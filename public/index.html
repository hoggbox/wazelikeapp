<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Waze-Like GPS App</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css?v=1.0.3">
  <link rel="manifest" href="/manifest.json?v=1.0.3">
  <script src="https://unpkg.com/@tweenjs/tween.js@23.1.3/dist/tween.umd.js?v=1.0.3"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js?v=1.0.3"></script>
  <style>
    * { box-sizing: border-box; }
    body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: Arial, sans-serif; }
    #map {
      height: 100vh;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      overflow: visible;
      background: #f0f0f0;
    }
    #compass {
      position: absolute; top: 10vh; right: 2vw; width: 40px; height: 40px; z-index: 1001;
      background: url('https://i.postimg.cc/YS0h0m7R/compass.png') no-repeat center center;
      background-size: contain; transition: transform 0.3s ease;
    }
    #search-container {
      position: absolute; top: 0.5vh; left: 50%; transform: translateX(-50%); width: 80%; max-width: 90vw; z-index: 1002;
      display: flex; align-items: center; background: white; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2);
      padding: 0.5rem; border: 1px solid #ccc;
    }
    #search-input {
      flex: 1; padding: 0.5rem; border: none; font-size: 1rem; outline: none; background: transparent; width: 100%;
    }
    #search-input::placeholder { color: #888; }
    #start-button, #simulate-position-button {
      background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.4rem;
      cursor: pointer; margin-left: 0.5rem; font-size: 1rem;
    }
    #simulate-position-button { background: #FF9800; }
    #start-button:hover, #simulate-position-button:hover { background: #45a049; }
    .hidden { display: none !important; }
    .pac-container {
      z-index: 1003; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); background: white;
      font-family: Arial, sans-serif; font-size: 1rem; width: 80% !important; max-width: 90vw; margin-top: 0.5rem;
    }
    .pac-item { padding: 0.5rem; cursor: pointer; color: #333; }
    .pac-item:hover { background: #f0f0f0; }
    #hud-container {
      position: absolute; top: 2vh; left: 50%; transform: translateX(-50%); width: 80%; max-width: 95vw; z-index: 1001;
      background: white; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); padding: 1vh;
      border: 1px solid #ccc; display: none; flex-direction: column; gap: 0.5vh;
    }
    #hud-turn { font-size: 1.2rem; font-weight: bold; color: #333; }
    #hud-street, #hud-heading { font-size: 0.9rem; color: #555; }
    #bottom-hud-container {
      position: absolute; bottom: 2vh; left: 50%; transform: translateX(-50%); width: 80%; max-width: 90vw; z-index: 1001;
      background: white; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); padding: 1vh;
      border: 1px solid #ccc; display: none; align-items: center; gap: 1vw;
    }
    #bottom-hud-stop {
      background: #d32f2f; color: white; border: none; padding: 0.5rem 0.8rem; border-radius: 0.4rem;
      cursor: pointer; font-size: 1rem; font-weight: bold;
    }
    #bottom-hud-stop:hover { background: #b71c1c; }
    #bottom-hud-info { flex: 1; text-align: center; }
    #bottom-hud-time { font-size: 1.2rem; font-weight: bold; color: #333; }
    #bottom-hud-distance { font-size: 0.9rem; color: #555; }
    #button-container {
      position: fixed; top: 50%; right: 2vw; transform: translateY(-50%); display: flex; flex-direction: column;
      gap: 1.2vh; padding: 1.5vmin; background: rgba(0, 0, 0, 0.3); border-radius: 0.5rem; z-index: 1001; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.3);
    }
    #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
      width: 5vw; height: 5vw; max-width: 40px; max-height: 40px; border: 0.1rem solid #fff; border-radius: 50%;
      box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; cursor: pointer;
    }
    #hazard-button { background: #ff4444; }
    #hazard-button::before { content: '+'; color: #00ff00; font-size: 1.2rem; font-weight: bold; }
    #hazard-button:hover { background: #cc0000; }
    #recenter-button { background: #4CAF50; }
    #recenter-button::before { content: '↻'; color: #fff; font-size: 1.2rem; font-weight: bold; }
    #recenter-button:hover { background: #45a049; }
    #voice-button { background: #FF5722; }
    #voice-button::before { content: '\f130'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #voice-button:hover { background: #E64A19; }
    #share-button { background: #2196F3; }
    #share-button::before { content: '\f1e0'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #share-button:hover { background: #1976D2; }
    #settings-button { background: #2196F3; }
    #settings-button::before { content: '\f013'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #settings-button:hover { background: #1976D2; }
    #current-alerts-button { background: #FF9800; }
    #current-alerts-button::before { content: '\f071'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #current-alerts-button:hover { background: #F57C00; }
    #leaderboard-button { background: #FFC107; }
    #leaderboard-button::before { content: '\f091'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #leaderboard-button:hover { background: #FFA000; }
    #admin-button { background: #9C27B0; display: none; }
    #admin-button::before { content: '\f085'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #admin-button:hover { background: #7B1FA2; }
    .report-container {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 1000;
    }
    #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) translateY(100%); width: 80vw;
      max-width: 300px; background: rgba(0, 0, 0, 0.7); border-radius: 0.5rem; padding: 1vmin; pointer-events: auto;
      display: none; flex-direction: column; transition: transform 0.3s ease; transform-origin: center; visibility: visible;
      overflow-y: auto; max-height: 80vh; color: white;
    }
    #admin-hud-container {
      max-width: 90vw;
      max-height: 90vh;
      width: 90vw;
    }
    #report-box.active, #reroute-hud-container.active, #settings-hud-container.active, #alerts-hud-container.active, #camera-hud-container.active, #leaderboard-hud-container.active, #arrival-hud-container.active, #admin-hud-container.active, #verification-hud-container.active, #user-profile-hud-container.active {
      display: flex; transform: translate(-50%, -50%); visibility: visible;
    }
    #report-box::before, #reroute-hud-container::before, #settings-hud-container::before, #alerts-hud-container::before, #camera-hud-container::before, #leaderboard-hud-container::before, #arrival-hud-container::before, #admin-hud-container::before, #verification-hud-container::before, #user-profile-hud-container::before {
      content: ''; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.3);
      z-index: -1; display: none;
    }
    #report-box.active::before, #reroute-hud-container.active::before, #settings-hud-container.active::before, #alerts-hud-container.active::before, #camera-hud-container.active::before, #leaderboard-hud-container.active::before, #arrival-hud-container.active::before, #admin-hud-container.active::before, #verification-hud-container.active::before, #user-profile-hud-container.active::before {
      display: block;
    }
    #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
      width: 100%; padding: 1vmin 0; position: relative; margin-bottom: 1vmin;
    }
    #report-close, #reroute-close, #settings-close, #alerts-close, #camera-close, #leaderboard-close, #arrival-close, #admin-close, #verification-close, #user-profile-close {
      position: absolute; top: 0.5vmin; right: 0.5vmin; background: #d32f2f; color: white; border: none;
      padding: 0.5vmin 1vmin; border-radius: 0.4rem; cursor: pointer; font-size: clamp(12px, 2.5vmin, 16px);
      font-weight: bold; z-index: 1;
    }
    #report-close:hover, #reroute-close:hover, #settings-close:hover, #alerts-close:hover, #camera-close:hover, #leaderboard-close:hover, #arrival-close:hover, #admin-close:hover, #verification-close:hover, #user-profile-close:hover {
      background: #b71c1c;
    }
    .report-options {
      flex: 1; display: grid; grid-template-columns: repeat(2, 1fr); gap: 1vmin; padding: 0.5vmin 0;
      padding-top: 2vmin; position: relative; width: 100%; height: 100%; overflow: hidden;
    }
    .report-button {
      background: rgba(255, 255, 255, 0.2); border: none; border-radius: 0.3rem; padding: 1vmin;
      text-align: center; cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
      display: flex; flex-direction: column; align-items: center; transition: background 0.2s;
      position: relative; width: 100%; height: 100%; vertical-align: middle; grid-column: auto; grid-row: auto;
    }
    .report-button:hover { background: rgba(255, 255, 255, 0.3); }
    .report-button i { font-size: clamp(12px, 2.5vmin, 16px); margin-bottom: 0.5vmin; }
    #confirm-alert {
      display: none; flex-direction: column; gap: 1vmin; padding: 1vmin; text-align: center;
    }
    #confirm-alert.active { display: flex; }
    #confirm-alert h3 { margin: 0; font-size: clamp(14px, 2.5vmin, 18px); color: white; }
    #confirm-alert p { margin: 0.5vmin 0; font-size: clamp(10px, 2vmin, 14px); color: white; }
    #post-alert-button, #cancel-alert-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #post-alert-button { background-color: #4CAF50; }
    #post-alert-button:hover { background-color: #45a049; }
    #cancel-alert-button { background-color: #d32f2f; }
    #cancel-alert-button:hover { background-color: #b71c1c; }
    #reroute-hud {
      display: none; flex-direction: column; gap: 1vmin; padding: 1vmin; text-align: center;
    }
    #reroute-hud.active { display: flex; }
    #reroute-hud h3 { margin: 0; font-size: clamp(14px, 2.5vmin, 18px); color: white; }
    #reroute-hud p { margin: 0.5vmin 0; font-size: clamp(10px, 2vmin, 14px); color: white; }
    #accept-reroute-button, #reject-reroute-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #accept-reroute-button { background-color: #4CAF50; }
    #accept-reroute-button:hover { background-color: #45a049; }
    #reject-reroute-button { background-color: #d32f2f; }
    #reject-reroute-button:hover { background-color: #b71c1c; }
    #settings-tabs, #alerts-tabs, #leaderboard-tabs, #admin-tabs {
      display: flex; border-bottom: 1px solid rgba(255, 255, 255, 0.3); margin-bottom: 1.5vmin;
    }
    .settings-tab, .alerts-tab, .leaderboard-tab, .admin-tab {
      flex: 1; padding: 0.5vmin; text-align: center; cursor: pointer; font-size: clamp(12px, 2.2vmin, 16px);
      color: rgba(255, 255, 255, 0.7); transition: color 0.2s, border-bottom 0.2s;
    }
    .settings-tab.active, .alerts-tab.active, .leaderboard-tab.active, .admin-tab.active {
      color: white; border-bottom: 2px solid #4CAF50;
    }
    .settings-tab:hover, .alerts-tab:hover, .leaderboard-tab:hover, .admin-tab:hover { color: white; }
    #settings-content {
      flex: 1; display: flex; flex-direction: column; gap: 1.5vmin; padding: 1.5vmin;
    }
    .settings-option {
      display: flex; justify-content: space-between; align-items: center; font-size: clamp(10px, 2vmin, 14px);
      padding-bottom: 1vmin; border-bottom: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .settings-option:last-child { border-bottom: none; }
    .settings-option label { color: white; font-weight: 600; }
    .settings-option select {
      padding: 0.5vmin; border-radius: 0.3rem; border: none; font-size: clamp(10px, 2vmin, 14px);
      background: #333; color: white; width: 50%; transition: background 0.2s;
    }
    .settings-option select:hover { background: #444; }
    .settings-option input[type="checkbox"] {
      appearance: none; width: 1.5rem; height: 1.5rem; background: #555; border-radius: 0.3rem;
      cursor: pointer; transition: background 0.2s;
    }
    .settings-option input[type="checkbox"]:checked {
      background: #333; position: relative;
    }
    .settings-option input[type="checkbox"]:checked::before {
      content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #4CAF50;
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1rem;
    }
    .settings-option input[type="checkbox"]:hover { background: #666; }
    .settings-option input[type="range"] { width: 50%; cursor: pointer; }
    .settings-option .slider-value { font-size: clamp(10px, 2vmin, 14px); color: white; }
    #recalibrate-compass-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #4CAF50;
    }
    #recalibrate-compass-button:hover { background-color: #45a049; }
    #logout-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #d32f2f;
    }
    #logout-button:hover { background-color: #b71c1c; }
    #edit-profile-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #2196F3;
    }
    #edit-profile-button:hover { background-color: #1976D2; }
    #save-profile, #cancel-edit {
      margin: 0.5vmin 0.25vmin; padding: 0.5vmin 1vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #save-profile { background-color: #4CAF50; }
    #save-profile:hover { background-color: #45a049; }
    #cancel-edit { background-color: #d32f2f; }
    #cancel-edit:hover { background-color: #b71c1c; }
    #edit-profile-form input {
      width: 100%; padding: 0.5vmin; margin-bottom: 0.5vmin; border: none; border-radius: 0.3rem;
      background: #333; color: white; font-size: clamp(10px, 2vmin, 14px);
    }
    #edit-profile-form input::placeholder { color: #ccc; }
    .profile-info {
      display: flex; flex-direction: column; gap: 0.5vmin; padding: 1vmin; background: rgba(255,255,255,0.1);
      border-radius: 0.3rem; margin-bottom: 1vmin;
    }
    .profile-info div { color: white; font-size: clamp(10px, 2vmin, 14px); }
    #user-profile-content { flex: 1; padding: 1vmin; overflow-y: auto; }
    #toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7);
      color: white; padding: 0.8vmin 1.5vmin; border-radius: 0.4rem; z-index: 1003; transition: opacity 0.5s;
      opacity: 0; font-size: clamp(10px, 2vmin, 14px); pointer-events: none; max-width: 90vw; text-align: center;
    }
    #toast.visible-toast { opacity: 1; }
    #tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.8rem;
      z-index: 1004;
      pointer-events: none;
      display: none;
      white-space: nowrap;
      box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2);
    }
    .alerts-tab-content, .leaderboard-tab-content, .admin-tab-content {
      flex: 1; overflow-y: auto; padding: 1.5vmin; display: none;
    }
    .alert-item {
      margin-bottom: 1.5vmin; padding: 1vmin; border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 0.3rem; background: rgba(255, 255, 255, 0.1);
    }
    .alert-field {
      font-size: clamp(10px, 2vmin, 14px); margin-bottom: 0.5vmin; color: white;
    }
    .alert-field a { color: #4CAF50; text-decoration: none; cursor: pointer; }
    .alert-field a:hover { text-decoration: underline; }
    .alert-votes {
      display: flex; justify-content: space-between; margin: 0.5vmin 0;
    }
    .vote-btn {
      padding: 0.5vmin 1vmin; border: none; border-radius: 0.3rem; cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    .upvote-btn { background: #4CAF50; }
    .upvote-btn:hover { background: #45a049; }
    .downvote-btn { background: #d32f2f; }
    .downvote-btn:hover { background: #b71c1c; }
    .alert-actions { display: flex; gap: 1vmin; margin-top: 1vmin; }
    .center-btn, .delete-btn, #center-alerts-btn {
      background: #4CAF50; color: white; border: none; padding: 0.5vmin 1vmin; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px);
    }
    .delete-btn { background: #d32f2f; margin-left: 0.5vmin; }
    .center-btn:hover, #center-alerts-btn:hover { background: #45a049; }
    .delete-btn:hover { background: #b71c1c; }
    .traffic-cam-marker { width: 40px; height: 40px; }
    #camera-hud, #arrival-hud, #verification-hud {
      display: none; flex-direction: column; gap: 1vmin; padding: 1vmin; text-align: center;
    }
    #camera-hud.active, #arrival-hud.active, #verification-hud.active { display: flex; }
    #camera-hud h3, #arrival-hud h3, #verification-hud h3 { margin: 0; font-size: clamp(14px, 2.5vmin, 18px); color: white; }
    #camera-hud p, #arrival-hud p, #verification-hud p { margin: 0.5vmin 0; font-size: clamp(10px, 2vmin, 14px); color: white; }
    #dismiss-camera-button, #arrival-ok-button, .verification-btn {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #dismiss-camera-button { background-color: #d32f2f; }
    #arrival-ok-button { background-color: #d32f2f; }
    #dismiss-camera-button:hover, #arrival-ok-button:hover, .verification-btn:hover { background-color: #b71c1c; }
    .verification-btn { background-color: #d32f2f; }
    .confirm-btn { background-color: #4CAF50; }
    .confirm-btn:hover { background-color: #45a049; }
    #high-contrast { filter: contrast(1.5); }
    .ping {
      animation: ping 1s ease-in-out infinite;
    }
    @keyframes ping {
      0% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.5); opacity: 0.4; }
      100% { transform: scale(1); opacity: 0.8; }
    }
    #multi-stop-inputs {
      display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;
    }
    #multi-stop-inputs input {
      padding: 0.5rem; border: 1px solid #ccc; border-radius: 0.3rem; font-size: 0.9rem;
    }
    .family-member {
      display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: rgba(255,255,255,0.1); margin-bottom: 0.5rem; border-radius: 0.3rem;
    }
    .remove-family { background: #d32f2f; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 0.2rem; cursor: pointer; }
    #offline-download-btn { background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; margin-top: 0.5rem; }
    #admin-search { width: 100%; padding: 0.5rem; margin-bottom: 1rem; border-radius: 0.3rem; border: none; background: #333; color: white; }
    #admin-search::placeholder { color: #ccc; }
    #search-users-btn { background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; margin-left: 0.5rem; }
    #users-list table { width: 100%; border-collapse: collapse; color: white; margin-top: 1rem; }
    #users-list th, #users-list td { border: 1px solid rgba(255,255,255,0.3); padding: 0.5rem; text-align: left; }
    #users-list button { margin-right: 0.5rem; padding: 0.3rem 0.6rem; font-size: clamp(8px, 1.5vmin, 12px); cursor: pointer; border-radius: 0.2rem; border: none; }
    #admin-user-activity { margin-top: 1rem; }
    #admin-user-activity ul { list-style: none; padding: 0; }
    #admin-user-activity li { padding: 0.5rem; background: rgba(255,255,255,0.1); margin-bottom: 0.5rem; border-radius: 0.3rem; }
    .admin-action-btn { background: #d32f2f; color: white; }
    .admin-action-btn:hover { background: #b71c1c; }
    .admin-promote-btn { background: #4CAF50; color: white; }
    .admin-promote-btn:hover { background: #45a049; }
    .accordion-header {
      background: rgba(255, 255, 255, 0.2); color: white; padding: 0.8vmin; cursor: pointer;
      border-radius: 0.3rem; margin-bottom: 0.5vmin; font-size: clamp(12px, 2.2vmin, 16px);
      transition: background 0.2s; display: flex; align-items: center; justify-content: space-between;
    }
    .accordion-header:hover { background: rgba(255, 255, 255, 0.3); }
    .accordion-header::after {
      content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1rem; color: white;
    }
    .accordion-header.active::after { content: '\f077'; }
    .accordion-content {
      display: none; padding: 1vmin; background: rgba(255, 255, 255, 0.1); border-radius: 0.3rem;
    }
    .accordion-content.active { display: block; }
    @media (max-width: 414px) {
      #button-container { right: 3vw; gap: 1.5vh; padding: 1.5vmin; }
      #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
        width: 8vw; height: 8vw; max-width: 32px; max-height: 32px;
      }
      #compass { width: 32px; height: 32px; top: 12vh; right: 3vw; }
      #hazard-button::before, #recenter-button::before, #settings-button::before, #current-alerts-button::before, #voice-button::before, #share-button::before, #leaderboard-button::before, #admin-button::before {
        font-size: 1rem;
      }
      #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
        width: 90vw; max-width: none; padding: 1.5vmin;
      }
      #admin-hud-container {
        width: 95vw;
        max-width: none;
      }
      #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
        padding: 1vmin 0; margin-bottom: 1vmin;
      }
      .report-options { gap: 1.5vmin; padding-top: 2.5vmin; }
      .report-button { font-size: clamp(9px, 1.8vmin, 13px); }
      .report-button i { font-size: clamp(11px, 2.2vmin, 14px); }
      #toast { width: 90vw; max-width: none; }
      .alert-field { font-size: clamp(9px, 1.8vmin, 13px); }
      .center-btn, .delete-btn, #center-alerts-btn { font-size: clamp(9px, 1.8vmin, 13px); }
      .traffic-cam-marker { width: 32px; height: 32px; }
      .settings-option .slider-value { font-size: clamp(9px, 1.8vmin, 13px); }
      .vote-btn { font-size: clamp(9px, 1.8vmin, 13px); }
      #users-list th, #users-list td { padding: 0.3rem; font-size: 0.8rem; }
    }
    @media (min-width: 415px) and (max-width: 768px) {
      #button-container { right: 2.5vw; gap: 1.2vh; padding: 1.5vmin; }
      #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
        width: 6vw; height: 6vw; max-width: 36px; max-height: 36px;
      }
      #compass { width: 36px; height: 36px; top: 11vh; right: 2.5vw; }
      #hazard-button::before, #recenter-button::before, #settings-button::before, #current-alerts-button::before, #voice-button::before, #share-button::before, #leaderboard-button::before, #admin-button::before {
        font-size: 1.1rem;
      }
      #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
        width: 80vw; max-width: 320px; padding: 1.2vmin;
      }
      #admin-hud-container {
        width: 85vw;
        max-width: 500px;
      }
      #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
        padding: 1vmin 0; margin-bottom: 1vmin;
      }
      .report-options { gap: 1.2vmin; padding-top: 2vmin; }
      .report-button { font-size: clamp(10px, 2vmin, 14px); }
      #toast { width: 80vw; max-width: 320px; }
    }
    @media (min-width: 769px) {
      #button-container { right: 2vw; gap: 1vh; padding: 1.5vmin; }
      #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
        width: 5vw; height: 5vw; max-width: 40px; max-height: 40px;
      }
      #compass { width: 40px; height: 40px; top: 10vh; right: 2vw; }
      #hazard-button::before, #recenter-button::before, #settings-button::before, #current-alerts-button::before, #voice-button::before, #share-button::before, #leaderboard-button::before, #admin-button::before {
        font-size: 1.2rem;
      }
      #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
        width: 30vw; max-width: 300px; padding: 1vmin;
      }
      #admin-hud-container {
        width: 60vw;
        max-width: 800px;
      }
      #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
        padding: 1vmin 0; margin-bottom: 1vmin;
      }
      .report-options { gap: 1vmin; padding-top: 2vmin; }
      .report-button { font-size: clamp(10px, 2vmin, 14px); }
      #toast { width: 30vw; max-width: 300px; }
    }
    @media (orientation: landscape) { #hud-container, #bottom-hud-container { width: 60%; } }
    @media (orientation: portrait) { #hud-container, #bottom-hud-container { width: 80%; } }
    #auth-container {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8);
      z-index: 10000; display: none; justify-content: center; align-items: center; flex-direction: column;
      color: white; font-family: Arial, sans-serif;
    }
    #auth-title { font-size: 2rem; margin-bottom: 1rem; }
    #auth-form {
      display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 300px;
      padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem;
    }
    #auth-form input {
      padding: 0.5rem; border: none; border-radius: 0.3rem; font-size: 1rem;
      background: #333; color: white; outline: none;
    }
    #auth-form input::placeholder { color: #ccc; }
    #auth-form button {
      background: #4CAF50; color: white; border: none; padding: 0.5rem; border-radius: 0.3rem;
      cursor: pointer; font-size: 1rem; transition: background 0.2s;
    }
    #auth-form button:hover { background: #45a049; }
    #auth-switch { margin-top: 1rem; font-size: 0.9rem; }
    #auth-switch a { color: #4CAF50; text-decoration: none; }
    #auth-switch a:hover { text-decoration: underline; }
    #admin-content { flex: 1; padding: 1vmin; overflow-y: auto; display: flex; flex-direction: column; }
    #admin-tabs { margin-bottom: 1rem; }
    .admin-tab-content { padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem; }
    #user-search-container { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
    #user-search { flex: 1; padding: 0.5rem; border-radius: 0.3rem; border: none; background: #333; color: white; }
    #search-users-btn { background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; }
    #show-all-users-btn { background: #2196F3; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; margin-top: 0.5rem; }
    #users-list { margin-top: 1rem; overflow-x: auto; }
    #users-list table { width: 100%; border-collapse: collapse; color: white; min-width: 600px; }
    #users-list th, #users-list td { border: 1px solid rgba(255,255,255,0.3); padding: 0.8rem; text-align: left; }
    #users-list th { background: rgba(255,255,255,0.1); }
    #users-list button { margin-right: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.9rem; cursor: pointer; border-radius: 0.3rem; border: none; }
    .delete-btn, .ban-btn { background: #d32f2f; color: white; }
    .delete-btn:hover, .ban-btn:hover { background: #b71c1c; }
    .ipban-btn { background: #f44336; color: white; }
    .ipban-btn:hover { background: #d32f2f; }
    .promote-btn { background: #4CAF50; color: white; }
    .promote-btn:hover { background: #45a049; }
    .demote-btn { background: #FF9800; color: white; }
    .demote-btn:hover { background: #F57C00; }
    .view-activity-btn { background: #2196F3; color: white; }
    .view-activity-btn:hover { background: #1976D2; }
    #user-activity-list { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; }
    #user-activity-list li { padding: 0.5rem; background: rgba(255,255,255,0.05); margin-bottom: 0.5rem; border-radius: 0.3rem; border-left: 3px solid #4CAF50; }
    #user-activity-list li strong { color: #4CAF50; }
    .no-activity { text-align: center; color: #ccc; font-style: italic; }
    /* Premium Modal Styles */
    .premium-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center; }
    .premium-modal button { margin: 0.5rem; padding: 0.5rem 1rem; border: none; border-radius: 0.3rem; cursor: pointer; color: white; }
    .premium-toggle input, .premium-toggle select { opacity: 0.5; }
    .premium-toggle input:disabled, .premium-toggle select:disabled { opacity: 0.5; background: #555; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="compass"></div>
  <div id="search-container">
    <input id="search-input" type="text" placeholder="Enter destination address">
    <div id="multi-stop-inputs" style="display: none;">
      <input type="text" placeholder="Add stop 1">
      <input type="text" placeholder="Add stop 2">
      <input type="text" placeholder="Add stop 3">
    </div>
    <button id="start-button">Start</button>
    <button id="simulate-position-button" style="display: none;">Simulate</button>
  </div>
  <div id="hud-container">
    <div id="hud-turn">Follow the road</div>
    <div id="hud-street">Current street: Unknown</div>
    <div id="hud-heading">Heading: Unknown</div>
  </div>
  <div id="bottom-hud-container">
    <button id="bottom-hud-stop">X</button>
    <div id="bottom-hud-info">
      <div id="bottom-hud-time">0 Mins</div>
      <div id="bottom-hud-distance">0 miles - Unknown</div>
    </div>
  </div>
  <div id="button-container">
    <div id="hazard-button"></div>
    <div id="recenter-button"></div>
    <div id="voice-button"></div>
    <div id="share-button"></div>
    <div id="settings-button"></div>
    <div id="current-alerts-button"></div>
    <div id="leaderboard-button"></div>
    <div id="admin-button"></div>
  </div>
  <div id="tooltip"></div>
  <div class="report-container">
    <div id="report-box">
      <header>
        <button id="report-close">X</button>
      </header>
      <div class="report-options">
        <div class="report-button" data-alert-type="Slowdown"><i class="fas fa-car"></i>Slowdown&nbsp;</div>
        <div class="report-button" data-alert-type="Crash"><i class="fas fa-car-crash"></i>Crash&nbsp;</div>
        <div class="report-button" data-alert-type="Construction"><i class="fas fa-tools"></i>Construction&nbsp;</div>
        <div class="report-button" data-alert-type="Police"><i class="fas fa-user-shield"></i>Police&nbsp;</div>
        <div class="report-button" data-alert-type="Object on Road"><i class="fas fa-road"></i>Object on Road&nbsp;</div>
        <div class="report-button" data-alert-type="Lane Closure"><i class="fas fa-road-barrier"></i>Lane Closure&nbsp;</div>
        <div class="report-button" data-alert-type="Manual Report"><i class="fas fa-comment"></i>Manual Report&nbsp;</div>
        <div class="report-button" data-alert-type="Low Visibility"><i class="fas fa-eye-slash"></i>Low Visibility&nbsp;</div>
        <div class="report-button" data-alert-type="Traffic Camera"><i class="fas fa-camera"></i>Traffic Camera&nbsp;</div>
        <div class="report-button" data-alert-type="Manual Traffic Camera"><i class="fas fa-camera-retro"></i>Manual Traffic Camera&nbsp;</div>
      </div>
      <div id="confirm-alert">
        <h3>Confirm Alert Location</h3>
        <p>Alert Type: <span id="alert-type-display"></span></p>
        <p>Location: <span id="location-display"></span></p>
        <p>Timestamp: <span id="timestamp-display"></span></p>
        <button id="post-alert-button">Post</button>
        <button id="cancel-alert-button">Cancel</button>
      </div>
    </div>
  </div>
  <div id="reroute-hud-container">
    <header>
      <button id="reroute-close">X</button>
    </header>
    <div id="reroute-hud">
      <h3>Reroute Available</h3>
      <p id="hazard-message"></p>
      <button id="accept-reroute-button">Accept</button>
      <button id="reject-reroute-button">Reject</button>
    </div>
  </div>
  <div id="settings-hud-container">
    <header>
      <button id="settings-close">X</button>
    </header>
    <div id="settings-content">
      <div class="accordion">
        <div class="accordion-item">
          <div class="accordion-header active" onclick="toggleAccordion(this)">Map Settings</div>
          <div class="accordion-content active">
            <div class="settings-option">
              <label for="map-type">Map Type</label>
              <select id="map-type">
                <option value="roadmap">Roadmap</option>
                <option value="satellite">Satellite</option>
                <option value="hybrid">Hybrid</option>
                <option value="terrain">Terrain</option>
              </select>
            </div>
            <div class="settings-option premium-toggle" data-prompt="Custom HUDs">
              <label for="map-skin">Map Skin</label>
              <select id="map-skin">
                <option value="default">Default</option>
                <option value="dark">Dark</option>
                <option value="green">Green</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="map-orientation">Map Orientation</label>
              <select id="map-orientation">
                <option value="heading-up">Heading-Up</option>
                <option value="north-up">North-Up</option>
              </select>
            </div>
            <div class="settings-option premium-toggle" data-prompt="Custom HUDs">
              <label for="high-contrast-toggle">High Contrast Mode</label>
              <input type="checkbox" id="high-contrast-toggle">
            </div>
            <div class="settings-option premium-toggle" data-prompt="Custom HUDs">
              <label for="main-route-color">Main Route Color</label>
              <select id="main-route-color">
                <option value="#4285F4">Blue</option>
                <option value="#FF0000">Red</option>
                <option value="#008000">Green</option>
                <option value="#800080">Purple</option>
              </select>
            </div>
            <div class="settings-option premium-toggle" data-prompt="Custom HUDs">
              <label for="alt-route-color">Alternate Route Color</label>
              <select id="alt-route-color">
                <option value="#FFA500">Orange</option>
                <option value="#FFFF00">Yellow</option>
                <option value="#FF69B4">Pink</option>
                <option value="#00CED1">Cyan</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="traffic-layer-toggle">Show Traffic Layer</label>
              <input type="checkbox" id="traffic-layer-toggle">
            </div>
            <div class="settings-option">
              <label for="traffic-camera-toggle">Show Traffic Camera Alerts</label>
              <input type="checkbox" id="traffic-camera-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="hazard-alert-distance">Hazard Alert Distance (miles)</label>
              <div>
                <input type="range" id="hazard-alert-distance" min="1" max="5" value="2" step="0.5">
                <span class="slider-value" id="hazard-distance-value">2 miles</span>
              </div>
            </div>
            <div class="settings-option">
              <label for="camera-alert-distance">Camera Alert Distance (miles)</label>
              <div>
                <input type="range" id="camera-alert-distance" min="0.5" max="2" value="0.5" step="0.5">
                <span class="slider-value" id="camera-distance-value">0.5 miles</span>
              </div>
            </div>
            <div class="settings-option">
              <label for="use-default-distances">Use Default Distances</label>
              <input type="checkbox" id="use-default-distances" checked>
            </div>
            <div class="settings-option">
              <label for="auto-recenter-toggle">Auto-Recenter</label>
              <input type="checkbox" id="auto-recenter-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="voice-assistant-toggle">Voice Assistant (Nova)</label>
              <input type="checkbox" id="voice-assistant-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="push-notifications-toggle">Push Notifications</label>
              <input type="checkbox" id="push-notifications-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="show-tooltips-toggle">Show Tooltips</label>
              <input type="checkbox" id="show-tooltips-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="recalibrate-compass-button">Recalibrate Compass</label>
              <button id="recalibrate-compass-button">Calibrate</button>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Advanced Alerts</div>
          <div class="accordion-content">
            <div class="settings-option premium-toggle" data-prompt="Advanced Alerts">
              <label for="alert-radius">Alert Radius (miles)</label>
              <div>
                <input type="range" id="alert-radius" min="1" max="20" value="10" step="1">
                <span class="slider-value" id="alert-radius-value">10 miles</span>
              </div>
            </div>
            <div class="settings-option premium-toggle" data-prompt="Advanced Alerts">
              <label>Custom Filters</label>
              <div style="display: flex; flex-direction: column; gap: 0.5vmin; width: 50%;">
                <label><input type="checkbox" id="filter-police" checked> Police Only</label>
                <label><input type="checkbox" id="filter-crash"> Crashes</label>
                <label><input type="checkbox" id="filter-construction"> Construction</label>
              </div>
            </div>
            <div class="settings-option premium-toggle" data-prompt="Advanced Alerts">
              <label for="traffic-forecast-toggle">Enable Traffic Forecast</label>
              <input type="checkbox" id="traffic-forecast-toggle" checked>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Route Options</div>
          <div class="accordion-content">
            <div class="settings-option premium-toggle" data-prompt="Multi-Stop Planning">
              <label for="multi-stop-toggle">Enable Multi-Stop Planning</label>
              <input type="checkbox" id="multi-stop-toggle">
            </div>
            <div class="settings-option premium-toggle" data-prompt="EV Charging">
              <label for="ev-charging-toggle">Integrate EV Charging</label>
              <input type="checkbox" id="ev-charging-toggle">
            </div>
            <div class="settings-option">
              <label for="route-preset">Route Preset</label>
              <select id="route-preset">
                <option value="default">Default</option>
                <option value="scenic">Scenic</option>
                <option value="avoid-toll">Avoid Tolls</option>
                <option value="family">Family Road Trip</option>
              </select>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Offline Maps</div>
          <div class="accordion-content">
            <div class="settings-option premium-toggle" data-prompt="Offline Maps">
              <label>Downloaded Regions</label>
              <div id="offline-regions-list" style="display: flex; flex-direction: column; gap: 0.5vmin; width: 50%;"></div>
            </div>
            <button id="offline-download-btn">Download Current Region</button>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Family Sharing</div>
          <div class="accordion-content">
            <div class="settings-option premium-toggle" data-prompt="Family Sharing">
              <label>Family Members (up to 5)</label>
              <div id="family-list" style="display: flex; flex-direction: column; gap: 0.5vmin; width: 50%;"></div>
            </div>
            <input id="add-family-input" type="text" placeholder="Add family member email">
            <button id="add-family-btn">Add</button>
            <button id="share-route-btn">Share Current Route</button>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Account</div>
          <div class="accordion-content">
            <div class="profile-info">
              <div><strong>Username:</strong> <span id="username-display">Loading...</span></div>
              <div><strong>Email:</strong> <span id="email-display">Loading...</span></div>
              <div><strong>Join Date:</strong> <span id="join-date-display">Loading...</span></div>
              <div><strong>Total Alerts Posted:</strong> <span id="total-alerts-display">Loading...</span></div>
              <div><strong>Active Alerts:</strong> <span id="active-alerts-display">Loading...</span></div>
              <div><strong>Points:</strong> <span id="points-display">Loading...</span></div>
            </div>
            <button id="edit-profile-button">Edit Profile</button>
            <div id="edit-profile-form" style="display: none;">
              <input id="edit-username" placeholder="New Username" type="text">
              <input id="edit-email" placeholder="New Email" type="email">
              <input id="edit-password" placeholder="New Password (optional)" type="password">
              <button id="save-profile">Save</button>
              <button id="cancel-edit">Cancel</button>
            </div>
            <button id="logout-button">Logout</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="alerts-hud-container">
    <header>
      <button id="alerts-close">X</button>
    </header>
    <div id="alerts-tabs">
      <div class="alerts-tab active" data-tab="information">Information</div>
      <div class="alerts-tab" data-tab="tools">Tools</div>
    </div>
    <div id="information" class="alerts-tab-content"></div>
    <div id="tools" class="alerts-tab-content" style="display: none;">
      <button id="center-alerts-btn">Center on Alerts</button>
    </div>
  </div>
  <div id="camera-hud-container">
    <header>
      <button id="camera-close">X</button>
    </header>
    <div id="camera-hud">
      <h3>Traffic Camera Ahead</h3>
      <p>Traffic enforcement camera in the area. Drive safely!</p>
      <button id="dismiss-camera-button">Dismiss</button>
    </div>
  </div>
  <div id="arrival-hud-container">
    <header>
      <button id="arrival-close">X</button>
    </header>
    <div id="arrival-hud">
      <h3>You've arrived!</h3>
      <button id="arrival-ok-button">OK</button>
    </div>
  </div>
  <div id="verification-hud-container">
    <header>
      <button id="verification-close">X</button>
    </header>
    <div id="verification-hud">
      <h3>Alert Verification</h3>
      <p id="verification-message">You have passed an alert. Is it still valid?</p>
      <button class="verification-btn confirm-btn" id="confirm-alert-btn">Confirm (Still Valid)</button>
      <button class="verification-btn" id="dismiss-alert-btn">Dismiss (No Longer Valid)</button>
    </div>
  </div>
  <div id="leaderboard-hud-container">
    <header>
      <button id="leaderboard-close">X</button>
    </header>
    <div id="leaderboard-content" class="leaderboard-tab-content"></div>
  </div>
  <div id="admin-hud-container">
    <header>
      <button id="admin-close">X</button>
      <h2>Admin Panel</h2>
    </header>
    <div id="admin-tabs">
      <div class="admin-tab active" data-tab="users">Users</div>
      <div class="admin-tab" data-tab="activity">User Activity</div>
    </div>
    <div id="admin-content">
      <div id="users" class="admin-tab-content">
        <div id="user-search-container">
          <input id="user-search" type="text" placeholder="Search users by username or email">
          <button id="search-users-btn">Search</button>
        </div>
        <button id="show-all-users-btn">Show All Users</button>
        <div id="users-list"></div>
      </div>
      <div id="activity" class="admin-tab-content">
        <div id="user-search-container">
          <input id="activity-user-search" type="text" placeholder="Enter user ID or username for activity">
          <button id="load-activity-btn">Load Activity</button>
        </div>
        <div id="user-activity-list"></div>
      </div>
    </div>
  </div>
  <div id="user-profile-hud-container">
    <header>
      <button id="user-profile-close">X</button>
    </header>
    <div id="user-profile-content">
      <div class="profile-info">
        <div><strong>Username:</strong> <span id="hud-username">Loading...</span></div>
        <div><strong>Join Date:</strong> <span id="hud-join-date">Loading...</span></div>
        <div><strong>Total Alerts Posted:</strong> <span id="hud-total-alerts">Loading...</span></div>
        <div><strong>Active Alerts:</strong> <span id="hud-active-alerts">Loading...</span></div>
        <div><strong>Points:</strong> <span id="hud-points">Loading...</span></div>
      </div>
    </div>
  </div>
  <div id="toast"></div>
  <div id="premium-modal" class="premium-modal">
    <div style="background: white; color: #333; padding: 2rem; border-radius: 0.5rem; max-width: 300px; text-align: center;">
      <h3>Your trial's up—pay ten bucks for a year of Nova Drive perks?</h3>
      <p>Unlock custom HUDs, advanced alerts, speed trap icons, and more!</p>
      <button id="upgrade-btn">Upgrade Now</button>
      <button id="dismiss-premium">Maybe Later</button>
    </div>
  </div>
  <div id="auth-container" style="display: none;">
    <h2 id="auth-title">Login</h2>
    <form id="auth-form" style="display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 300px; padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem;">
      <input type="text" id="username" name="username" placeholder="Username" style="display: none;">
      <input type="email" id="email" name="email" placeholder="Email" required>
      <input type="password" id="password" name="password" placeholder="Password" required>
      <button type="submit">Submit</button>
    </form>
    <p id="auth-switch">Don't have an account? <a href="#" style="color: #4CAF50;" onclick="switchAuthMode()">Register</a></p>
  </div>
  <script>
    const VAPID_PUBLIC_KEY = 'BNclrc97FLwjMZNchCLjpVHHOMtP4FfxR9gvXZAT0tv0rzPREQ91v37M-Aa-D0hAygzmIKhMDeSLpmhG-NohTvs';
    const API_KEY = 'AIzaSyBSW8iQAE1AjjouEu4df-Cvq1ceUMLBit4';
    const mapId = '2666b5bd496d9c6026f43f82';
    const mapSkins = {
      default: [],
      dark: [
        {elementType: 'geometry', stylers: [{color: '#242f3e'}]},
        {elementType: 'labels.text.stroke', stylers: [{color: '#242f3e'}]},
        {elementType: 'labels.text.fill', stylers: [{color: '#746855'}]},
        {featureType: 'administrative.locality', elementType: 'labels.text.fill', stylers: [{color: '#d59563'}]},
        {featureType: 'poi', elementType: 'labels.text.fill', stylers: [{color: '#d59563'}]},
        {featureType: 'poi.park', elementType: 'geometry', stylers: [{color: '#263c3f'}]},
        {featureType: 'poi.park', elementType: 'labels.text.fill', stylers: [{color: '#6b9a76'}]},
        {featureType: 'road', elementType: 'geometry', stylers: [{color: '#38414e'}]},
        {featureType: 'road', elementType: 'geometry.stroke', stylers: [{color: '#212a37'}]},
        {featureType: 'road', elementType: 'labels.text.fill', stylers: [{color: '#9ca5b3'}]},
        {featureType: 'road.highway', elementType: 'geometry', stylers: [{color: '#746855'}]},
        {featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{color: '#1f2835'}]},
        {featureType: 'road.highway', elementType: 'labels.text.fill', stylers: [{color: '#f3d19c'}]},
        {featureType: 'transit', elementType: 'geometry', stylers: [{color: '#2f3948'}]},
        {featureType: 'transit.station', elementType: 'labels.text.fill', stylers: [{color: '#d59563'}]},
        {featureType: 'water', elementType: 'geometry', stylers: [{color: '#17263c'}]},
        {featureType: 'water', elementType: 'labels.text.fill', stylers: [{color: '#515c6d'}]},
        {featureType: 'water', elementType: 'labels.text.stroke', stylers: [{color: '#17263c'}]}
      ],
      green: [
        {featureType: 'all', elementType: 'all', stylers: [{saturation: 20}, {lightness: 10}]},
        {featureType: 'poi.park', elementType: 'geometry', stylers: [{color: '#4a8a4a'}, {lightness: 0}]},
        {featureType: 'landscape', elementType: 'geometry', stylers: [{color: '#8dc869'}, {lightness: 10}]},
        {featureType: 'road', elementType: 'geometry', stylers: [{lightness: 10}, {color: '#a3c6a3'}]},
        {featureType: 'road.highway', elementType: 'geometry', stylers: [{color: '#90c690'}]},
        {featureType: 'water', elementType: 'geometry', stylers: [{color: '#6bb6ff'}, {lightness: 10}]},
        {featureType: 'administrative', elementType: 'labels.text.fill', stylers: [{color: '#4a8a4a'}]}
      ]
    };
    let map, userMarker, destMarker, directionsService, directionsRenderer, alternativeRenderer, trafficLayer, watchId, socket, speechRecognition, routePolyline, offRoadPolyline;
    let currentAlerts = [];
    let cameraCheckInterval = null;
    let alertPollInterval = null;
    let cameraPositions = [];
    let cameraAlertShown = new Set();
    let positionHistory = [];
    let showTrafficCameras = localStorage.getItem('showTrafficCameras') !== 'false';
    let hazardAlertDistance = parseFloat(localStorage.getItem('hazardAlertDistance')) || 2;
    let cameraAlertDistance = parseFloat(localStorage.getItem('cameraAlertDistance')) || 0.5;
    let useDefaultDistances = localStorage.getItem('useDefaultDistances') !== 'false';
    let highContrastMode = localStorage.getItem('highContrastMode') === 'true';
    let pushNotificationsEnabled = localStorage.getItem('pushNotificationsEnabled') !== 'false';
    let mapOrientation = localStorage.getItem('mapOrientation') || 'heading-up';
    let mapSkin = localStorage.getItem('mapSkin') || 'default';
    let voiceAssistantEnabled = localStorage.getItem('voiceAssistantEnabled') !== 'false';
    let showTooltips = localStorage.getItem('showTooltips') !== 'false';
    let isInitialized = false;
    let toastTimeout = null;
    let lastHeading = 0;
    let lastStableHeading = 0;
    let lastSpokenTurn = '';
    let lastAnnouncementTime = 0;
    let headingHistory = [];
    let lastLocationUpdate = 0;
    let lastAlertFetchTime = 0;
    let lastPosition = null;
    let compassHeading = 0;
    let retryCount = 0;
    let rawUserLocation = null;
    let needsCalibration = false;
    let lastCameraUpdate = 0;
    let isHeadingTweening = false;
    let isAdmin = localStorage.getItem('isAdmin') === 'true';
    let isPremium = localStorage.getItem('isPremium') === 'true';
    let trackingUsers = [];
    let trackedMarkers = new Map();
    const markers = new Map();
    const MAX_RETRIES = 5;
    const REROUTE_CHECK_INTERVAL = 2000;
    const OFF_ROUTE_TOLERANCE = 50;
    const MIN_REROUTE_DISTANCE = 100;
    const MIN_ALERT_DISTANCE = 152.4;
    const CAMERA_CHECK_INTERVAL = 10000;
    const ALERT_POLL_INTERVAL = 5000;
    const HEADING_SMOOTHING_WINDOW = 15;
    const POSITION_HISTORY_WINDOW = 5;
    const MIN_ZOOM = 16;
    const MAX_ZOOM = 19;
    const TURN_ZOOM = 19;
    const STRAIGHT_ZOOM = 16.5;
    const TURN_THRESHOLD = 300;
    const HEADING_CHANGE_THRESHOLD = 15;
    const MIN_HEADING_CHANGE = 8;
    const CAMERA_UPDATE_THRESHOLD = 50;
    const STATIONARY_SPEED_THRESHOLD = 2.2352;
    const ARRIVAL_RADIUS = 50;
    const ANNOUNCEMENT_COOLDOWN = 10000;
    const ALERT_FETCH_INTERVAL = 30000;
    const ALTERNATE_TRIGGER_DISTANCE = 50;
    const SNAP_BUFFER = 30;
    const MAX_GPS_DISTANCE = 300;
    const HEADING_VARIANCE_THRESHOLD = 45;
    const SIGNIFICANT_TURN_THRESHOLD = 30;
    const VERIFICATION_DISTANCE = 50;
    let navState = {
      currentRoute: null,
      isNavigating: false,
      isFollowing: localStorage.getItem('isFollowing') === 'true',
      mapOrientation: mapOrientation,
      destination: null,
      userLocation: { lat: 33.083270, lng: -83.233040 },
      previousUserLocation: null,
      lastKnownPosition: null,
      routePolyline: null,
      rerouteCheckTimeout: null,
      hazardCheckInterval: null,
      currentHeading: 0,
      alertState: 'IDLE',
      tempMarker: null,
      tempAlertData: null,
      alternativeRoute: null,
      originalRoute: null,
      mapClickListener: null,
      ignoredHazards: [],
      currentHazard: null,
      pendingReroute: null,
      navigationZoom: 18,
      mainRouteColor: localStorage.getItem('mainRouteColor') || '#4285F4',
      altRouteColor: localStorage.getItem('altRouteColor') || '#FFA500',
      mapType: localStorage.getItem('mapType') || 'roadmap',
      showTraffic: localStorage.getItem('showTraffic') === 'true',
      useDefaultDistances: useDefaultDistances,
      lastValidHeading: 0,
      isInitialSnap: true,
      lastCameraUpdate: 0,
      hasArrived: false,
      alertProximities: new Map(),
      waypoints: [],
      avoidTolls: false,
      avoidHighways: false,
      evCharging: false,
      routePreset: 'default',
      alertRadius: parseInt(localStorage.getItem('alertRadius')) || 10,
      alertFilters: JSON.parse(localStorage.getItem('alertFilters')) || { police: true, crash: true, construction: true },
      trafficForecast: localStorage.getItem('trafficForecast') === 'true',
      multiStop: localStorage.getItem('multiStop') === 'true',
      offlineRegions: JSON.parse(localStorage.getItem('offlineRegions')) || [],
      familyMembers: JSON.parse(localStorage.getItem('familyMembers')) || []
    };
    let mockSimulationInterval = null;
    let isRegister = false;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const LOCATION_UPDATE_THRESHOLD = isMobile ? 500 : 100;
    let isProgrammaticUpdate = false;
    let wakeLock = null;
    let isLowBattery = false;
    let visibilityHandler = null;
    let currentVerificationAlertId = null;
    let wakeWordRecognizer = null;
    let commandSpeechRecognition = null;
    const tooltipTexts = {
      'hazard-button': 'Report hazard ahead',
      'recenter-button': 'Recenter on location',
      'voice-button': 'Voice commands',
      'share-button': 'Share current route',
      'settings-button': 'App settings',
      'current-alerts-button': 'View current alerts',
      'leaderboard-button': 'View leaderboard',
      'admin-button': 'Admin panel'
    };
    let tooltipTimer = null;
    let tooltipHideTimer = null;
    let selectedUserId = null; // For admin activity view
    let trialEnd = null;

    // Fetch subscription status
    async function fetchSubscriptionStatus() {
      try {
        const response = await fetch('/api/subscription/status', {
          headers: { 'Authorization': `Bearer ${localStorage.getItem('token') || sessionStorage.getItem('token')}` }
        });
        const data = await response.json();
        isPremium = data.premium;
        trialEnd = data.trialEnd;
        localStorage.setItem('isPremium', isPremium);
        console.log('Subscription status:', { isPremium, trialEnd });
        if (!isPremium && trialEnd && new Date() > new Date(trialEnd)) {
          showPremiumPrompt();
        }
        gatePremiumFeatures();
      } catch (error) {
        console.error('Failed to fetch subscription status:', error);
      }
    }

    // Gate premium features
    function gatePremiumFeatures() {
      const premiumToggles = document.querySelectorAll('.premium-toggle');
      premiumToggles.forEach(toggle => {
        const input = toggle.querySelector('input, select');
        if (input) {
          if (!isPremium) {
            input.disabled = true;
            input.style.opacity = 0.5;
            const prompt = toggle.dataset.prompt || 'Premium feature';
            const badge = document.createElement('span');
            badge.textContent = ` (${prompt})`;
            badge.style.color = '#FF9800';
            toggle.appendChild(badge);
          } else {
            input.disabled = false;
            input.style.opacity = 1;
          }
        }
      });
      // Speed trap icons: Enhance police markers if premium
      if (isPremium) {
        console.log('Premium: Enabling speed trap icons');
      }
    }

    // Show premium prompt modal
    function showPremiumPrompt() {
      document.getElementById('premium-modal').style.display = 'flex';
    }

    document.getElementById('upgrade-btn').addEventListener('click', async () => {
      try {
        const response = await fetch('/api/subscription/create-checkout-session', {
          method: 'POST',
          headers: { 
            'Authorization': `Bearer ${localStorage.getItem('token') || sessionStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        const { url } = await response.json();
        window.location.href = url;
      } catch (error) {
        console.error('Upgrade error:', error);
        showToast('Upgrade failed. Try again.');
      }
    });

    document.getElementById('dismiss-premium').addEventListener('click', () => {
      document.getElementById('premium-modal').style.display = 'none';
    });

    function createSpeedTrapIcon() {
      const content = document.createElement('div');
      content.innerHTML = '<i class="fas fa-exclamation-triangle" style="color: red; font-size: 20px;"></i>'; // Custom icon
      return content;
    }

    function showTooltip(buttonId, text) {
      if (!showTooltips) return;
      const tooltip = document.getElementById('tooltip');
      tooltip.textContent = text;
      tooltip.style.display = 'block';
      const button = document.getElementById(buttonId);
      const rect = button.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let top = rect.top - 50;
      let left = rect.left + (rect.width / 2);
      if (top < 10) top = rect.bottom + 10;
      if (left + 100 > viewportWidth) left = rect.right - 100;
      if (left < 10) left = rect.left;
      if (top + 30 > viewportHeight) top = viewportHeight - 40;
      tooltip.style.top = top + 'px';
      tooltip.style.left = left + 'px';
      if (tooltipHideTimer) clearTimeout(tooltipHideTimer);
      tooltipHideTimer = setTimeout(() => hideTooltip(), 2000);
    }
    function hideTooltip() {
      const tooltip = document.getElementById('tooltip');
      tooltip.style.display = 'none';
      if (tooltipTimer) clearTimeout(tooltipTimer);
      if (tooltipHideTimer) clearTimeout(tooltipHideTimer);
    }
    function setupTooltips() {
      Object.keys(tooltipTexts).forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (!button) return;
        const text = tooltipTexts[buttonId];
        if (isMobile) {
          let holdStart = 0;
          button.addEventListener('touchstart', (e) => {
            hideTooltip();
            holdStart = Date.now();
            tooltipTimer = setTimeout(() => showTooltip(buttonId, text), 500);
          });
          button.addEventListener('touchend', (e) => {
            const holdTime = Date.now() - holdStart;
            if (holdTime >= 500) {
              e.preventDefault();
            }
            clearTimeout(tooltipTimer);
            holdStart = 0;
          });
        } else {
          button.addEventListener('mouseenter', () => showTooltip(buttonId, text));
          button.addEventListener('mouseleave', hideTooltip);
        }
      });
      document.addEventListener('touchstart', hideTooltip, { passive: true });
    }
    function normalizeHeadingDelta(current, target) {
      let delta = target - current;
      while (delta > 180) delta -= 360;
      while (delta < -180) delta += 360;
      return delta;
    }
    async function requestWakeLock() {
      if (!('wakeLock' in navigator)) {
        console.warn('Wake Lock API not supported');
        return;
      }
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
          console.log('Wake Lock released');
          wakeLock = null;
        });
        console.log('Wake Lock acquired');
      } catch (err) {
        console.error('Wake Lock request failed:', err);
      }
    }
    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
        console.log('Wake Lock released');
      }
    }
    function setupPageVisibility() {
      visibilityHandler = () => {
        if (!document.hidden && navState.isNavigating) {
          console.log('Page became visible, re-initializing GPS and Socket.IO');
          if (socket && !socket.connected) {
            socket.connect();
          }
          if (watchId) {
            navigator.geolocation.clearWatch(watchId);
          }
          watchId = navigator.geolocation.watchPosition(
            onPositionUpdate,
            (error) => handleGeolocationError(error),
            { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
          );
          restoreNavigationView();
          requestWakeLock();
        }
      };
      document.addEventListener('visibilitychange', visibilityHandler);
    }
    function cleanupPageVisibility() {
      if (visibilityHandler) {
        document.removeEventListener('visibilitychange', visibilityHandler);
        visibilityHandler = null;
      }
    }
    window.addEventListener('beforeunload', () => {
      releaseWakeLock();
      cleanupPageVisibility();
      stopWakeWordDetection();
    });
    navigator.getBattery?.().then(battery => {
      isLowBattery = battery.level < 0.2;
      battery.addEventListener('levelchange', () => {
        isLowBattery = battery.level < 0.2;
        if (isLowBattery && navState.isNavigating) {
          releaseWakeLock();
          showToast('Low battery detected. Screen wake lock released to save power.');
        }
      });
    });
    function switchAuthMode() {
      isRegister = !isRegister;
      console.log('Switching auth mode:', isRegister ? 'Register' : 'Login');
      const authTitle = document.getElementById('auth-title');
      const usernameInput = document.getElementById('username');
      const authSwitch = document.getElementById('auth-switch');
      authTitle.textContent = isRegister ? 'Register' : 'Login';
      usernameInput.style.display = isRegister ? 'block' : 'none';
      authSwitch.innerHTML = isRegister
        ? 'Already have an account? <a href="#" style="color: #4CAF50;" onclick="switchAuthMode()">Login</a>'
        : 'Don\'t have an account? <a href="#" style="color: #4CAF50;" onclick="switchAuthMode()">Register</a>';
      console.log('Auth form updated:', { isRegister, title: authTitle.textContent, usernameVisible: usernameInput.style.display });
    }
    document.getElementById('auth-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      console.log('Auth form submitted:', { isRegister });
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value.trim();
      const username = isRegister ? document.getElementById('username').value.trim() : '';
      console.log('Form data:', { email, password, username, endpoint: isRegister ? '/api/auth/register' : '/api/auth/login' });
      if (!email || !password || (isRegister && !username)) {
        console.error('Missing required fields:', { email, password, username });
        showToast('Please fill in all required fields.');
        return;
      }
      const endpoint = isRegister ? '/api/auth/register' : '/api/auth/login';
      const body = isRegister ? { email, password, username } : { email, password };
      try {
        console.log('Sending fetch request to:', endpoint);
        const response = await fetch(endpoint, {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        console.log('Response received:', { status: response.status, ok: response.ok });
        console.log('Response headers:', [...response.headers.entries()]);
        const data = await response.json();
        console.log('Response data:', data);
        if (response.ok && data.token && data.user) {
          localStorage.setItem('token', data.token);
          sessionStorage.setItem('token', data.token);
          localStorage.setItem('userId', data.user.id);
          sessionStorage.setItem('userId', data.user.id);
          isAdmin = data.user.email === 'imhoggbox@gmail.com' || data.user.isAdmin;
          localStorage.setItem('isAdmin', isAdmin);
          sessionStorage.setItem('isAdmin', isAdmin);
          document.getElementById('admin-button').style.display = isAdmin ? 'flex' : 'none';
          console.log('Token and userId saved:', { token: data.token.substring(0, 20) + '...', userId: data.user.id, isAdmin });
          document.getElementById('auth-container').style.display = 'none';
          showToast(isRegister ? 'Registration successful!' : 'Login successful!');
          console.log(isRegister ? 'User registered' : 'User logged in', { userId: data.user.id });
          initApp();
        } else {
          console.error('Auth failed:', { status: response.status, error: data.error || 'No error message' });
          showToast(data.error || (isRegister ? 'Registration failed.' : 'Login failed.'));
        }
      } catch (error) {
        console.error('Fetch error:', error.message);
        showToast('Error: Unable to connect to server. Check your network.');
      }
    });
    function animate() {
      if (typeof TWEEN !== 'undefined') {
        TWEEN.update();
        requestAnimationFrame(animate);
      }
    }
    animate();
    function adjustHud() {
      const reportBox = document.getElementById('report-box');
      const rerouteHudContainer = document.getElementById('reroute-hud-container');
      const settingsHudContainer = document.getElementById('settings-hud-container');
      const alertsHudContainer = document.getElementById('alerts-hud-container');
      const cameraHudContainer = document.getElementById('camera-hud-container');
      const leaderboardHudContainer = document.getElementById('leaderboard-hud-container');
      const arrivalHudContainer = document.getElementById('arrival-hud-container');
      const adminHudContainer = document.getElementById('admin-hud-container');
      const verificationHudContainer = document.getElementById('verification-hud-container');
      const userProfileHudContainer = document.getElementById('user-profile-hud-container');
      const currentWidth = window.innerWidth;
      const currentHeight = window.innerHeight;
      const maxHeight = Math.min(currentHeight * 0.5, 400);
      const hudElements = [reportBox, rerouteHudContainer, settingsHudContainer, alertsHudContainer, cameraHudContainer, leaderboardHudContainer, arrivalHudContainer, adminHudContainer, verificationHudContainer, userProfileHudContainer];
      hudElements.forEach(element => {
        element.style.maxHeight = `${maxHeight}px`;
        element.style.width = currentWidth <= 414 ? '90vw' : currentWidth <= 768 ? '80vw' : '30vw';
        element.style.maxWidth = currentWidth <= 414 ? 'none' : currentWidth <= 768 ? '320px' : '300px';
      });
      console.log('HUDs adjusted: MaxHeight:', maxHeight, 'Width:', reportBox.style.width, 'Screen:', currentWidth, 'x', currentHeight);
    }
    function updateCompass() {
      const compass = document.getElementById('compass');
      if (compass && map) {
        const mapHeading = navState.mapOrientation === 'north-up' ? 0 : map.getHeading() || navState.currentHeading;
        compass.style.transform = `rotate(${-mapHeading}deg)`;
        console.log('Compass updated:', { mapHeading, rotation: -mapHeading });
      }
    }
    async function requestDeviceOrientationPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission === 'granted') {
            console.log('Device orientation permission granted');
            setupDeviceOrientation();
          } else {
            console.warn('Device orientation permission denied');
            showToast('Compass access denied. Using GPS heading.');
          }
        } catch (error) {
          console.error('Error requesting device orientation permission:', error);
          showToast('Failed to access compass. Using GPS heading.');
        }
      } else {
        setupDeviceOrientation();
      }
    }
    function setupDeviceOrientation() {
      window.addEventListener('deviceorientation', (event) => {
        if (event.alpha !== null) {
          compassHeading = 360 - event.alpha;
          console.log('Raw compass heading (alpha):', event.alpha, 'Adjusted:', compassHeading);
          checkHeadingVariance(compassHeading);
        } else {
          console.warn('Device orientation alpha is null');
          needsCalibration = true;
        }
      });
    }
    function checkHeadingVariance(newHeading) {
      if (headingHistory.length > 2) {
        const variance = Math.max(...headingHistory) - Math.min(...headingHistory);
        needsCalibration = variance > HEADING_VARIANCE_THRESHOLD;
        console.log('Heading variance checked:', { variance, threshold: HEADING_VARIANCE_THRESHOLD, needsCalibration });
      }
    }
    function recalibrateCompass() {
      needsCalibration = false;
      headingHistory = [];
      showToast('Move phone in a figure-eight pattern to calibrate compass.');
      console.log('Calibration triggered manually');
      setTimeout(() => {
        console.log('Calibration completed, resetting heading history');
      }, 5000);
    }
    function smoothHeading(newHeading, source = 'unknown', speed = 0, isSnapped = false) {
      if (isNaN(newHeading) || newHeading === null || speed <= STATIONARY_SPEED_THRESHOLD) {
        console.log('Stationary or invalid heading used:', { heading: navState.lastValidHeading, source: 'lastValid', speed });
        return navState.lastValidHeading;
      }
      const headingDiff = Math.abs(((newHeading - lastStableHeading + 180) % 360) - 180);
      if (headingDiff < MIN_HEADING_CHANGE) {
        console.log('Ignoring small heading change:', { newHeading, lastStableHeading, headingDiff });
        return lastStableHeading;
      }
      headingHistory.push(newHeading);
      if (headingHistory.length > HEADING_SMOOTHING_WINDOW) {
        headingHistory.shift();
      }
      let smoothedHeading = headingHistory.reduce((sum, h) => sum + h, 0) / headingHistory.length;
      const gpsWeight = speed > STATIONARY_SPEED_THRESHOLD ? 0.7 : 0.2;
      const compassWeight = needsCalibration ? 0.1 : 0.6;
      const polylineWeight = isSnapped ? 0.8 : needsCalibration ? 0.2 : 0.2;
      for (let i = 0; i < headingHistory.length; i++) {
        let delta = headingHistory[i] - smoothedHeading;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        smoothedHeading += (source === 'gps' ? gpsWeight : source === 'compass' ? compassWeight : polylineWeight) * delta / headingHistory.length;
      }
      smoothedHeading = smoothedHeading % 360;
      if (smoothedHeading < 0) smoothedHeading += 360;
      navState.lastValidHeading = smoothedHeading;
      lastStableHeading = smoothedHeading;
      console.log('Heading stabilized:', { newHeading, smoothed: smoothedHeading, source, speed, gpsWeight, compassWeight, polylineWeight, isSnapped });
      return smoothedHeading;
    }
    function smoothPosition(rawPos) {
      positionHistory.push(rawPos);
      if (positionHistory.length > POSITION_HISTORY_WINDOW) {
        positionHistory.shift();
      }
      const avgLat = positionHistory.reduce((sum, p) => sum + p.lat, 0) / positionHistory.length;
      const avgLng = positionHistory.reduce((sum, p) => sum + p.lng, 0) / positionHistory.length;
      const smoothedPos = { lat: avgLat, lng: avgLng };
      console.log('Position smoothed:', { raw: rawPos, smoothed: smoothedPos, historyLength: positionHistory.length });
      return smoothedPos;
    }
    function loadGoogleMaps() {
      console.log('Loading Google Maps API...');
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&map_ids=${mapId}&v=beta&callback=initMap&libraries=places,geometry,marker,routes&loading=async`;
      script.async = true;
      script.defer = true;
      script.onerror = () => {
        console.error('Failed to load Google Maps script');
        showToast('Failed to load map. Check network or API key.');
        setTimeout(loadGoogleMaps, 2000);
      };
      script.onload = () => {
        console.log('Google Maps script loaded successfully');
      };
      document.head.appendChild(script);
    }
    window.initMap = function() {
      console.log('initMap called');
      if (!window.google || !google.maps || !google.maps.Map || !google.maps.marker || !google.maps.places || !google.maps.routes || !google.maps.geometry) {
        console.error('Google Maps libraries not loaded:', {
          Map: !!google.maps?.Map,
          AdvancedMarkerElement: !!google.maps?.marker,
          Autocomplete: !!google.maps?.places,
          DirectionsService: !!google.maps?.routes,
          Geometry: !!google.maps?.geometry
        });
        showToast('Failed to load map libraries. Retrying...');
        setTimeout(loadGoogleMaps, 2000);
        return;
      }
      console.log('Google Maps API loaded successfully');
      initializeMap();
    };
    function initializeMap() {
      console.log('Initializing map...');
      if (!google.maps || !google.maps.Map || !google.maps.marker || !google.maps.places || !google.maps.routes || !google.maps.geometry) {
        console.error('Google Maps libraries not loaded:', {
          Map: !!google.maps?.Map,
          AdvancedMarkerElement: !!google.maps?.marker,
          Autocomplete: !!google.maps?.places,
          DirectionsService: !!google.maps?.routes,
          Geometry: !!google.maps?.geometry
        });
        showToast('Map initialization failed: libraries not loaded.');
        return;
      }
      try {
        if (map) {
          console.warn('Map already initialized, skipping to prevent multiple instances');
          return;
        }
        map = new google.maps.Map(document.getElementById('map'), {
          center: navState.userLocation,
          zoom: navState.navigationZoom,
          mapId: mapId,
          tilt: 45,
          heading: navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading,
          disableDefaultUI: true,
          gestureHandling: 'cooperative',
          mapTypeControl: false,
          streetViewControl: false,
          clickableIcons: false,
          zoomControl: false,
          disableDoubleClickZoom: true
        });
        map.setOptions({ styles: mapSkins[mapSkin] });
        console.log('Map initialized:', { center: navState.userLocation, zoom: navState.navigationZoom, mapId });
        map.setMapTypeId(navState.mapType);
        trafficLayer = new google.maps.TrafficLayer({ map: navState.showTraffic ? map : null });
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
          map: null,
          suppressMarkers: true,
          preserveViewport: true,
          polylineOptions: {
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            zIndex: 5
          }
        });
        alternativeRenderer = new google.maps.DirectionsRenderer({
          map: null,
          suppressMarkers: true,
          polylineOptions: {
            strokeColor: navState.altRouteColor,
            strokeOpacity: 0,
            zIndex: 10,
            icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 }, offset: '0', repeat: '12px' }]
          }
        });
        const markerElement = document.createElement('div');
        markerElement.style.borderLeft = '15px solid transparent';
        markerElement.style.borderRight = '15px solid transparent';
        markerElement.style.borderBottom = '30px solid #4285F4';
        markerElement.style.width = '0';
        markerElement.style.height = '0';
        markerElement.style.boxShadow = '0 0 5px rgba(0,0,0,0.5)';
        markerElement.style.transformOrigin = 'center 75%';
        userMarker = new google.maps.marker.AdvancedMarkerElement({
          map: map,
          position: navState.userLocation,
          content: markerElement,
          title: 'Your Location'
        });
        google.maps.event.addListener(userMarker, 'position_changed', () => {
          const pos = userMarker.position;
          if (pos && navState.isFollowing && navState.isNavigating) {
            const { zoom, tilt, turnHeading } = getDynamicZoom(pos, 0);
            const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
            const lookaheadPoint = getLookaheadPoint(pos, heading, 50);
            requestAnimationFrame(() => {
              map.panTo(lookaheadPoint);
              map.setZoom(zoom);
              if (!isHeadingTweening) {
                map.setHeading(heading);
              }
              map.setTilt(tilt);
              userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
              console.log('User marker position changed, map panned:', { lat: pos.lat, lng: pos.lng, heading, zoom, tilt, orientation: navState.mapOrientation });
              updateCompass();
            });
          }
        });
        if (showTrafficCameras) {
          const trafficCamImage = 'https://i.postimg.cc/jjN0JrPZ/New-Project-5.png';
          const trafficCamLocations = [
            { coords: { lat: 33.0921, lng: -83.2246 }, title: 'Traffic Camera - Baldwin High School' },
            { coords: { lat: 33.0785, lng: -83.2251 }, title: 'Traffic Camera - The Kidd Center' },
            { coords: { lat: 33.1087, lng: -83.2168 }, title: 'Traffic Camera - John Milledge Academy' }
          ];
          trafficCamLocations.forEach(location => {
            fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(location.title.split(' - ')[1] + ', Milledgeville, GA, USA')}&key=${API_KEY}`)
              .then(response => response.json())
              .then(data => {
                let position = location.coords;
                if (data.status === 'OK' && data.results[0]) {
                  position = data.results[0].geometry.location;
                  console.log(`Geocoding successful for ${location.title}:`, position);
                } else {
                  console.warn(`Geocoding failed for ${location.title}, using fallback coords:`, position);
                  showToast(`Using fallback coordinates for ${location.title}.`);
                }
                const markerImage = document.createElement('img');
                markerImage.src = trafficCamImage;
                markerImage.className = 'traffic-cam-marker';
                new google.maps.marker.AdvancedMarkerElement({
                  map: map,
                  position: position,
                  content: markerImage,
                  title: location.title
                });
                cameraPositions.push(position);
                console.log(`Traffic camera marker placed at ${location.title}:`, position);
              })
              .catch(error => {
                console.error(`Error geocoding ${location.title}:`, error);
                const markerImage = document.createElement('img');
                markerImage.src = trafficCamImage;
                markerImage.className = 'traffic-cam-marker';
                new google.maps.marker.AdvancedMarkerElement({
                  map: map,
                  position: location.coords,
                  content: markerImage,
                  title: location.title
                });
                cameraPositions.push(location.coords);
                showToast(`Error geocoding ${location.title}, using fallback coordinates.`);
                console.log(`Traffic camera marker placed at ${location.title} using fallback:`, location.coords);
              });
          });
        }
        const input = document.getElementById('search-input');
        const autocomplete = new google.maps.places.Autocomplete(input, { fields: ['geometry', 'formatted_address'] });
        autocomplete.bindTo('bounds', map);
        console.log('Autocomplete initialized');
        autocomplete.addListener('place_changed', () => {
          const place = autocomplete.getPlace();
          if (place && place.geometry && place.geometry.location) {
            navState.destination = {
              lat: place.geometry.location.lat(),
              lng: place.geometry.location.lng()
            };
            console.log('Destination selected:', navState.destination);
            if (destMarker) destMarker.map = null;
            const destMarkerElement = document.createElement('div');
            destMarkerElement.style.width = '20px';
            destMarkerElement.style.height = '20px';
            destMarkerElement.style.backgroundColor = 'green';
            destMarkerElement.style.borderRadius = '50%';
            destMarkerElement.style.border = '2px solid white';
            destMarker = new google.maps.marker.AdvancedMarkerElement({
              map: map,
              position: navState.destination,
              content: destMarkerElement,
              title: 'Destination'
            });
            calculateAndDisplayRoute(navState.userLocation, navState.destination, () => {
              console.log('Route preview displayed:', { destination: navState.destination });
              document.getElementById('start-button').style.display = 'block';
              document.getElementById('simulate-position-button').style.display = 'block';
            });
          } else {
            console.error('No location for selected place:', place);
            showToast('Invalid address selected. Please try again.');
          }
        });
        document.getElementById('traffic-layer-toggle').checked = navState.showTraffic;
        document.getElementById('main-route-color').value = navState.mainRouteColor;
        document.getElementById('alt-route-color').value = navState.altRouteColor;
        document.getElementById('map-type').value = navState.mapType;
        document.getElementById('map-skin').value = mapSkin;
        document.getElementById('map-orientation').value = navState.mapOrientation;
        document.getElementById('auto-recenter-toggle').checked = navState.isFollowing;
        document.getElementById('traffic-camera-toggle').checked = showTrafficCameras;
        document.getElementById('push-notifications-toggle').checked = pushNotificationsEnabled;
        document.getElementById('voice-assistant-toggle').checked = voiceAssistantEnabled;
        document.getElementById('show-tooltips-toggle').checked = showTooltips;
        document.getElementById('hazard-alert-distance').value = hazardAlertDistance;
        document.getElementById('hazard-distance-value').textContent = `${hazardAlertDistance} miles`;
        document.getElementById('camera-alert-distance').value = cameraAlertDistance;
        document.getElementById('camera-distance-value').textContent = `${cameraAlertDistance} miles`;
        document.getElementById('use-default-distances').checked = navState.useDefaultDistances;
        document.getElementById('high-contrast-toggle').checked = highContrastMode;
        if (highContrastMode) document.body.classList.add('high-contrast');
        document.getElementById('alert-radius').value = navState.alertRadius;
        document.getElementById('alert-radius-value').textContent = `${navState.alertRadius} miles`;
        document.getElementById('filter-police').checked = navState.alertFilters.police;
        document.getElementById('filter-crash').checked = navState.alertFilters.crash;
        document.getElementById('filter-construction').checked = navState.alertFilters.construction;
        document.getElementById('traffic-forecast-toggle').checked = navState.trafficForecast;
        document.getElementById('multi-stop-toggle').checked = navState.multiStop;
        document.getElementById('ev-charging-toggle').checked = navState.evCharging;
        document.getElementById('route-preset').value = navState.routePreset;
        fetchAndDisplayMarkers(map, navState.userLocation);
        const ownId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
        fetchProfile(ownId, true).then(populateAccountProfile);
        loadOfflineRegions();
        loadFamilyMembers();
        setupEventListeners();
        setupTooltips();
        updateCompass();
        checkURLForAlert();
        setupPageVisibility();
        if (isAdmin) {
          document.getElementById('admin-button').style.display = 'flex';
        }
        if (voiceAssistantEnabled) {
          setTimeout(startWakeWordDetection, 1000); // Delay to ensure permissions
        }
        console.log('Map initialization complete');
      } catch (error) {
        console.error('Map initialization error:', error);
        showToast('Failed to initialize map. Retrying...');
        setTimeout(initializeMap, 2000);
      }
    }
    function loadOfflineRegions() {
      const list = document.getElementById('offline-regions-list');
      list.innerHTML = '';
      navState.offlineRegions.forEach((region, index) => {
        const div = document.createElement('div');
        div.textContent = `Region ${index + 1}: ${region.bounds}`;
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => deleteOfflineRegion(index);
        div.appendChild(deleteBtn);
        list.appendChild(div);
      });
    }
    function deleteOfflineRegion(index) {
      navState.offlineRegions.splice(index, 1);
      localStorage.setItem('offlineRegions', JSON.stringify(navState.offlineRegions));
      loadOfflineRegions();
      showToast('Region deleted');
    }
    function loadFamilyMembers() {
      const list = document.getElementById('family-list');
      list.innerHTML = '';
      navState.familyMembers.forEach(member => {
        const div = document.createElement('div');
        div.className = 'family-member';
        div.innerHTML = `<span>${member.email}</span><button class="remove-family" onclick="removeFamilyMember('${member.email}')">Remove</button>`;
        list.appendChild(div);
      });
    }
    function removeFamilyMember(email) {
      navState.familyMembers = navState.familyMembers.filter(m => m.email !== email);
      localStorage.setItem('familyMembers', JSON.stringify(navState.familyMembers));
      loadFamilyMembers();
      showToast('Family member removed');
    }
    function checkURLForAlert() {
      const urlParams = new URLSearchParams(window.location.search);
      const alertId = urlParams.get('alertId');
      const lat = parseFloat(urlParams.get('lat'));
      const lng = parseFloat(urlParams.get('lng'));
      if (alertId && !isNaN(lat) && !isNaN(lng) && map) {
        const position = { lat, lng };
        map.setCenter(position);
        map.setZoom(15);
        console.log('Centered map on alert from URL:', { alertId, lat, lng });
        window.history.replaceState({}, document.title, window.location.pathname);
        fetchWithRetry(`/api/markers?lat=${lat}&lng=${lng}&maxDistance=100`, {
          headers: { 'Authorization': `Bearer ${(localStorage.getItem('token') || sessionStorage.getItem('token'))?.trim()}` }
        })
          .then(response => response.json())
          .then(alerts => {
            const alert = alerts.find(a => a._id === alertId);
            if (alert) {
              const isTrafficCamera = alert.type === 'Traffic Camera';
              if (isTrafficCamera && !showTrafficCameras) return;
              const marker = new google.maps.marker.AdvancedMarkerElement({
                map,
                position: { lat: alert.location.coordinates[1], lng: alert.location.coordinates[0] },
                content: isTrafficCamera ? createTrafficCameraContent() : createAlertContent(),
                title: `${alert.type} Alert`
              });
              markers.set(alertId, marker);
              console.log('Alert marker placed from URL:', { alertId, position });
            }
          })
          .catch(error => {
            console.error('Error fetching alert for URL centering:', error);
            showToast('Failed to load alert details.');
          });
      } else {
        console.log('No valid URL alert parameters or map not initialized:', { alertId, lat, lng, map: !!map });
      }
      // Check URL params for success
      if (urlParams.get('success')) {
        showToast('Subscription successful! Premium features unlocked.');
        fetchSubscriptionStatus(); // Refresh status
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    }
    function setupEventListeners() {
      console.log('Setting up event listeners...');
      document.getElementById('start-button').addEventListener('click', startGPS);
      document.getElementById('bottom-hud-stop').addEventListener('click', stopGPS);
      document.getElementById('simulate-position-button').addEventListener('click', () => {
        if (mockSimulationInterval) {
          clearInterval(mockSimulationInterval);
          mockSimulationInterval = null;
          document.getElementById('simulate-position-button').textContent = 'Simulate';
          console.log('Position simulation stopped');
          document.getElementById('hud-container').style.display = 'none';
          document.getElementById('bottom-hud-container').style.display = 'none';
          if (routePolyline) {
            routePolyline.setMap(null);
            routePolyline = null;
          }
          if (offRoadPolyline) {
            offRoadPolyline.setMap(null);
            offRoadPolyline = null;
          }
          directionsRenderer.setMap(map);
          navState.isFollowing = false;
          navState.isNavigating = false;
          localStorage.setItem('isFollowing', navState.isFollowing);
          sessionStorage.setItem('isFollowing', navState.isFollowing);
          map.setOptions({ gestureHandling: 'cooperative', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
          requestAnimationFrame(() => {
            map.setCenter(navState.userLocation);
            map.setZoom(navState.navigationZoom);
            map.setHeading(navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading);
            console.log('Simulation completed, map re-centered to user location');
          });
          return;
        }
        startPositionSimulation();
        document.getElementById('simulate-position-button').textContent = 'Stop Simulation';
        console.log('Position simulation started');
      });
      document.getElementById('hazard-button').addEventListener('click', () => {
        if (navState.alertState === 'OFFERING_REROUTE') return;
        closeAllHuds();
        const reportBox = document.getElementById('report-box');
        const reportOptions = document.querySelector('.report-options');
        const confirmAlert = document.getElementById('confirm-alert');
        reportBox.classList.add('active');
        reportOptions.style.display = 'grid';
        confirmAlert.classList.remove('active');
        navState.alertState = 'IDLE';
        if (navState.isNavigating) {
          unlockNavigation();
          console.log('Map unlocked for manual report during navigation');
        }
        console.log('Hazard button clicked, report box opened in IDLE state');
      });
      document.getElementById('report-close').addEventListener('click', () => {
        cancelAlert();
        console.log('Report box closed');
      });
      document.getElementById('settings-button').addEventListener('click', () => {
        closeAllHuds();
        const settingsHudContainer = document.getElementById('settings-hud-container');
        settingsHudContainer.classList.add('active');
        console.log('Settings button clicked, settings HUD opened');
      });
      document.getElementById('settings-close').addEventListener('click', () => {
        const settingsHudContainer = document.getElementById('settings-hud-container');
        settingsHudContainer.classList.remove('active');
        console.log('Settings HUD closed');
        if (navState.isNavigating && navState.isFollowing) {
          lockNavigation();
          console.log('Navigation view re-locked after closing settings HUD');
        }
      });
      document.getElementById('current-alerts-button').addEventListener('click', () => {
        closeAllHuds();
        fetchCurrentAlerts();
        const alertsHudContainer = document.getElementById('alerts-hud-container');
        alertsHudContainer.classList.add('active');
        document.getElementById('information').style.display = 'block';
        console.log('Current alerts button clicked, alerts HUD opened');
      });
      document.getElementById('alerts-close').addEventListener('click', () => {
        const alertsHudContainer = document.getElementById('alerts-hud-container');
        alertsHudContainer.classList.remove('active');
        console.log('Alerts HUD closed');
        if (navState.isNavigating && navState.isFollowing) {
          lockNavigation();
          console.log('Navigation view re-locked after closing alerts HUD');
        }
      });
      document.getElementById('leaderboard-button').addEventListener('click', () => {
        closeAllHuds();
        fetchLeaderboard();
        const leaderboardHudContainer = document.getElementById('leaderboard-hud-container');
        leaderboardHudContainer.classList.add('active');
        console.log('Leaderboard button clicked, leaderboard HUD opened');
      });
      document.getElementById('leaderboard-close').addEventListener('click', () => {
        const leaderboardHudContainer = document.getElementById('leaderboard-hud-container');
        leaderboardHudContainer.classList.remove('active');
        console.log('Leaderboard HUD closed');
        if (navState.isNavigating && navState.isFollowing) {
          lockNavigation();
          console.log('Navigation view re-locked after closing leaderboard HUD');
        }
      });
      document.getElementById('admin-button').addEventListener('click', () => {
        window.location.href = 'admin.html';
      });
      document.getElementById('admin-close').addEventListener('click', () => {
        document.getElementById('admin-hud-container').classList.remove('active');
        console.log('Admin HUD closed');
        if (navState.isNavigating && navState.isFollowing) {
          lockNavigation();
        }
      });
      document.querySelectorAll('.admin-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.admin-tab-content').forEach(c => c.style.display = 'none');
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).style.display = 'block';
          if (tab.dataset.tab === 'activity' && selectedUserId) {
            loadUserActivity(selectedUserId);
          }
        });
      });
      document.getElementById('search-users-btn').addEventListener('click', () => {
        const query = document.getElementById('user-search').value;
        fetchUsers(query);
      });
      document.getElementById('show-all-users-btn').addEventListener('click', () => loadAllUsers());
      document.getElementById('load-activity-btn').addEventListener('click', () => {
        const query = document.getElementById('activity-user-search').value;
        if (query) {
          fetchUserForActivity(query);
        }
      });
      document.getElementById('voice-button').addEventListener('click', startVoiceRecognition);
      document.getElementById('share-button').addEventListener('click', shareRoute);
      document.getElementById('recalibrate-compass-button').addEventListener('click', () => {
        recalibrateCompass();
        console.log('Recalibrate Compass button clicked');
      });
      document.getElementById('push-notifications-toggle').addEventListener('change', async (e) => {
        pushNotificationsEnabled = e.target.checked;
        localStorage.setItem('pushNotificationsEnabled', pushNotificationsEnabled);
        sessionStorage.setItem('pushNotificationsEnabled', pushNotificationsEnabled);
        console.log('Push notifications toggled:', pushNotificationsEnabled);
        if (pushNotificationsEnabled) {
          await requestPushPermission();
        } else {
          await unsubscribeFromPush();
        }
      });
      document.getElementById('show-tooltips-toggle').addEventListener('change', (e) => {
        showTooltips = e.target.checked;
        localStorage.setItem('showTooltips', showTooltips);
        sessionStorage.setItem('showTooltips', showTooltips);
        console.log('Tooltips toggled:', showTooltips);
        if (!showTooltips) hideTooltip();
      });
      document.getElementById('voice-assistant-toggle').addEventListener('change', (e) => {
        voiceAssistantEnabled = e.target.checked;
        localStorage.setItem('voiceAssistantEnabled', voiceAssistantEnabled);
        if (voiceAssistantEnabled) {
          startWakeWordDetection();
        } else {
          stopWakeWordDetection();
        }
        console.log('Voice assistant toggled:', voiceAssistantEnabled);
      });
      document.getElementById('map-skin').addEventListener('change', (e) => {
        mapSkin = e.target.value;
        localStorage.setItem('mapSkin', mapSkin);
        sessionStorage.setItem('mapSkin', mapSkin);
        if (map) {
          map.setOptions({ styles: mapSkins[mapSkin] });
        }
        console.log('Map skin changed to:', mapSkin);
      });
      document.getElementById('alert-radius').addEventListener('input', (e) => {
        navState.alertRadius = parseInt(e.target.value);
        localStorage.setItem('alertRadius', navState.alertRadius);
        document.getElementById('alert-radius-value').textContent = `${navState.alertRadius} miles`;
        console.log('Alert radius set to:', navState.alertRadius);
      });
      document.getElementById('filter-police').addEventListener('change', (e) => {
        navState.alertFilters.police = e.target.checked;
        localStorage.setItem('alertFilters', JSON.stringify(navState.alertFilters));
      });
      document.getElementById('filter-crash').addEventListener('change', (e) => {
        navState.alertFilters.crash = e.target.checked;
        localStorage.setItem('alertFilters', JSON.stringify(navState.alertFilters));
      });
      document.getElementById('filter-construction').addEventListener('change', (e) => {
        navState.alertFilters.construction = e.target.checked;
        localStorage.setItem('alertFilters', JSON.stringify(navState.alertFilters));
      });
      document.getElementById('traffic-forecast-toggle').addEventListener('change', (e) => {
        navState.trafficForecast = e.target.checked;
        localStorage.setItem('trafficForecast', navState.trafficForecast);
        console.log('Traffic forecast toggled:', navState.trafficForecast);
      });
      document.getElementById('multi-stop-toggle').addEventListener('change', (e) => {
        navState.multiStop = e.target.checked;
        localStorage.setItem('multiStop', navState.multiStop);
        document.getElementById('multi-stop-inputs').style.display = navState.multiStop ? 'flex' : 'none';
        console.log('Multi-stop toggled:', navState.multiStop);
      });
      document.getElementById('ev-charging-toggle').addEventListener('change', (e) => {
        navState.evCharging = e.target.checked;
        localStorage.setItem('evCharging', navState.evCharging);
        console.log('EV charging toggled:', navState.evCharging);
      });
      document.getElementById('route-preset').addEventListener('change', (e) => {
        navState.routePreset = e.target.value;
        localStorage.setItem('routePreset', navState.routePreset);
        if (navState.routePreset === 'avoid-toll') navState.avoidTolls = true;
        if (navState.routePreset === 'scenic') navState.avoidHighways = true;
        console.log('Route preset set to:', navState.routePreset);
      });
      document.getElementById('offline-download-btn').addEventListener('click', () => {
        if (map) {
          const bounds = map.getBounds();
          const region = { bounds: bounds.toJSON(), name: `Region ${navState.offlineRegions.length + 1}`, timestamp: new Date().toISOString() };
          navState.offlineRegions.push(region);
          localStorage.setItem('offlineRegions', JSON.stringify(navState.offlineRegions));
          navigator.serviceWorker.controller?.postMessage({ type: 'CACHE_REGION', region });
          loadOfflineRegions();
          showToast('Region downloaded for offline use');
          console.log('Offline region downloaded:', region);
        }
      });
      document.getElementById('add-family-btn').addEventListener('click', () => {
        const email = document.getElementById('add-family-input').value.trim();
        if (email && navState.familyMembers.length < 5) {
          navState.familyMembers.push({ email });
          localStorage.setItem('familyMembers', JSON.stringify(navState.familyMembers));
          loadFamilyMembers();
          document.getElementById('add-family-input').value = '';
          showToast('Family member added');
        } else {
          showToast('Max 5 members or invalid email');
        }
      });
      document.getElementById('share-route-btn').addEventListener('click', () => {
        if (navState.currentRoute) {
          const shareData = { route: navState.currentRoute, family: navState.familyMembers };
          const shareUrl = `${window.location.href}?familyShare=${encodeURIComponent(JSON.stringify(shareData))}`;
          if (navigator.share) {
            navigator.share({ title: 'Share Route', url: shareUrl });
          } else {
            navigator.clipboard.writeText(shareUrl);
            showToast('Route shared via clipboard');
          }
          console.log('Route shared with family:', shareUrl);
        }
      });
      document.querySelectorAll('.report-button').forEach(button => {
        button.addEventListener('click', async () => {
          if (navState.alertState === 'IDLE') {
            const alertType = button.getAttribute('data-alert-type');
            console.log('Report button clicked:', { alertType });
            if (navState.alertFilters[alertType.toLowerCase()] === false) {
              showToast(`Filter disabled for ${alertType}`);
              return;
            }
            if (alertType === 'Manual Report' || alertType === 'Manual Traffic Camera') {
              const reportBox = document.getElementById('report-box');
              reportBox.classList.remove('active');
              navState.alertState = alertType === 'Manual Report' ? 'PLACING_ALERT' : 'PLACING_TRAFFIC_CAMERA';
              showToast(`Press a location on the map to place a ${alertType === 'Manual Report' ? 'hazard' : 'traffic camera'} alert.`);
              navState.mapClickListener = google.maps.event.addListener(map, 'click', (event) => {
                if (navState.alertState === 'PLACING_ALERT' || navState.alertState === 'PLACING_TRAFFIC_CAMERA') {
                  console.log('Map clicked for alert placement:', { lat: event.latLng.lat(), lng: event.latLng.lng() });
                  confirmAlertLocation(event.latLng, alertType === 'Manual Report' ? 'Manual Report' : 'Traffic Camera');
                }
              });
            } else {
              const location = new google.maps.LatLng(navState.userLocation);
              console.log('Placing alert at user location:', { alertType, location: navState.userLocation });
              confirmAlertLocation(location, alertType);
            }
          }
        });
      });
      document.getElementById('post-alert-button').addEventListener('click', postAlert);
      document.getElementById('cancel-alert-button').addEventListener('click', cancelAlert);
      document.getElementById('reroute-close').addEventListener('click', rejectReroute);
      document.getElementById('accept-reroute-button').addEventListener('click', acceptReroute);
      document.getElementById('reject-reroute-button').addEventListener('click', rejectReroute);
      document.getElementById('camera-close').addEventListener('click', dismissCameraAlert);
      document.getElementById('dismiss-camera-button').addEventListener('click', dismissCameraAlert);
      document.getElementById('arrival-close').addEventListener('click', endArrival);
      document.getElementById('arrival-ok-button').addEventListener('click', endArrival);
      document.getElementById('confirm-alert-btn').addEventListener('click', () => voteOnAlert(currentVerificationAlertId, 'up'));
      document.getElementById('dismiss-alert-btn').addEventListener('click', () => voteOnAlert(currentVerificationAlertId, 'down'));
      document.getElementById('verification-close').addEventListener('click', dismissVerificationHud);
      document.getElementById('user-profile-close').addEventListener('click', () => {
        document.getElementById('user-profile-hud-container').classList.remove('active');
      });
      // Add logout button event listener
      document.getElementById('logout-button').addEventListener('click', () => {
      console.log('Logout button clicked');
      localStorage.removeItem('token');
      localStorage.removeItem('userId');
      localStorage.removeItem('isAdmin');
      sessionStorage.removeItem('token');
      sessionStorage.removeItem('userId');
      sessionStorage.removeItem('isAdmin');
      isAdmin = false;
      document.getElementById('admin-button').style.display = 'none';
      document.getElementById('auth-container').style.display = 'flex';
      document.getElementById('settings-hud-container').classList.remove('active');
      showToast('Logged out successfully');
      if (socket) {
        socket.disconnect();
        socket = null;
      }
      stopGPS();
      console.log('User logged out, auth container shown');
    });
      let dragStartTime;
      let dragTimer;
      map.addListener('dragstart', () => {
        if (navState.isNavigating && navState.isFollowing && !isProgrammaticUpdate) {
          dragStartTime = Date.now();
          dragTimer = setTimeout(() => {
            unlockNavigation();
            console.log('Map unlocked for free roam on debounced dragstart during navigation');
          }, 150);
        }
      });
      map.addListener('drag', () => {
        if (navState.isNavigating && navState.isFollowing && !isProgrammaticUpdate && dragStartTime) {
          const dragDuration = Date.now() - dragStartTime;
          if (dragDuration < 150) {
            clearTimeout(dragTimer);
          }
        }
      });
      map.addListener('dragend', () => {
        if (dragTimer) {
          clearTimeout(dragTimer);
        }
        dragStartTime = null;
      });
      map.addListener('zoom_changed', () => {
        if (navState.isNavigating && navState.isFollowing && !isProgrammaticUpdate) {
          unlockNavigation();
          console.log('Map unlocked for free roam on zoom change during navigation');
        }
      });
      map.addListener('heading_changed', () => {
        updateCompass();
      });
      document.getElementById('recenter-button').addEventListener('click', () => {
        if (navState.isNavigating) {
          lockNavigation();
          console.log('Recenter button clicked, locking navigation, camera auto-follow resumed');
        } else {
          recenterNonNavigation();
          console.log('Recenter button clicked, re-centered to user location (non-navigation)');
        }
      });
      document.getElementById('traffic-layer-toggle').addEventListener('change', (e) => {
        navState.showTraffic = e.target.checked;
        localStorage.setItem('showTraffic', navState.showTraffic);
        sessionStorage.setItem('showTraffic', navState.showTraffic);
        trafficLayer.setMap(navState.showTraffic ? map : null);
        console.log('Traffic layer toggled:', navState.showTraffic);
      });
      document.getElementById('main-route-color').addEventListener('change', (e) => {
        navState.mainRouteColor = e.target.value;
        localStorage.setItem('mainRouteColor', navState.mainRouteColor);
        sessionStorage.setItem('mainRouteColor', navState.mainRouteColor);
        if (routePolyline) {
          routePolyline.setOptions({
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            zIndex: 5
          });
        }
        directionsRenderer.setOptions({
          polylineOptions: {
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            zIndex: 5
          }
        });
        console.log('Main route color changed to:', navState.mainRouteColor);
      });
      document.getElementById('alt-route-color').addEventListener('change', (e) => {
        navState.altRouteColor = e.target.value;
        localStorage.setItem('altRouteColor', navState.altRouteColor);
        sessionStorage.setItem('altRouteColor', navState.altRouteColor);
        alternativeRenderer.setOptions({
          polylineOptions: {
            strokeColor: navState.altRouteColor,
            strokeOpacity: 0,
            zIndex: 10,
            icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 }, offset: '0', repeat: '12px' }]
          }
        });
        if (navState.alternativeRoute) {
          alternativeRenderer.setDirections(navState.alternativeRoute);
        }
        console.log('Alternate route color changed to:', navState.altRouteColor);
      });
      document.getElementById('map-type').addEventListener('change', (e) => {
        navState.mapType = e.target.value;
        localStorage.setItem('mapType', navState.mapType);
        sessionStorage.setItem('mapType', navState.mapType);
        map.setMapTypeId(navState.mapType);
        console.log('Map type changed to:', navState.mapType);
      });
      document.getElementById('map-orientation').addEventListener('change', (e) => {
        navState.mapOrientation = e.target.value;
        localStorage.setItem('mapOrientation', navState.mapOrientation);
        sessionStorage.setItem('mapOrientation', navState.mapOrientation);
        console.log('Map orientation changed to:', navState.mapOrientation);
        if (navState.isNavigating && navState.isFollowing) {
          restoreNavigationView();
          updateCompass();
        }
      });
      document.getElementById('auto-recenter-toggle').addEventListener('change', (e) => {
        navState.isFollowing = e.target.checked;
        localStorage.setItem('isFollowing', navState.isFollowing);
        sessionStorage.setItem('isFollowing', navState.isFollowing);
        console.log('Auto-recenter toggled:', navState.isFollowing);
        if (navState.isFollowing && navState.isNavigating) {
          lockNavigation();
        } else if (navState.isNavigating) {
          unlockNavigation();
        }
      });
      document.getElementById('traffic-camera-toggle').addEventListener('change', (e) => {
        showTrafficCameras = e.target.checked;
        localStorage.setItem('showTrafficCameras', showTrafficCameras);
        sessionStorage.setItem('showTrafficCameras', showTrafficCameras);
        console.log('Traffic camera alerts toggled:', showTrafficCameras);
        cameraPositions = [];
        cameraAlertShown.clear();
        markers.forEach((marker, id) => {
          if (marker.title.includes('Traffic Camera') && !showTrafficCameras) {
            marker.setMap(null);
            markers.delete(id);
            console.log('Removed traffic camera marker due to toggle off:', id);
          }
        });
        fetchAndDisplayMarkers(map, navState.userLocation);
      });
      document.getElementById('high-contrast-toggle').addEventListener('change', (e) => {
        highContrastMode = e.target.checked;
        localStorage.setItem('highContrastMode', highContrastMode);
        sessionStorage.setItem('highContrastMode', highContrastMode);
        if (highContrastMode) {
          document.body.classList.add('high-contrast');
        } else {
          document.body.classList.remove('high-contrast');
        }
        console.log('High contrast mode toggled:', highContrastMode);
      });
      document.getElementById('hazard-alert-distance').addEventListener('change', (e) => {
        if (!navState.useDefaultDistances) {
          hazardAlertDistance = parseFloat(e.target.value);
          localStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          sessionStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          document.getElementById('hazard-distance-value').textContent = `${hazardAlertDistance} miles`;
          console.log('Hazard alert distance set to:', hazardAlertDistance, 'miles');
        }
      });
      document.getElementById('camera-alert-distance').addEventListener('change', (e) => {
        if (!navState.useDefaultDistances) {
          cameraAlertDistance = parseFloat(e.target.value);
          localStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          sessionStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          document.getElementById('camera-distance-value').textContent = `${cameraAlertDistance} miles`;
          console.log('Camera alert distance set to:', cameraAlertDistance, 'miles');
        }
      });
      document.getElementById('use-default-distances').addEventListener('change', (e) => {
        navState.useDefaultDistances = e.target.checked;
        localStorage.setItem('useDefaultDistances', navState.useDefaultDistances);
        sessionStorage.setItem('useDefaultDistances', navState.useDefaultDistances);
        if (navState.useDefaultDistances) {
          hazardAlertDistance = 2;
          cameraAlertDistance = 0.5;
          localStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          sessionStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          localStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          sessionStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          document.getElementById('hazard-alert-distance').value = hazardAlertDistance;
          document.getElementById('hazard-distance-value').textContent = `${hazardAlertDistance} miles`;
          document.getElementById('camera-alert-distance').value = cameraAlertDistance;
          document.getElementById('camera-distance-value').textContent = `${cameraAlertDistance} miles`;
          console.log('Restored default distances: hazard=2 miles, camera=0.5 miles');
        }
      });
      document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.settings-tab-content').forEach(c => c.style.display = 'none');
          tab.classList.add('active');
          document.getElementById(tab.getAttribute('data-tab')).style.display = 'block';
          console.log('Switched to settings tab:', tab.getAttribute('data-tab'));
        });
      });
      document.querySelectorAll('.alerts-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.alerts-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.alerts-tab-content').forEach(c => c.style.display = 'none');
          tab.classList.add('active');
          document.getElementById(tab.getAttribute('data-tab')).style.display = 'block';
          console.log('Switched to alerts tab:', tab.getAttribute('data-tab'));
        });
      });
      window.addEventListener('orientationchange', () => {
        adjustHud();
        if (navState.isFollowing) {
          restoreNavigationView();
        }
      });
    }
    async function startWakeWordDetection() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('Speech recognition not supported');
        showToast('Voice assistant not supported in this browser');
        return;
      }
      if (!voiceAssistantEnabled) {
        console.log('Voice assistant disabled, skipping');
        return;
      }
      try {
        await navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
          stream.getTracks().forEach(track => track.stop());
          console.log('Mic access granted for wake word');
        }).catch(err => {
          console.error('Mic access denied:', err);
          showToast('Mic access denied - check permissions');
          return;
        });
        if (wakeWordRecognizer) {
          wakeWordRecognizer.stop();
        }
        wakeWordRecognizer = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        wakeWordRecognizer.continuous = true;
        wakeWordRecognizer.interimResults = true;
        wakeWordRecognizer.lang = 'en-US';
        wakeWordRecognizer.maxAlternatives = 1;
        wakeWordRecognizer.onresult = (event) => {
          let transcript = '';
          for (let i = event.resultIndex; i < event.results.length; i++) {
            transcript += event.results[i][0].transcript.toLowerCase().trim();
          }
          console.log('Wake word heard:', transcript);
          if (transcript.includes('hey nova')) {
            console.log('Wake word "Hey Nova" detected');
            showToast('Listening for command...');
            wakeWordRecognizer.stop();
            startCommandRecognition();
            setTimeout(startWakeWordDetection, 3000);
          }
        };
        wakeWordRecognizer.onerror = (event) => {
          console.error('Wake word recognition error:', event.error);
          if (event.error === 'not-allowed') {
            showToast('Mic access denied - check permissions');
          } else if (event.error !== 'aborted') {
            setTimeout(startWakeWordDetection, 1000);
          }
        };
        wakeWordRecognizer.onend = () => {
          if (voiceAssistantEnabled) {
            setTimeout(startWakeWordDetection, 100);
          }
        };
        wakeWordRecognizer.start();
        console.log('Wake word detection started');
        showToast('Voice assistant enabled');
      } catch (err) {
        console.error('Failed to start wake word detection:', err);
        showToast('Voice assistant failed to start');
        stopWakeWordDetection();
      }
    }
    function stopWakeWordDetection() {
      if (wakeWordRecognizer) {
        wakeWordRecognizer.stop();
        wakeWordRecognizer = null;
        console.log('Wake word detection stopped');
      }
      if (commandSpeechRecognition) {
        commandSpeechRecognition.stop();
        commandSpeechRecognition = null;
        console.log('Command recognition stopped');
      }
    }
    function startCommandRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('Speech recognition not supported');
        showToast('Command recognition not supported');
        return;
      }
      if (commandSpeechRecognition) {
        commandSpeechRecognition.stop();
      }
      commandSpeechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      commandSpeechRecognition.lang = 'en-US';
      commandSpeechRecognition.interimResults = false;
      commandSpeechRecognition.maxAlternatives = 1;
      commandSpeechRecognition.onresult = (event) => {
        const command = event.results[0][0].transcript.toLowerCase().trim();
        console.log('Command recognized:', command);
        parseAndExecuteCommand(command);
      };
      commandSpeechRecognition.onerror = (event) => {
        console.error('Command recognition error:', event.error);
        showToast('Command recognition error: ' + event.error);
      };
      commandSpeechRecognition.onend = () => {
        console.log('Command recognition ended');
        commandSpeechRecognition = null;
        if (voiceAssistantEnabled) {
          startWakeWordDetection();
        }
      };
      commandSpeechRecognition.start();
      console.log('Command recognition started');
    }
    function parseAndExecuteCommand(command) {
      if (command.includes('go to') || command.includes('navigate to')) {
        const addressMatch = command.match(/go to\s+(.+)/i) || command.match(/navigate to\s+(.+)/i);
        if (addressMatch) {
          const address = addressMatch[1].trim();
          document.getElementById('search-input').value = address;
          console.log('Setting address for navigation:', address);
          const placeChangedEvent = new Event('place_changed');
          google.maps.event.trigger(document.getElementById('search-input'), 'place_changed', placeChangedEvent);
          showToast(`Navigating to ${address}`);
          if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance('Starting navigation');
            utterance.lang = 'en-US';
            speechSynthesis.speak(utterance);
          }
          setTimeout(startGPS, 1000);
        }
      } else if (command.includes('place an alert at my location')) {
        document.getElementById('hazard-button').click();
        showToast('Placing alert at current location');
      } else if (command.includes('place an alert at this location')) {
        showToast('Tap on the map to place alert');
        const manualReportButton = document.querySelector('[data-alert-type="Manual Report"]');
        if (manualReportButton) manualReportButton.click();
      } else if (command.includes('recenter')) {
        document.getElementById('recenter-button').click();
        showToast('Recentering map');
      } else if (command.includes('share route')) {
        shareRoute();
      } else {
        showToast(`Command not recognized: ${command}`);
      }
    }
    async function fetchProfile(targetId, isOwn) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          throw new Error('Invalid token format in storage');
        }
        console.log('Fetching profile with token:', token.substring(0, 20) + '...');
        let response = await fetchWithRetry(`/api/auth/profile/${targetId}`, {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Profile fetch response:', { status: response.status, ok: response.ok });
        const data = await response.json();
        if (!response.ok) throw new Error(`Profile fetch failed: ${data.error || response.statusText}`);
        isAdmin = data.email === 'imhoggbox@gmail.com' || data.isAdmin;
        localStorage.setItem('isAdmin', isAdmin);
        sessionStorage.setItem('isAdmin', isAdmin);
        if (isAdmin) {
          document.getElementById('admin-button').style.display = 'flex';
        }
        return data;
      } catch (err) {
        console.error('Failed to fetch profile:', err);
        showToast('Failed to load profile data. Please log in again.');
        localStorage.removeItem('token');
        localStorage.removeItem('userId');
        sessionStorage.removeItem('token');
        sessionStorage.removeItem('userId');
        document.getElementById('auth-container').style.display = 'flex';
        throw err;
      }
    }
    function populateAccountProfile(data) {
      document.getElementById('username-display').textContent = data.username || 'N/A';
      document.getElementById('email-display').textContent = data.email || 'N/A';
      document.getElementById('join-date-display').textContent = data.joinDate ? new Date(data.joinDate).toLocaleDateString() : 'N/A';
      document.getElementById('total-alerts-display').textContent = data.totalAlerts || 0;
      document.getElementById('active-alerts-display').textContent = data.activeAlerts || 0;
      document.getElementById('points-display').textContent = `Points: ${data.points || 0}`;
      document.getElementById('edit-username').value = data.username || '';
      document.getElementById('edit-email').value = data.email || '';
      document.getElementById('edit-password').value = '';
    }
    function viewUserProfile(userId) {
      fetchProfile(userId, false).then(data => {
        document.getElementById('hud-username').textContent = data.username || 'N/A';
        document.getElementById('hud-join-date').textContent = data.joinDate ? new Date(data.joinDate).toLocaleDateString() : 'N/A';
        document.getElementById('hud-total-alerts').textContent = data.totalAlerts || 0;
        document.getElementById('hud-active-alerts').textContent = data.activeAlerts || 0;
        document.getElementById('hud-points').textContent = `Points: ${data.points || 0}`;
        document.getElementById('user-profile-hud-container').classList.add('active');
      }).catch(err => {
        console.error('Failed to fetch user profile:', err);
        showToast('Failed to load user profile.');
      });
    }
    window.viewUserProfile = viewUserProfile;
    async function requestPushPermission() {
      if (!pushNotificationsEnabled) {
        console.log('Push notifications disabled, skipping permission request');
        return;
      }
      if ('PushManager' in window) {
        try {
          const permission = await Notification.requestPermission();
          if (permission === 'granted') {
            console.log('Push notification permission granted');
            await subscribeToPush();
          } else {
            console.warn('Push notification permission denied');
            showToast('Notifications blocked. Enable in browser settings for alerts.');
            localStorage.setItem('pushNotificationsEnabled', false);
            sessionStorage.setItem('pushNotificationsEnabled', false);
            document.getElementById('push-notifications-toggle').checked = false;
            pushNotificationsEnabled = false;
          }
        } catch (err) {
          console.error('Error requesting push permission:', err);
          showToast('Failed to request notification permission.');
        }
      } else {
        console.warn('Push notifications not supported');
        showToast('Push notifications not supported by this browser.');
        localStorage.setItem('pushNotificationsEnabled', false);
        sessionStorage.setItem('pushNotificationsEnabled', false);
        document.getElementById('push-notifications-toggle').checked = false;
        pushNotificationsEnabled = false;
      }
    }
    async function subscribeToPush() {
      if (!pushNotificationsEnabled) {
        console.log('Push notifications disabled, skipping subscription');
        return;
      }
      try {
        const reg = await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlB64ToUint8Array(VAPID_PUBLIC_KEY)
        });
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, cannot subscribe to push');
          return;
        }
        console.log('Subscribing to push with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry('/api/auth/subscribe', {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token.trim()}`
          },
          body: JSON.stringify(sub)
        });
        console.log('Push subscription response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error(`Failed to subscribe: ${response.statusText}`);
        console.log('Subscribed to push notifications');
      } catch (err) {
        console.error('Failed to subscribe to push:', err);
        showToast('Failed to enable notifications.');
      }
    }
    async function unsubscribeFromPush() {
      try {
        const reg = await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.getSubscription();
        if (sub) {
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          if (!token || !token.includes('.') || token === 'undefined') {
            console.error('Invalid token, cannot unsubscribe from push');
            return;
          }
          console.log('Unsubscribing from push with token:', token.substring(0, 20) + '...');
          await fetchWithRetry('/api/auth/unsubscribe', {
            method: 'POST',
            mode: 'cors',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token.trim()}`
            },
            body: JSON.stringify(sub)
          });
          await sub.unsubscribe();
          console.log('Unsubscribed from push notifications');
        } else {
          console.log('No push subscription to unsubscribe');
        }
      } catch (err) {
        console.error('Failed to unsubscribe from push:', err);
        showToast('Failed to disable notifications.');
      }
    }
    function urlB64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }
    async function fetchLeaderboard() {
      const token = localStorage.getItem('token') || sessionStorage.getItem('token');
      if (!token || !token.includes('.') || token === 'undefined') {
        console.error('Invalid token, showing auth form');
        localStorage.removeItem('token');
        localStorage.removeItem('userId');
        sessionStorage.removeItem('token');
        sessionStorage.removeItem('userId');
        document.getElementById('auth-container').style.display = 'flex';
        return;
      }
      try {
        console.log('Fetching leaderboard with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry('/api/leaderboard', {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Leaderboard fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error(`Leaderboard fetch failed: ${response.statusText}`);
        const users = await response.json();
        const content = document.getElementById('leaderboard-content');
        content.innerHTML = '';
        users.forEach((user, index) => {
          const item = document.createElement('div');
          item.className = 'alert-item';
          item.innerHTML = `
            <div class="alert-field"><strong>#${index + 1} ${user.username}</strong> - Points: ${user.points}</div>
            <div class="alert-field">Achievements: ${Array.isArray(user.achievements) ? user.achievements.join(', ') : 'None'}</div>
          `;
          content.appendChild(item);
        });
        console.log('Leaderboard fetched:', users.length);
      } catch (err) {
        console.error('Failed to fetch leaderboard:', err);
        showToast('Failed to load leaderboard.');
      }
    }
    function startVoiceRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('Speech recognition not supported');
        showToast('Speech recognition not supported');
        return;
      }
      if (!speechRecognition) {
        speechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        speechRecognition.lang = 'en-US';
        speechRecognition.interimResults = false;
        speechRecognition.maxAlternatives = 1;
        speechRecognition.onresult = (event) => {
          const command = event.results[0][0].transcript.toLowerCase();
          console.log('Voice command:', command);
          if (command.includes('report hazard')) {
            document.getElementById('hazard-button').click();
          } else if (command.includes('start navigation')) {
            document.getElementById('start-button').click();
          } else if (command.includes('stop navigation')) {
            document.getElementById('bottom-hud-stop').click();
          }
        };
        speechRecognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          showToast('Speech recognition error: ' + event.error);
        };
      }
      speechRecognition.start();
      console.log('Speech recognition started');
    }
    function shareRoute() {
      if (navigator.share && navState.currentRoute) {
        const shareData = { route: navState.currentRoute, family: navState.familyMembers };
        navigator.share({
          title: 'My Route',
          text: 'Check out my current route!',
          url: `${window.location.href}?route=${encodeURIComponent(JSON.stringify(shareData))}`
        }).then(() => console.log('Route shared successfully'))
          .catch(err => {
            console.error('Share failed:', err);
            showToast('Sharing not supported');
          });
      } else {
        showToast('Sharing not supported');
      }
    }
    async function refreshToken() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          throw new Error('Invalid token format in storage');
        }
        console.log('Refreshing token:', token.substring(0, 20) + '...');
        const response = await fetch('/api/auth/refresh', {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Token refresh response:', { status: response.status, ok: response.ok });
        const data = await response.json();
        if (response.ok) {
          localStorage.setItem('token', data.token);
          sessionStorage.setItem('token', data.token);
          console.log('Token refreshed:', data.token.substring(0, 20) + '...');
          return true;
        } else {
          throw new Error('Token refresh failed: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Token refresh failed:', error);
        showToast('Session expired. Please log in again.');
        localStorage.removeItem('token');
        localStorage.removeItem('userId');
        sessionStorage.removeItem('token');
        sessionStorage.removeItem('userId');
        document.getElementById('auth-container').style.display = 'flex';
        return false;
      }
    }
    async function fetchWithRetry(url, options, retries = 3, backoff = 1000) {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url, options);
          if (response.status === 401) {
            console.log(`Attempt ${i + 1} failed with 401, trying to refresh token`);
            const refreshed = await refreshToken();
            if (refreshed) {
              const newToken = localStorage.getItem('token') || sessionStorage.getItem('token');
              options.headers['Authorization'] = `Bearer ${newToken.trim()}`;
              return await fetch(url, options);
            }
            throw new Error('Unauthorized after token refresh');
          }
          return response;
        } catch (err) {
          console.error(`Fetch attempt ${i + 1} failed for ${url}:`, err);
          if (i < retries - 1) {
            await new Promise(resolve => setTimeout(resolve, backoff * Math.pow(2, i)));
          } else {
            throw err;
          }
        }
      }
    }
    function confirmAlertLocation(latLng, alertType) {
      navState.alertState = 'CONFIRMING';
      navState.tempAlertData = { latLng, alertType };
      const reportBox = document.getElementById('report-box');
      const reportOptions = document.querySelector('.report-options');
      const confirmAlert = document.getElementById('confirm-alert');
      reportBox.classList.add('active');
      reportOptions.style.display = 'none';
      confirmAlert.classList.add('active');
      document.getElementById('alert-type-display').textContent = alertType;
      document.getElementById('location-display').textContent = `${latLng.lat().toFixed(4)}, ${latLng.lng().toFixed(4)}`;
      document.getElementById('timestamp-display').textContent = new Date().toLocaleString();
      if (navState.tempMarker) navState.tempMarker.setMap(null);
      const tempMarkerElement = document.createElement('div');
      tempMarkerElement.style.width = '20px';
      tempMarkerElement.style.height = '20px';
      tempMarkerElement.style.backgroundColor = 'red';
      tempMarkerElement.style.borderRadius = '50%';
      tempMarkerElement.style.border = '2px solid white';
      navState.tempMarker = new google.maps.marker.AdvancedMarkerElement({
        map: map,
        position: latLng,
        content: tempMarkerElement,
        title: 'Temporary Alert'
      });
      console.log('Confirming alert location:', { alertType, lat: latLng.lat(), lng: latLng.lng() });
    }
    async function postAlert() {
      if (navState.alertState !== 'CONFIRMING' || !navState.tempAlertData) {
        console.warn('Invalid alert state or data:', { state: navState.alertState, tempAlertData: navState.tempAlertData });
        return;
      }
      const { latLng, alertType } = navState.tempAlertData;
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        const geocoder = new google.maps.Geocoder();
        let address = 'Unknown';
        try {
          const response = await geocoder.geocode({ location: latLng });
          if (response.results[0]) {
            address = response.results[0].formatted_address;
            console.log('Geocoded address for alert:', address);
          }
        } catch (error) {
          console.error('Geocoding failed:', error);
        }
        const alertData = {
          type: alertType,
          location: {
            type: 'Point',
            coordinates: [latLng.lng(), latLng.lat()]
          },
          address,
          timestamp: new Date().toISOString()
        };
        console.log('Posting alert:', alertData);
        const response = await fetchWithRetry('/api/alerts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token.trim()}`
          },
          body: JSON.stringify(alertData)
        });
        console.log('Alert post response:', { status: response.status, ok: response.ok });
        const data = await response.json();
        if (response.ok && data.alert) {
          showToast('Alert posted successfully!');
          const reportBox = document.getElementById('report-box');
          reportBox.classList.remove('active');
          if (navState.tempMarker) {
            navState.tempMarker.setMap(null);
            navState.tempMarker = null;
          }
          navState.alertState = 'IDLE';
          navState.tempAlertData = null;
          if (navState.mapClickListener) {
            google.maps.event.removeListener(navState.mapClickListener);
            navState.mapClickListener = null;
          }
          console.log('Alert posted:', data.alert);
          if (navState.isNavigating && navState.isFollowing) {
            lockNavigation();
            console.log('Navigation view re-locked after posting alert');
          }
        } else if (response.status === 409 && data.alert) {
          showToast('Duplicate alert ignored.');
          const reportBox = document.getElementById('report-box');
          reportBox.classList.remove('active');
          if (navState.tempMarker) {
            navState.tempMarker.setMap(null);
            navState.tempMarker = null;
          }
          navState.alertState = 'IDLE';
          navState.tempAlertData = null;
          if (navState.mapClickListener) {
            google.maps.event.removeListener(navState.mapClickListener);
            navState.mapClickListener = null;
          }
          console.log('Duplicate alert ignored:', data.alert);
        } else {
          console.error('Failed to post alert:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to post alert.');
        }
      } catch (error) {
        console.error('Error posting alert:', error);
        showToast('Failed to post alert.');
      }
    }
    function cancelAlert() {
      const reportBox = document.getElementById('report-box');
      reportBox.classList.remove('active');
      if (navState.tempMarker) {
        navState.tempMarker.setMap(null);
        navState.tempMarker = null;
      }
      navState.alertState = 'IDLE';
      navState.tempAlertData = null;
      if (navState.mapClickListener) {
        google.maps.event.removeListener(navState.mapClickListener);
        navState.mapClickListener = null;
      }
      if (navState.isNavigating && navState.isFollowing) {
        lockNavigation();
        console.log('Navigation view re-locked after cancelling alert');
      }
      console.log('Alert cancelled, state reset to IDLE');
    }
    function createTrafficCameraContent() {
      const content = document.createElement('div');
      content.innerHTML = '<img src="https://i.postimg.cc/jjN0JrPZ/New-Project-5.png" class="traffic-cam-marker">';
      return content;
    }
    function createAlertContent() {
      const content = document.createElement('div');
      content.style.width = '20px';
      content.style.height = '20px';
      content.style.backgroundColor = 'red';
      content.style.borderRadius = '50%';
      content.style.border = '2px solid white';
      content.classList.add('ping');
      return content;
    }
    async function fetchAndDisplayMarkers(map, center) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching markers near:', center);
        const response = await fetchWithRetry(`/api/markers?lat=${center.lat}&lng=${center.lng}&maxDistance=${navState.alertRadius * 1609.34}`, {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Markers fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error(`Failed to fetch markers: ${response.statusText}`);
        const alerts = await response.json();
        console.log('Markers fetched:', alerts.length);
        currentAlerts = alerts;
        markers.forEach((marker, id) => {
          if (!alerts.some(alert => alert._id === id)) {
            marker.setMap(null);
            markers.delete(id);
            console.log('Removed expired marker:', id);
          }
        });
        alerts.forEach(alert => {
          if (alert.type === 'Traffic Camera' && !showTrafficCameras) return;
          if (navState.alertFilters[alert.type.toLowerCase()] === false) return;
          if (!markers.has(alert._id)) {
            const isTrafficCamera = alert.type === 'Traffic Camera';
            const content = isPremium && alert.type === 'Police' ? createSpeedTrapIcon() : isTrafficCamera ? createTrafficCameraContent() : createAlertContent();
            const marker = new google.maps.marker.AdvancedMarkerElement({
              map: map,
              position: { lat: alert.location.coordinates[1], lng: alert.location.coordinates[0] },
              content,
              title: `${alert.type} Alert`
            });
            marker.addListener('click', () => showAlertDetails(alert));
            markers.set(alert._id, marker);
            console.log('Added marker:', { id: alert._id, type: alert.type, position: alert.location.coordinates });
          }
        });
        console.log('Active markers:', markers.size);
      } catch (error) {
        console.error('Error fetching markers:', error);
        showToast('Failed to load alerts.');
      }
    }
    function showAlertDetails(alert) {
      const content = document.getElementById('information');
      content.innerHTML = '';
      const item = document.createElement('div');
      item.className = 'alert-item';
      item.innerHTML = `
        <div class="alert-field"><strong>Type:</strong> ${alert.type}</div>
        <div class="alert-field"><strong>Location:</strong> ${alert.address || 'Unknown'}</div>
        <div class="alert-field"><strong>Posted:</strong> ${new Date(alert.timestamp).toLocaleString()}</div>
        <div class="alert-field"><strong>Expires:</strong> ${new Date(alert.expiry).toLocaleString()}</div>
        <div class="alert-field"><strong>Posted by:</strong> <a href="#" onclick="viewUserProfile('${alert.userId._id}')">${alert.userId.username}</a></div>
        <div class="alert-votes">
          <button class="vote-btn upvote-btn" onclick="voteOnAlert('${alert._id}', 'up')">Upvote (${alert.votes.up})</button>
          <button class="vote-btn downvote-btn" onclick="voteOnAlert('${alert._id}', 'down')">Downvote (${alert.votes.down})</button>
        </div>
        <div class="alert-actions">
          <button class="center-btn" onclick="centerOnAlert(${alert.location.coordinates[1]}, ${alert.location.coordinates[0]})">Center</button>
          <button class="delete-btn" onclick="deleteAlert('${alert._id}')">Delete</button>
        </div>
      `;
      content.appendChild(item);
      document.getElementById('alerts-hud-container').classList.add('active');
      document.getElementById('information').style.display = 'block';
      document.getElementById('alerts-tabs').querySelector('[data-tab="information"]').classList.add('active');
      document.getElementById('alerts-tabs').querySelector('[data-tab="tools"]').classList.remove('active');
      document.getElementById('tools').style.display = 'none';
      console.log('Showing alert details:', alert._id);
    }
    window.centerOnAlert = function(lat, lng) {
      map.setCenter({ lat, lng });
      map.setZoom(15);
      console.log('Centered on alert:', { lat, lng });
    };
    async function voteOnAlert(alertId, voteType) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Voting on alert:', { alertId, voteType });
        const response = await fetchWithRetry(`/api/alerts/${alertId}/vote`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token.trim()}`
          },
          body: JSON.stringify({ voteType })
        });
        console.log('Vote response:', { status: response.status, ok: response.ok });
        const data = await response.json();
        if (response.ok && data.deleted) {
          showToast('Alert deleted due to votes.');
          if (markers.has(alertId)) {
            markers.get(alertId).setMap(null);
            markers.delete(alertId);
            console.log('Deleted alert marker:', alertId);
          }
        } else if (response.ok) {
          showToast(`${voteType.charAt(0).toUpperCase() + voteType.slice(1)}vote recorded.`);
          const alert = currentAlerts.find(a => a._id === alertId);
          if (alert) {
            alert.votes[voteType] = data.votes[voteType];
            showAlertDetails(alert);
            console.log('Alert votes updated:', { alertId, votes: data.votes });
          }
        } else {
          console.error('Failed to vote:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to vote on alert.');
        }
      } catch (error) {
        console.error('Error voting on alert:', error);
        showToast('Failed to vote on alert.');
      }
    }
    async function deleteAlert(alertId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Deleting alert:', alertId);
        const response = await fetchWithRetry(`/api/alerts/${alertId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Delete alert response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('Alert deleted successfully.');
          if (markers.has(alertId)) {
            markers.get(alertId).setMap(null);
            markers.delete(alertId);
            console.log('Deleted alert marker:', alertId);
          }
          document.getElementById('alerts-hud-container').classList.remove('active');
        } else {
          const data = await response.json();
          console.error('Failed to delete alert:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to delete alert.');
        }
      } catch (error) {
        console.error('Error deleting alert:', error);
        showToast('Failed to delete alert.');
      }
    }
    function dismissCameraAlert() {
      document.getElementById('camera-hud-container').classList.remove('active');
      console.log('Camera alert dismissed');
    }
    function endArrival() {
      document.getElementById('arrival-hud-container').classList.remove('active');
      navState.hasArrived = false;
      stopGPS();
      console.log('Arrival HUD dismissed, navigation ended');
    }
    function dismissVerificationHud() {
      document.getElementById('verification-hud-container').classList.remove('active');
      currentVerificationAlertId = null;
      console.log('Verification HUD dismissed');
    }
    function closeAllHuds() {
      const huds = [
        'report-box', 'reroute-hud-container', 'settings-hud-container',
        'alerts-hud-container', 'camera-hud-container', 'leaderboard-hud-container',
        'arrival-hud-container', 'admin-hud-container', 'verification-hud-container',
        'user-profile-hud-container'
      ];
      huds.forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      if (navState.isNavigating && navState.isFollowing) {
        lockNavigation();
      }
      console.log('All HUDs closed');
    }
    function lockNavigation() {
      if (!navState.isFollowing || !navState.isNavigating) return;
      navState.isFollowing = true;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      map.setOptions({ gestureHandling: 'none', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
      restoreNavigationView();
      console.log('Navigation locked: gestures disabled, following user');
    }
    function unlockNavigation() {
      navState.isFollowing = false;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      map.setOptions({ gestureHandling: 'cooperative', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
      console.log('Navigation unlocked: gestures enabled');
    }
    function restoreNavigationView() {
      if (!navState.isNavigating || !navState.isFollowing) return;
      const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, navState.currentHeading);
      const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
      const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 50);
      isProgrammaticUpdate = true;
      requestAnimationFrame(() => {
        map.panTo(lookaheadPoint);
        map.setZoom(zoom);
        if (!isHeadingTweening) {
          map.setHeading(heading);
          userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
        }
        map.setTilt(tilt);
        isProgrammaticUpdate = false;
        updateCompass();
        console.log('Restored navigation view:', { center: lookaheadPoint, zoom, heading, tilt });
      });
    }
    function recenterNonNavigation() {
      navState.isFollowing = true;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      isProgrammaticUpdate = true;
      requestAnimationFrame(() => {
        map.panTo(navState.userLocation);
        map.setZoom(navState.navigationZoom);
        map.setHeading(navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading);
        map.setTilt(45);
        userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
        isProgrammaticUpdate = false;
        console.log('Recentered to user location (non-navigation):', { center: navState.userLocation, zoom: navState.navigationZoom });
        updateCompass();
      });
    }
    function getDynamicZoom(position, heading) {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) {
        return { zoom: navState.navigationZoom, tilt: 45, turnHeading: null };
      }
      const routePath = google.maps.geometry.encoding.decodePath(navState.currentRoute.routes[0].overview_polyline);
      let closestPoint = null;
      let minDistance = Infinity;
      let closestIndex = -1;
      routePath.forEach((point, index) => {
        const distance = google.maps.geometry.spherical.computeDistanceBetween(position, point);
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = point;
          closestIndex = index;
        }
      });
      let zoom = STRAIGHT_ZOOM;
      let tilt = 45;
      let turnHeading = null;
      if (closestIndex >= 0 && closestIndex < routePath.length - 1) {
        const nextPoint = routePath[closestIndex + 1];
        const prevPoint = closestIndex > 0 ? routePath[closestIndex - 1] : null;
        if (prevPoint && nextPoint) {
          const bearingToNext = google.maps.geometry.spherical.computeHeading(closestPoint, nextPoint);
          const bearingFromPrev = google.maps.geometry.spherical.computeHeading(prevPoint, closestPoint);
          const angleDiff = Math.abs(((bearingToNext - bearingFromPrev + 180) % 360) - 180);
          if (angleDiff > SIGNIFICANT_TURN_THRESHOLD) {
            const distanceToNext = google.maps.geometry.spherical.computeDistanceBetween(position, nextPoint);
            if (distanceToNext < TURN_THRESHOLD) {
              zoom = TURN_ZOOM;
              tilt = 60;
              turnHeading = bearingToNext;
              console.log('Significant turn detected, adjusting zoom:', { angleDiff, distanceToNext, zoom, tilt });
            }
          }
        }
      }
      return { zoom, tilt, turnHeading };
    }
    function getLookaheadPoint(position, heading, distance) {
      return google.maps.geometry.spherical.computeOffset(
        new google.maps.LatLng(position.lat, position.lng),
        distance,
        heading
      );
    }
    function startGPS() {
      if (!navState.destination) {
        console.warn('No destination set for navigation');
        showToast('Please select a destination.');
        return;
      }
      if (watchId) {
        console.log('GPS already active, updating navigation state');
        navState.isNavigating = true;
        navState.isFollowing = true;
        localStorage.setItem('isFollowing', navState.isFollowing);
        sessionStorage.setItem('isFollowing', navState.isFollowing);
        lockNavigation();
        startHazardCheck();
        startCameraCheck();
        startAlertPolling();
        document.getElementById('hud-container').style.display = 'flex';
        document.getElementById('bottom-hud-container').style.display = 'flex';
        document.getElementById('start-button').style.display = 'none';
        return;
      }
      console.log('Starting GPS navigation');
      if (navigator.geolocation) {
        watchId = navigator.geolocation.watchPosition(
          onPositionUpdate,
          (error) => handleGeolocationError(error),
          { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
        );
        navState.isNavigating = true;
        navState.isFollowing = true;
        localStorage.setItem('isFollowing', navState.isFollowing);
        sessionStorage.setItem('isFollowing', navState.isFollowing);
        lockNavigation();
        startHazardCheck();
        startCameraCheck();
        startAlertPolling();
        document.getElementById('hud-container').style.display = 'flex';
        document.getElementById('bottom-hud-container').style.display = 'flex';
        document.getElementById('start-button').style.display = 'none';
        if (!isLowBattery) {
          requestWakeLock();
        }
        console.log('GPS started, navigation active');
      } else {
        console.error('Geolocation not supported');
        showToast('Geolocation not supported by this browser.');
      }
    }
    function stopGPS() {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
        console.log('GPS watch cleared');
      }
      if (mockSimulationInterval) {
        clearInterval(mockSimulationInterval);
        mockSimulationInterval = null;
        document.getElementById('simulate-position-button').textContent = 'Simulate';
        console.log('Position simulation stopped');
      }
      if (navState.rerouteCheckTimeout) {
        clearTimeout(navState.rerouteCheckTimeout);
        navState.rerouteCheckTimeout = null;
      }
      if (navState.hazardCheckInterval) {
        clearInterval(navState.hazardCheckInterval);
        navState.hazardCheckInterval = null;
      }
      if (cameraCheckInterval) {
        clearInterval(cameraCheckInterval);
        cameraCheckInterval = null;
      }
      if (alertPollInterval) {
        clearInterval(alertPollInterval);
        alertPollInterval = null;
      }
      navState.isNavigating = false;
      navState.isFollowing = false;
      navState.currentRoute = null;
      navState.alternativeRoute = null;
      navState.ignoredHazards = [];
      navState.currentHazard = null;
      navState.pendingReroute = null;
      navState.hasArrived = false;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      if (routePolyline) {
        routePolyline.setMap(null);
        routePolyline = null;
      }
      if (offRoadPolyline) {
        offRoadPolyline.setMap(null);
        offRoadPolyline = null;
      }
      if (directionsRenderer) {
        directionsRenderer.setMap(null);
      }
      if (alternativeRenderer) {
        alternativeRenderer.setMap(null);
      }
      if (destMarker) {
        destMarker.setMap(null);
        destMarker = null;
      }
      document.getElementById('hud-container').style.display = 'none';
      document.getElementById('bottom-hud-container').style.display = 'none';
      document.getElementById('start-button').style.display = 'block';
      document.getElementById('simulate-position-button').style.display = 'block';
      map.setOptions({ gestureHandling: 'cooperative', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
      releaseWakeLock();
      console.log('Navigation stopped, all resources cleared');
    }
    function handleGeolocationError(error) {
      console.error('Geolocation error:', { code: error.code, message: error.message });
      if (error.code === error.PERMISSION_DENIED) {
        showToast('Location access denied. Please enable location services.');
        stopGPS();
      } else if (error.code === error.POSITION_UNAVAILABLE || error.code === error.TIMEOUT) {
        retryCount++;
        if (retryCount >= MAX_RETRIES) {
          showToast('Unable to retrieve location after multiple attempts.');
          stopGPS();
        } else {
          showToast('Retrying location retrieval...');
          setTimeout(() => {
            if (navigator.geolocation && !watchId) {
              watchId = navigator.geolocation.watchPosition(
                onPositionUpdate,
                (err) => handleGeolocationError(err),
                { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
              );
            }
          }, 2000);
        }
      }
    }
    async function onPositionUpdate(position) {
      const newPos = {
        lat: position.coords.latitude,
        lng: position.coords.longitude
      };
      rawUserLocation = newPos;
      const smoothedPos = smoothPosition(newPos);
      let heading = position.coords.heading;
      const speed = position.coords.speed || 0;
      if (heading === null || isNaN(heading)) {
        heading = compassHeading || navState.currentHeading;
        console.log('Using compass or last known heading:', heading);
      }
      const snappedPos = await snapToRoad(smoothedPos);
      navState.previousUserLocation = navState.userLocation;
      navState.userLocation = snappedPos || smoothedPos;
      navState.lastKnownPosition = navState.userLocation;
      const isSnapped = !!snappedPos;
      navState.currentHeading = smoothHeading(heading, isSnapped ? 'polyline' : 'gps', speed, isSnapped);
      userMarker.position = navState.userLocation;
      console.log('Position updated:', {
        raw: newPos,
        smoothed: smoothedPos,
        snapped: snappedPos,
        heading: navState.currentHeading,
        speed,
        isSnapped
      });
      const now = Date.now();
      if (now - lastLocationUpdate >= LOCATION_UPDATE_THRESHOLD) {
        lastLocationUpdate = now;
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        try {
          const response = await fetchWithRetry('/api/location', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token.trim()}`
            },
            body: JSON.stringify({
              location: {
                type: 'Point',
                coordinates: [navState.userLocation.lng, navState.userLocation.lat]
              }
            })
          });
          console.log('Location update response:', { status: response.status, ok: response.ok });
          if (!response.ok) throw new Error('Failed to update location');
          socket?.emit('locationUpdate', {
            userId: localStorage.getItem('userId') || sessionStorage.getItem('userId'),
            location: navState.userLocation
          });
        } catch (error) {
          console.error('Error updating location to server:', error);
        }
      }
      if (navState.isNavigating && navState.isFollowing) {
        const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, navState.currentHeading);
        const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
        const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 50);
        isProgrammaticUpdate = true;
        requestAnimationFrame(() => {
          map.panTo(lookaheadPoint);
          map.setZoom(zoom);
          if (!isHeadingTweening) {
            map.setHeading(heading);
            userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
          }
          map.setTilt(tilt);
          isProgrammaticUpdate = false;
          updateCompass();
          console.log('Map updated during navigation:', { center: lookaheadPoint, zoom, heading, tilt });
        });
        updateNavigationHUD();
        checkArrival();
      }
      if (now - lastAlertFetchTime >= ALERT_FETCH_INTERVAL) {
        lastAlertFetchTime = now;
        fetchAndDisplayMarkers(map, navState.userLocation);
      }
      checkAlertVerification();
    }
    async function snapToRoad(position) {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) return null;
      const path = google.maps.geometry.encoding.decodePath(navState.currentRoute.routes[0].overview_polyline);
      let closestPoint = null;
      let minDistance = Infinity;
      path.forEach(point => {
        const distance = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(position.lat, position.lng),
          point
        );
        if (distance < minDistance && distance <= SNAP_BUFFER) {
          minDistance = distance;
          closestPoint = { lat: point.lat(), lng: point.lng() };
        }
      });
      if (closestPoint) {
        console.log('Snapped to road:', { original: position, snapped: closestPoint, distance: minDistance });
        return closestPoint;
      }
      const rawDistance = google.maps.geometry.spherical.computeDistanceBetween(
        new google.maps.LatLng(position.lat, position.lng),
        new google.maps.LatLng(navState.previousUserLocation?.lat || position.lat, navState.previousUserLocation?.lng || position.lng)
      );
      if (rawDistance > MAX_GPS_DISTANCE) {
        console.warn('Position jump too large, ignoring:', { rawDistance, position });
        return null;
      }
      console.log('No road snap within buffer, using raw position:', position);
      return null;
    }
    function updateNavigationHUD() {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) return;
      const route = navState.currentRoute.routes[0];
      const leg = route.legs[0];
      const step = getCurrentStep(leg);
      if (!step) return;
      const maneuver = step.maneuver || 'Follow the road';
      const street = step.end_location ? getStreetName(step) : 'Unknown';
      const distance = step.distance ? step.distance.text : 'Unknown';
      const duration = step.duration ? step.duration.text : 'Unknown';
      document.getElementById('hud-turn').textContent = maneuver.charAt(0).toUpperCase() + maneuver.slice(1);
      document.getElementById('hud-street').textContent = `Current street: ${street}`;
      document.getElementById('hud-heading').textContent = `Heading: ${Math.round(navState.currentHeading)}°`;
      document.getElementById('bottom-hud-time').textContent = duration;
      document.getElementById('bottom-hud-distance').textContent = `${distance} - ${leg.end_address || 'Unknown'}`;
      if (voiceAssistantEnabled && maneuver !== lastSpokenTurn && Date.now() - lastAnnouncementTime > ANNOUNCEMENT_COOLDOWN) {
        const utterance = new SpeechSynthesisUtterance(`${maneuver} in ${distance}`);
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
        lastSpokenTurn = maneuver;
        lastAnnouncementTime = Date.now();
        console.log('Announced navigation instruction:', { maneuver, distance });
      }
      console.log('Navigation HUD updated:', { maneuver, street, heading: navState.currentHeading, distance, duration });
    }
    function getCurrentStep(leg) {
      let totalDistance = 0;
      for (let i = 0; i < leg.steps.length; i++) {
        totalDistance += leg.steps[i].distance.value;
        const distanceToStep = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(navState.userLocation.lat, navState.userLocation.lng),
          leg.steps[i].end_location
        );
        if (distanceToStep < TURN_THRESHOLD) {
          return leg.steps[i];
        }
      }
      return leg.steps[0];
    }
    function getStreetName(step) {
      if (step.instructions) {
        const div = document.createElement('div');
        div.innerHTML = step.instructions;
        return div.textContent.split('onto ')[1]?.split(' ')[0] || 'Unknown';
      }
      return 'Unknown';
    }
    function startHazardCheck() {
      if (navState.hazardCheckInterval) clearInterval(navState.hazardCheckInterval);
      navState.hazardCheckInterval = setInterval(checkHazardsOnRoute, REROUTE_CHECK_INTERVAL);
      console.log('Started hazard check interval');
    }
    async function checkHazardsOnRoute() {
      if (!navState.isNavigating || !navState.currentRoute || navState.alertState === 'OFFERING_REROUTE') return;
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        const path = google.maps.geometry.encoding.decodePath(navState.currentRoute.routes[0].overview_polyline);
        const response = await fetchWithRetry('/api/hazards-near-route', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token.trim()}`
          },
          body: JSON.stringify({ polyline: path.map(p => ({ lat: p.lat(), lng: p.lng() })) })
        });
        console.log('Hazards check response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error('Failed to check hazards');
        const hazards = await response.json();
        console.log('Hazards found:', hazards.length);
        let nearestHazard = null;
        let minDistance = Infinity;
        hazards.forEach(hazard => {
          if (navState.ignoredHazards.includes(hazard._id)) return;
          if (navState.alertFilters[hazard.type.toLowerCase()] === false) return;
          const hazardPos = new google.maps.LatLng(hazard.location.coordinates[1], hazard.location.coordinates[0]);
          const distance = google.maps.geometry.spherical.computeDistanceBetween(
            new google.maps.LatLng(navState.userLocation.lat, navState.userLocation.lng),
            hazardPos
          );
          if (distance < minDistance && distance <= hazardAlertDistance * 1609.34) {
            minDistance = distance;
            nearestHazard = hazard;
          }
        });
        if (nearestHazard && nearestHazard._id !== navState.currentHazard) {
          navState.currentHazard = nearestHazard._id;
          offerReroute(nearestHazard);
          console.log('Offering reroute for hazard:', nearestHazard);
        }
      } catch (error) {
        console.error('Error checking hazards:', error);
      }
    }
    function offerReroute(hazard) {
      navState.alertState = 'OFFERING_REROUTE';
      const rerouteHud = document.getElementById('reroute-hud-container');
      document.getElementById('hazard-message').textContent = `A ${hazard.type} is ahead at ${hazard.address || 'unknown location'}. Reroute?`;
      rerouteHud.classList.add('active');
      console.log('Reroute offered for:', hazard);
      calculateAlternativeRoute(hazard);
    }
    async function calculateAlternativeRoute(hazard) {
      if (!navState.currentRoute || !navState.destination) return;
      try {
        const avoidPoint = new google.maps.LatLng(hazard.location.coordinates[1], hazard.location.coordinates[0]);
        const waypoints = [
          {
            location: avoidPoint,
            stopover: false,
            avoid: true
          }
        ];
        const request = {
          origin: navState.userLocation,
          destination: navState.destination,
          travelMode: 'DRIVING',
          provideRouteAlternatives: true,
          avoidTolls: navState.avoidTolls,
          avoidHighways: navState.avoidHighways,
          waypoints: navState.waypoints.length > 0 ? navState.waypoints : waypoints
        };
        console.log('Calculating alternative route:', request);
        const response = await directionsService.route(request);
        if (response.status === 'OK' && response.routes.length > 1) {
          navState.alternativeRoute = response;
          alternativeRenderer.setDirections(response);
          alternativeRenderer.setRouteIndex(1);
          alternativeRenderer.setMap(map);
          console.log('Alternative route calculated and displayed:', response.routes[1]);
        } else {
          console.warn('No alternative route found:', response.status);
          showToast('No alternative route available.');
          rejectReroute();
        }
      } catch (error) {
        console.error('Error calculating alternative route:', error);
        showToast('Failed to calculate alternative route.');
        rejectReroute();
      }
    }
    function acceptReroute() {
      if (navState.alternativeRoute) {
        navState.currentRoute = navState.alternativeRoute;
        directionsRenderer.setDirections(navState.currentRoute);
        directionsRenderer.setRouteIndex(1);
        directionsRenderer.setMap(map);
        alternativeRenderer.setMap(null);
        navState.alternativeRoute = null;
        navState.ignoredHazards.push(navState.currentHazard);
        navState.currentHazard = null;
        navState.alertState = 'IDLE';
        document.getElementById('reroute-hud-container').classList.remove('active');
        lockNavigation();
        updateNavigationHUD();
        console.log('Reroute accepted, new route set');
      }
    }
    function rejectReroute() {
      if (navState.alternativeRoute) {
        alternativeRenderer.setMap(null);
        navState.alternativeRoute = null;
      }
      navState.ignoredHazards.push(navState.currentHazard);
      navState.currentHazard = null;
      navState.alertState = 'IDLE';
      document.getElementById('reroute-hud-container').classList.remove('active');
      lockNavigation();
      console.log('Reroute rejected');
    }
    function checkArrival() {
      if (!navState.destination || navState.hasArrived) return;
      const distance = google.maps.geometry.spherical.computeDistanceBetween(
        new google.maps.LatLng(navState.userLocation.lat, navState.userLocation.lng),
        new google.maps.LatLng(navState.destination.lat, navState.destination.lng)
      );
      if (distance < ARRIVAL_RADIUS) {
        navState.hasArrived = true;
        document.getElementById('arrival-hud-container').classList.add('active');
        if (voiceAssistantEnabled) {
          const utterance = new SpeechSynthesisUtterance('You have arrived at your destination.');
          utterance.lang = 'en-US';
          speechSynthesis.speak(utterance);
        }
        console.log('Arrival detected:', { distance });
      }
    }
    function startCameraCheck() {
      if (cameraCheckInterval) clearInterval(cameraCheckInterval);
      cameraCheckInterval = setInterval(checkTrafficCameras, CAMERA_CHECK_INTERVAL);
      console.log('Started traffic camera check interval');
    }
    function checkTrafficCameras() {
      if (!showTrafficCameras || !navState.isNavigating) return;
      cameraPositions.forEach((camera, index) => {
        if (cameraAlertShown.has(index)) return;
        const distance = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(navState.userLocation.lat, navState.userLocation.lng),
          new google.maps.LatLng(camera.lat, camera.lng)
        );
        if (distance <= cameraAlertDistance * 1609.34) {
          cameraAlertShown.add(index);
          document.getElementById('camera-hud-container').classList.add('active');
          if (voiceAssistantEnabled) {
            const utterance = new SpeechSynthesisUtterance('Traffic camera ahead. Drive safely.');
            utterance.lang = 'en-US';
            speechSynthesis.speak(utterance);
          }
          console.log('Traffic camera alert shown:', { index, distance });
          setTimeout(() => {
            cameraAlertShown.delete(index);
            console.log('Camera alert reset for:', index);
          }, 60000);
        }
      });
    }
    function startAlertPolling() {
      if (alertPollInterval) clearInterval(alertPollInterval);
      alertPollInterval = setInterval(() => {
        fetchAndDisplayMarkers(map, navState.userLocation);
      }, ALERT_POLL_INTERVAL);
      console.log('Started alert polling interval');
    }
    function checkAlertVerification() {
      currentAlerts.forEach(alert => {
        if (alert.type === 'Traffic Camera' || navState.alertFilters[alert.type.toLowerCase()] === false) return;
        const alertPos = new google.maps.LatLng(alert.location.coordinates[1], alert.location.coordinates[0]);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(navState.userLocation.lat, navState.userLocation.lng),
          alertPos
        );
        if (distance < VERIFICATION_DISTANCE && !navState.alertProximities.has(alert._id)) {
          navState.alertProximities.set(alert._id, true);
          currentVerificationAlertId = alert._id;
          document.getElementById('verification-message').textContent = `You have passed a ${alert.type} alert. Is it still valid?`;
          document.getElementById('verification-hud-container').classList.add('active');
          console.log('Verification HUD shown for alert:', { id: alert._id, type: alert.type, distance });
        }
      });
    }
    async function calculateAndDisplayRoute(start, end, callback) {
      const request = {
        origin: start,
        destination: end,
        travelMode: 'DRIVING',
        provideRouteAlternatives: true,
        avoidTolls: navState.avoidTolls,
        avoidHighways: navState.avoidHighways,
        waypoints: navState.waypoints
      };
      console.log('Calculating route:', request);
      try {
        const response = await directionsService.route(request);
        if (response.status === 'OK') {
          navState.currentRoute = response;
          navState.originalRoute = response;
          directionsRenderer.setDirections(response);
          directionsRenderer.setMap(map);
          routePolyline = new google.maps.Polyline({
            path: google.maps.geometry.encoding.decodePath(response.routes[0].overview_polyline),
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            map: map,
            zIndex: 5
          });
          console.log('Route calculated and displayed:', response.routes[0].summary);
          if (callback) callback();
        } else {
          console.error('Directions request failed:', response.status);
          showToast('Failed to calculate route.');
        }
      } catch (error) {
        console.error('Error calculating route:', error);
        showToast('Failed to calculate route.');
      }
    }
    function startPositionSimulation() {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) {
        showToast('No route to simulate.');
        return;
      }
      const path = google.maps.geometry.encoding.decodePath(navState.currentRoute.routes[0].overview_polyline);
      let index = 0;
      mockSimulationInterval = setInterval(() => {
        if (index >= path.length) {
          clearInterval(mockSimulationInterval);
          mockSimulationInterval = null;
          document.getElementById('simulate-position-button').textContent = 'Simulate';
          showToast('Simulation completed.');
          stopGPS();
          return;
        }
        const pos = { lat: path[index].lat(), lng: path[index].lng() };
        const nextPos = index < path.length - 1 ? path[index + 1] : pos;
        const heading = google.maps.geometry.spherical.computeHeading(pos, nextPos);
        onPositionUpdate({
          coords: {
            latitude: pos.lat,
            longitude: pos.lng,
            heading: heading,
            speed: 13.4112
          }
        });
        index++;
      }, 1000);
      console.log('Started position simulation along route');
    }
    function toggleAccordion(header) {
      const content = header.nextElementSibling;
      const isActive = header.classList.contains('active');
      document.querySelectorAll('.accordion-header').forEach(h => {
        h.classList.remove('active');
        h.nextElementSibling.classList.remove('active');
      });
      if (!isActive) {
        header.classList.add('active');
        content.classList.add('active');
      }
      console.log('Accordion toggled:', { section: header.textContent, active: !isActive });
    }
    async function fetchUsers(query) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching users with query:', query);
        const response = await fetchWithRetry(`/api/users${query ? `?query=${encodeURIComponent(query)}` : ''}`, {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Users fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error('Failed to fetch users');
        const users = await response.json();
        displayUsers(users);
      } catch (error) {
        console.error('Error fetching users:', error);
        showToast('Failed to load users.');
      }
    }
    async function loadAllUsers() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching all users');
        const response = await fetchWithRetry('/api/users', {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('All users fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error('Failed to fetch users');
        const users = await response.json();
        displayUsers(users);
      } catch (error) {
        console.error('Error fetching all users:', error);
        showToast('Failed to load users.');
      }
    }
    function displayUsers(users) {
      const usersList = document.getElementById('users-list');
      usersList.innerHTML = `
        <table>
          <tr>
            <th>Username</th>
            <th>Email</th>
            <th>Join Date</th>
            <th>Points</th>
            <th>Admin</th>
            <th>Last Location</th>
            <th>Last Active</th>
            <th>Actions</th>
          </tr>
        </table>
      `;
      const table = usersList.querySelector('table');
      users.forEach(user => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${user.username}</td>
          <td>${user.email}</td>
          <td>${new Date(user.joinDate).toLocaleDateString()}</td>
          <td>${user.points}</td>
          <td>${user.isAdmin ? 'Yes' : 'No'}</td>
          <td>${user.lastLocation ? `${user.lastLocation.coordinates[1].toFixed(4)}, ${user.lastLocation.coordinates[0].toFixed(4)}` : 'N/A'}</td>
          <td>${user.lastActive ? new Date(user.lastActive).toLocaleString() : 'N/A'}</td>
          <td>
            <button class="view-activity-btn" onclick="loadUserActivity('${user._id}')">View Activity</button>
            ${user.isAdmin ? `<button class="demote-btn" onclick="demoteUser('${user._id}')">Demote</button>` : `<button class="promote-btn" onclick="promoteUser('${user._id}')">Promote</button>`}
            <button class="ban-btn" onclick="banUser('${user._id}')">Ban</button>
            <button class="ipban-btn" onclick="ipBanUser('${user._id}')">IP Ban</button>
            <button class="delete-btn" onclick="deleteUser('${user._id}')">Delete</button>
          </td>
        `;
        table.appendChild(row);
      });
      console.log('Users displayed:', users.length);
      document.getElementById('admin-hud-container').classList.add('active');
      document.getElementById('users').style.display = 'block';
      document.getElementById('admin-tabs').querySelector('[data-tab="users"]').classList.add('active');
      document.getElementById('admin-tabs').querySelector('[data-tab="activity"]').classList.remove('active');
      document.getElementById('activity').style.display = 'none';
    }
    async function promoteUser(userId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Promoting user:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/promote`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Promote user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User promoted to admin.');
          fetchUsers(document.getElementById('user-search').value);
        } else {
          const data = await response.json();
          console.error('Failed to promote user:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to promote user.');
        }
      } catch (error) {
        console.error('Error promoting user:', error);
        showToast('Failed to promote user.');
      }
    }
    async function demoteUser(userId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Demoting user:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/demote`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Demote user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User demoted from admin.');
          fetchUsers(document.getElementById('user-search').value);
        } else {
          const data = await response.json();
          console.error('Failed to demote user:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to demote user.');
        }
      } catch (error) {
        console.error('Error demoting user:', error);
        showToast('Failed to demote user.');
      }
    }
    async function banUser(userId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Banning user:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/ban`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Ban user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User banned.');
          fetchUsers(document.getElementById('user-search').value);
        } else {
          const data = await response.json();
          console.error('Failed to ban user:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to ban user.');
        }
      } catch (error) {
        console.error('Error banning user:', error);
        showToast('Failed to ban user.');
      }
    }
    async function ipBanUser(userId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('IP banning user:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/ipban`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('IP ban user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User IP banned.');
          fetchUsers(document.getElementById('user-search').value);
        } else {
          const data = await response.json();
          console.error('Failed to IP ban user:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to IP ban user.');
        }
      } catch (error) {
        console.error('Error IP banning user:', error);
        showToast('Failed to IP ban user.');
      }
    }
    async function deleteUser(userId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Deleting user:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Delete user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User deleted.');
          fetchUsers(document.getElementById('user-search').value);
        } else {
          const data = await response.json();
          console.error('Failed to delete user:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to delete user.');
        }
      } catch (error) {
        console.error('Error deleting user:', error);
        showToast('Failed to delete user.');
      }
    }
    async function loadUserActivity(userId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        selectedUserId = userId;
        console.log('Loading activity for user:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/activity`, {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('User activity fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error('Failed to load user activity');
        const activity = await response.json();
        const activityList = document.getElementById('user-activity-list');
        activityList.innerHTML = '';
        if (activity.length === 0) {
          activityList.innerHTML = '<li class="no-activity">No activity recorded</li>';
        } else {
          activity.forEach(item => {
            const li = document.createElement('li');
            li.innerHTML = `<strong>${item.type}:</strong> ${item.description} at ${new Date(item.timestamp).toLocaleString()}`;
            activityList.appendChild(li);
          });
        }
        document.getElementById('admin-hud-container').classList.add('active');
        document.getElementById('activity').style.display = 'block';
        document.getElementById('admin-tabs').querySelector('[data-tab="activity"]').classList.add('active');
        document.getElementById('admin-tabs').querySelector('[data-tab="users"]').classList.remove('active');
        document.getElementById('users').style.display = 'none';
        console.log('User activity loaded:', activity.length);
      } catch (error) {
        console.error('Error loading user activity:', error);
        showToast('Failed to load user activity.');
      }
    }
    async function fetchUserForActivity(query) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching user for activity:', query);
        const response = await fetchWithRetry(`/api/users/search?query=${encodeURIComponent(query)}`, {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('User search for activity response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error('Failed to find user');
        const users = await response.json();
        if (users.length > 0) {
          loadUserActivity(users[0]._id);
        } else {
          showToast('No user found for activity.');
        }
      } catch (error) {
        console.error('Error fetching user for activity:', error);
        showToast('Failed to find user for activity.');
      }
    }
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('visible-toast');
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => {
        toast.classList.remove('visible-toast');
      }, 3000);
      console.log('Toast displayed:', message);
    }
    function initApp() {
      console.log('Initializing app...');
      const token = localStorage.getItem('token') || sessionStorage.getItem('token');
      const userId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
      if (!token || !userId || !token.includes('.') || token === 'undefined') {
        console.log('No valid token or userId, showing auth form');
        localStorage.removeItem('token');
        localStorage.removeItem('userId');
        sessionStorage.removeItem('token');
        sessionStorage.removeItem('userId');
        document.getElementById('auth-container').style.display = 'flex';
        return;
      }
      console.log('App initializing with token:', token.substring(0, 20) + '...', 'userId:', userId);
      socket = io({
        auth: { token }
      });
      socket.on('connect', () => {
        console.log('Socket.IO connected, joining user room:', userId);
        socket.emit('join', userId);
      });
      socket.on('connect_error', (error) => {
        console.error('Socket.IO connection error:', error);
        showToast('Connection error. Retrying...');
      });
      socket.on('alert', (alert) => {
        console.log('Received new alert via Socket.IO:', alert);
        if (navState.alertFilters[alert.type.toLowerCase()] === false) return;
        if (alert.type === 'Traffic Camera' && !showTrafficCameras) return;
        currentAlerts.push(alert);
        const isTrafficCamera = alert.type === 'Traffic Camera';
        const content = isPremium && alert.type === 'Police' ? createSpeedTrapIcon() : isTrafficCamera ? createTrafficCameraContent() : createAlertContent();
        const marker = new google.maps.marker.AdvancedMarkerElement({
          map: map,
          position: { lat: alert.location.coordinates[1], lng: alert.location.coordinates[0] },
          content,
          title: `${alert.type} Alert`
        });
        marker.addListener('click', () => showAlertDetails(alert));
        markers.set(alert._id, marker);
        console.log('Added real-time alert marker:', alert._id);
        if (pushNotificationsEnabled) {
          const distance = google.maps.geometry.spherical.computeDistanceBetween(
            new google.maps.LatLng(navState.userLocation.lat, navState.userLocation.lng),
            new google.maps.LatLng(alert.location.coordinates[1], alert.location.coordinates[0])
          );
          if (distance <= navState.alertRadius * 1609.34) {
            new Notification(`${alert.type} Alert Nearby`, {
              body: `A ${alert.type} was reported at ${alert.address || 'unknown location'}.`,
              icon: '/icon.png'
            });
            console.log('Push notification sent for alert:', alert._id);
          }
        }
      });
      socket.on('familyAlert', (data) => {
        console.log('Received family alert:', data);
        const alert = data.alert;
        if (navState.alertFilters[alert.type.toLowerCase()] === false) return;
        if (alert.type === 'Traffic Camera' && !showTrafficCameras) return;
        showToast(`Family member ${data.user.username} posted a ${alert.type} alert at ${alert.address || 'unknown location'}`);
      });
      socket.on('alertDeleted', (alertId) => {
        console.log('Alert deleted via Socket.IO:', alertId);
        if (markers.has(alertId)) {
          markers.get(alertId).setMap(null);
          markers.delete(alertId);
          currentAlerts = currentAlerts.filter(a => a._id !== alertId);
          console.log('Removed deleted alert marker:', alertId);
        }
      });
      socket.on('extendAlert', (alertId) => {
        console.log('Alert extended via Socket.IO:', alertId);
        const alert = currentAlerts.find(a => a._id === alertId);
        if (alert) {
          alert.expiry = new Date(Date.now() + 3600000);
          console.log('Extended alert expiry:', { alertId, newExpiry: alert.expiry });
        }
      });
      socket.on('locationUpdate', ({ userId, location }) => {
        console.log('Received location update:', { userId, location });
        if (trackingUsers.includes(userId)) {
          if (trackedMarkers.has(userId)) {
            trackedMarkers.get(userId).position = location;
          } else {
            const markerElement = document.createElement('div');
            markerElement.style.width = '15px';
            markerElement.style.height = '15px';
            markerElement.style.backgroundColor = 'purple';
            markerElement.style.borderRadius = '50%';
            markerElement.style.border = '2px solid white';
            const marker = new google.maps.marker.AdvancedMarkerElement({
              map: map,
              position: location,
              content: markerElement,
              title: `User ${userId}`
            });
            trackedMarkers.set(userId, marker);
          }
          console.log('Updated tracked user marker:', { userId, location });
        }
      });
      socket.on('userBanned', ({ userId }) => {
        console.log('User banned via Socket.IO:', userId);
        const ownId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
        if (userId === ownId) {
          showToast('Your account has been banned.');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          socket.disconnect();
        }
      });
      if (navigator.serviceWorker) {
        navigator.serviceWorker.register('/sw.js').then(reg => {
          console.log('Service Worker registered:', reg);
          if (pushNotificationsEnabled) {
            requestPushPermission();
          }
        }).catch(err => {
          console.error('Service Worker registration failed:', err);
        });
      }
      loadGoogleMaps();
      fetchSubscriptionStatus();
      console.log('App initialization complete');
    }
    async function fetchCurrentAlerts() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching current alerts');
        const response = await fetchWithRetry(`/api/markers?lat=${navState.userLocation.lat}&lng=${navState.userLocation.lng}&maxDistance=${navState.alertRadius * 1609.34}`, {
          headers: { 'Authorization': `Bearer ${token.trim()}` }
        });
        console.log('Current alerts fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error('Failed to fetch current alerts');
        const alerts = await response.json();
        currentAlerts = alerts;
        const content = document.getElementById('information');
        content.innerHTML = '';
        alerts.forEach(alert => {
          if (alert.type === 'Traffic Camera' && !showTrafficCameras) return;
          if (navState.alertFilters[alert.type.toLowerCase()] === false) return;
          const item = document.createElement('div');
          item.className = 'alert-item';
          item.innerHTML = `
            <div class="alert-field"><strong>Type:</strong> ${alert.type}</div>
            <div class="alert-field"><strong>Location:</strong> ${alert.address || 'Unknown'}</div>
            <div class="alert-field"><strong>Posted:</strong> ${new Date(alert.timestamp).toLocaleString()}</div>
            <div class="alert-field"><strong>Expires:</strong> ${new Date(alert.expiry).toLocaleString()}</div>
            <div class="alert-field"><strong>Posted by:</strong> <a href="#" onclick="viewUserProfile('${alert.userId._id}')">${alert.userId.username}</a></div>
            <div class="alert-votes">
              <button class="vote-btn upvote-btn" onclick="voteOnAlert('${alert._id}', 'up')">Upvote (${alert.votes.up})</button>
              <button class="vote-btn downvote-btn" onclick="voteOnAlert('${alert._id}', 'down')">Downvote (${alert.votes.down})</button>
            </div>
            <div class="alert-actions">
              <button class="center-btn" onclick="centerOnAlert(${alert.location.coordinates[1]}, ${alert.location.coordinates[0]})">Center</button>
              <button class="delete-btn" onclick="deleteAlert('${alert._id}')">Delete</button>
            </div>
          `;
          content.appendChild(item);
        });
        console.log('Current alerts displayed:', alerts.length);
      } catch (error) {
        console.error('Error fetching current alerts:', error);
        showToast('Failed to load current alerts.');
      }
    }
    document.getElementById('center-alerts-btn').addEventListener('click', () => {
      if (currentAlerts.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        currentAlerts.forEach(alert => {
          if (alert.type === 'Traffic Camera' && !showTrafficCameras) return;
          if (navState.alertFilters[alert.type.toLowerCase()] === false) return;
          bounds.extend({ lat: alert.location.coordinates[1], lng: alert.location.coordinates[0] });
        });
        map.fitBounds(bounds);
        console.log('Centered map on current alerts');
      } else {
        showToast('No alerts to center on.');
      }
    });
    document.getElementById('edit-profile-button').addEventListener('click', () => {
      document.getElementById('edit-profile-form').style.display = 'block';
      document.getElementById('edit-profile-button').style.display = 'none';
      console.log('Edit profile form shown');
    });
    document.getElementById('cancel-edit').addEventListener('click', () => {
      document.getElementById('edit-profile-form').style.display = 'none';
      document.getElementById('edit-profile-button').style.display = 'block';
      console.log('Edit profile form cancelled');
    });
    document.getElementById('save-profile').addEventListener('click', async () => {
      const username = document.getElementById('edit-username').value.trim();
      const email = document.getElementById('edit-email').value.trim();
      const password = document.getElementById('edit-password').value.trim();
      if (!username || !email) {
        showToast('Username and email are required.');
        return;
      }
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || !token.includes('.') || token === 'undefined') {
          console.error('Invalid token, showing auth form');
          localStorage.removeItem('token');
          localStorage.removeItem('userId');
          sessionStorage.removeItem('token');
          sessionStorage.removeItem('userId');
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Saving profile:', { username, email, hasPassword: !!password });
        const body = { username, email };
        if (password) body.password = password;
        const response = await fetchWithRetry('/api/auth/profile', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token.trim()}`
          },
          body: JSON.stringify(body)
        });
        console.log('Profile save response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('Profile updated successfully.');
          document.getElementById('edit-profile-form').style.display = 'none';
          document.getElementById('edit-profile-button').style.display = 'block';
          const data = await response.json();
          populateAccountProfile(data);
        } else {
          const data = await response.json();
          console.error('Failed to update profile:', data.error || 'Unknown error');
          showToast(data.error || 'Failed to update profile.');
        }
      } catch (error) {
        console.error('Error updating profile:', error);
        showToast('Failed to update profile.');
      }
    });
    initApp();
  </script>
</body>
</html>