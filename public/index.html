<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Waze-Like GPS App</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css?v=1.0.3">
  <link rel="manifest" href="/manifest.json?v=1.0.3">
  <script src="https://unpkg.com/@tweenjs/tween.js@23.1.3/dist/tween.umd.js?v=1.0.3"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js?v=1.0.3"></script>
  <script src="https://browser.sentry-cdn.com/7.x.x/bundle.min.js"></script>
  <script>
    // Only initialize Sentry if it's loaded AND not localhost
    if (typeof Sentry !== 'undefined' && window.location.hostname !== 'localhost') {
      Sentry.init({
        dsn: 'YOUR_SENTRY_DSN',
        environment: 'production',
        tracesSampleRate: 0.1,
        beforeSend(event, hint) {
          // Filter sensitive data
          if (event.request) {
            delete event.request.cookies;
            delete event.request.headers['Authorization'];
          }
          // Don't send localStorage/sessionStorage
          if (event.contexts?.state) {
            delete event.contexts.state.localStorage;
          }
          return event;
        }
      });
    }
  </script>
  <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').then(reg => {
    // Check for updates every 5 minutes
    setInterval(() => reg.update(), 5 * 60 * 1000);
    // Listen for new SW waiting
    reg.addEventListener('updatefound', () => {
      const newWorker = reg.installing;
      newWorker.addEventListener('statechange', () => {
        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
          // New SW ready - prompt user or auto-reload
          if (confirm('New version available! Reload to update?')) {
            newWorker.postMessage({ type: 'SKIP_WAITING' });
            window.location.reload();
          }
        }
      });
    });
  });
}
</script>
  <style>
    * { box-sizing: border-box; }
    body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: Arial, sans-serif; }
    #map {
      height: 100vh;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      overflow: visible;
      background: #f0f0f0;
    }
    #compass {
      position: absolute; top: 10vh; right: 2vw; width: 40px; height: 40px; z-index: 1001;
      background: url('https://i.postimg.cc/YS0h0m7R/compass.png') no-repeat center center;
      background-size: contain; transition: transform 0.3s ease;
    }
    #search-container {
      position: absolute; top: 0.5vh; left: 50%; transform: translateX(-50%); width: 80%; max-width: 90vw; z-index: 1002;
      display: flex; align-items: center; background: white; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2);
      padding: 0.5rem; border: 1px solid #ccc;
    }
    #search-input {
      flex: 1; padding: 0.5rem; border: none; font-size: 1rem; outline: none; background: transparent; width: 100%;
    }
    #search-input::placeholder { color: #888; }
    #start-button, #simulate-position-button {
      background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.4rem;
      cursor: pointer; margin-left: 0.5rem; font-size: 1rem;
    }
    #simulate-position-button { background: #FF9800; }
    #start-button:hover, #simulate-position-button:hover { background: #45a049; }
    .hidden { display: none !important; }
    .pac-container {
      z-index: 1003; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); background: white;
      font-family: Arial, sans-serif; font-size: 1rem; width: 80% !important; max-width: 90vw; margin-top: 0.5rem;
    }
    .pac-item { padding: 0.5rem; cursor: pointer; color: #333; }
    .pac-item:hover { background: #f0f0f0; }
    #hud-container {
      position: absolute; top: 2vh; left: 50%; transform: translateX(-50%); width: 80%; max-width: 95vw; z-index: 1001;
      background: white; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); padding: 1vh;
      border: 1px solid #ccc; display: none; flex-direction: column; gap: 0.5vh;
    }
    #hud-turn { font-size: 1.2rem; font-weight: bold; color: #333; }
    #hud-street, #hud-heading { font-size: 0.9rem; color: #555; }
    #bottom-hud-container {
      position: absolute; bottom: 2vh; left: 50%; transform: translateX(-50%); width: 80%; max-width: 90vw; z-index: 1001;
      background: white; border-radius: 0.5rem; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); padding: 1vh;
      border: 1px solid #ccc; display: none; align-items: center; gap: 1vw;
    }
    #bottom-hud-stop {
      background: #d32f2f; color: white; border: none; padding: 0.5rem 0.8rem; border-radius: 0.4rem;
      cursor: pointer; font-size: 1rem; font-weight: bold;
    }
    #bottom-hud-stop:hover { background: #b71c1c; }
    #bottom-hud-info { flex: 1; text-align: center; }
    #bottom-hud-time { font-size: 1.2rem; font-weight: bold; color: #333; }
    #bottom-hud-distance { font-size: 0.9rem; color: #555; }
    #button-container {
      position: fixed; top: 50%; right: 2vw; transform: translateY(-50%); display: flex; flex-direction: column;
      gap: 1.2vh; padding: 1.5vmin; background: rgba(0, 0, 0, 0.3); border-radius: 0.5rem; z-index: 1001; box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.3);
    }
    #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
      width: 5vw; height: 5vw; max-width: 40px; max-height: 40px; border: 0.1rem solid #fff; border-radius: 50%;
      box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; cursor: pointer;
    }
    #hazard-button { background: #ff4444; }
    #hazard-button::before { content: '+'; color: #00ff00; font-size: 1.2rem; font-weight: bold; }
    #hazard-button:hover { background: #cc0000; }
    #recenter-button { background: #4CAF50; }
    #recenter-button::before { content: 'â†»'; color: #fff; font-size: 1.2rem; font-weight: bold; }
    #recenter-button:hover { background: #45a049; }
    #voice-button { background: #FF5722; }
    #voice-button::before { content: '\f130'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #voice-button:hover { background: #E64A19; }
    #share-button { background: #2196F3; }
    #share-button::before { content: '\f1e0'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #share-button:hover { background: #1976D2; }
    #settings-button { background: #2196F3; }
    #settings-button::before { content: '\f013'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #settings-button:hover { background: #1976D2; }
    #current-alerts-button { background: #FF9800; }
    #current-alerts-button::before { content: '\f071'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #current-alerts-button:hover { background: #F57C00; }
    #leaderboard-button { background: #FFC107; }
    #leaderboard-button::before { content: '\f091'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #leaderboard-button:hover { background: #FFA000; }
    #admin-button { background: #9C27B0; display: none; }
    #admin-button::before { content: '\f085'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #fff; font-size: 1.2rem; }
    #admin-button:hover { background: #7B1FA2; }
    .report-container {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 1000;
    }
    #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) translateY(100%); width: 80vw;
      max-width: 300px; background: rgba(0, 0, 0, 0.7); border-radius: 0.5rem; padding: 1vmin; pointer-events: auto;
      display: none; flex-direction: column; transition: transform 0.3s ease; transform-origin: center; visibility: visible;
      overflow-y: auto; max-height: 80vh; color: white;
    }
    #admin-hud-container {
      max-width: 90vw;
      max-height: 90vh;
      width: 90vw;
    }
    #report-box.active, #reroute-hud-container.active, #settings-hud-container.active, #alerts-hud-container.active, #camera-hud-container.active, #leaderboard-hud-container.active, #arrival-hud-container.active, #admin-hud-container.active, #verification-hud-container.active, #user-profile-hud-container.active {
      display: flex; transform: translate(-50%, -50%); visibility: visible;
    }
    #report-box::before, #reroute-hud-container::before, #settings-hud-container::before, #alerts-hud-container::before, #camera-hud-container::before, #leaderboard-hud-container::before, #arrival-hud-container::before, #admin-hud-container::before, #verification-hud-container::before, #user-profile-hud-container::before {
      content: ''; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.3);
      z-index: -1; display: none;
    }
    #report-box.active::before, #reroute-hud-container.active::before, #settings-hud-container.active::before, #alerts-hud-container.active::before, #camera-hud-container.active::before, #leaderboard-hud-container.active::before, #arrival-hud-container.active::before, #admin-hud-container.active::before, #verification-hud-container.active::before, #user-profile-hud-container.active::before {
      display: block;
    }
    #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
      width: 100%; padding: 1vmin 0; position: relative; margin-bottom: 1vmin;
    }
    #report-close, #reroute-close, #settings-close, #alerts-close, #camera-close, #leaderboard-close, #arrival-close, #admin-close, #verification-close, #user-profile-close {
      position: absolute; top: 0.5vmin; right: 0.5vmin; background: #d32f2f; color: white; border: none;
      padding: 0.5vmin 1vmin; border-radius: 0.4rem; cursor: pointer; font-size: clamp(12px, 2.5vmin, 16px);
      font-weight: bold; z-index: 1;
    }
    #report-close:hover, #reroute-close:hover, #settings-close:hover, #alerts-close:hover, #camera-close:hover, #leaderboard-close:hover, #arrival-close:hover, #admin-close:hover, #verification-close:hover, #user-profile-close:hover {
      background: #b71c1c;
    }
    .report-options {
      flex: 1; display: grid; grid-template-columns: repeat(2, 1fr); gap: 1vmin; padding: 0.5vmin 0;
      padding-top: 2vmin; position: relative; width: 100%; height: 100%; overflow: hidden;
    }
    .report-button {
      background: rgba(255, 255, 255, 0.2); border: none; border-radius: 0.3rem; padding: 1vmin;
      text-align: center; cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
      display: flex; flex-direction: column; align-items: center; transition: background 0.2s;
      position: relative; width: 100%; height: 100%; vertical-align: middle; grid-column: auto; grid-row: auto;
    }
    .report-button:hover { background: rgba(255, 255, 255, 0.3); }
    .report-button i { font-size: clamp(12px, 2.5vmin, 16px); margin-bottom: 0.5vmin; }
    #confirm-alert {
      display: none; flex-direction: column; gap: 1vmin; padding: 1vmin; text-align: center;
    }
    #confirm-alert.active { display: flex; }
    #confirm-alert h3 { margin: 0; font-size: clamp(14px, 2.5vmin, 18px); color: white; }
    #confirm-alert p { margin: 0.5vmin 0; font-size: clamp(10px, 2vmin, 14px); color: white; }
    #post-alert-button, #cancel-alert-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #post-alert-button { background-color: #4CAF50; }
    #post-alert-button:hover { background-color: #45a049; }
    #cancel-alert-button { background-color: #d32f2f; }
    #cancel-alert-button:hover { background-color: #b71c1c; }
    #reroute-hud {
      display: none; flex-direction: column; gap: 1vmin; padding: 1vmin; text-align: center;
    }
    #reroute-hud.active { display: flex; }
    #reroute-hud h3 { margin: 0; font-size: clamp(14px, 2.5vmin, 18px); color: white; }
    #reroute-hud p { margin: 0.5vmin 0; font-size: clamp(10px, 2vmin, 14px); color: white; }
    #accept-reroute-button, #reject-reroute-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #accept-reroute-button { background-color: #4CAF50; }
    #accept-reroute-button:hover { background-color: #45a049; }
    #reject-reroute-button { background-color: #d32f2f; }
    #reject-reroute-button:hover { background-color: #b71c1c; }
    #settings-tabs, #alerts-tabs, #leaderboard-tabs, #admin-tabs {
      display: flex; border-bottom: 1px solid rgba(255, 255, 255, 0.3); margin-bottom: 1.5vmin;
    }
    .settings-tab, .alerts-tab, .leaderboard-tab, .admin-tab {
      flex: 1; padding: 0.5vmin; text-align: center; cursor: pointer; font-size: clamp(12px, 2.2vmin, 16px);
      color: rgba(255, 255, 255, 0.7); transition: color 0.2s, border-bottom 0.2s;
    }
    .settings-tab.active, .alerts-tab.active, .leaderboard-tab.active, .admin-tab.active {
      color: white; border-bottom: 2px solid #4CAF50;
    }
    .settings-tab:hover, .alerts-tab:hover, .leaderboard-tab:hover, .admin-tab:hover { color: white; }
    #settings-content {
      flex: 1; display: flex; flex-direction: column; gap: 1.5vmin; padding: 1.5vmin;
    }
    .settings-option {
      display: flex; justify-content: space-between; align-items: center; font-size: clamp(10px, 2vmin, 14px);
      padding-bottom: 1vmin; border-bottom: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .settings-option:last-child { border-bottom: none; }
    .settings-option label { color: white; font-weight: 600; }
    .settings-option select {
      padding: 0.5vmin; border-radius: 0.3rem; border: none; font-size: clamp(10px, 2vmin, 14px);
      background: #333; color: white; width: 50%; transition: background 0.2s;
    }
    .settings-option select:hover { background: #444; }
    .settings-option input[type="checkbox"] {
      appearance: none; width: 1.5rem; height: 1.5rem; background: #555; border-radius: 0.3rem;
      cursor: pointer; transition: background 0.2s;
    }
    .settings-option input[type="checkbox"]:checked {
      background: #333; position: relative;
    }
    .settings-option input[type="checkbox"]:checked::before {
      content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: #4CAF50;
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1rem;
    }
    .settings-option input[type="checkbox"]:hover { background: #666; }
    .settings-option input[type="range"] { width: 50%; cursor: pointer; }
    .settings-option .slider-value { font-size: clamp(10px, 2vmin, 14px); color: white; }
    #recalibrate-compass-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #4CAF50;
    }
    #recalibrate-compass-button:hover { background-color: #45a049; }
    #logout-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #d32f2f;
    }
    #logout-button:hover { background-color: #b71c1c; }
    #edit-profile-button {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #2196F3;
    }
    #edit-profile-button:hover { background-color: #1976D2; }
    #save-profile, #cancel-edit {
      margin: 0.5vmin 0.25vmin; padding: 0.5vmin 1vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #save-profile { background-color: #4CAF50; }
    #save-profile:hover { background-color: #45a049; }
    #cancel-edit { background-color: #d32f2f; }
    #cancel-edit:hover { background-color: #b71c1c; }
    #edit-profile-form input {
      width: 100%; padding: 0.5vmin; margin-bottom: 0.5vmin; border: none; border-radius: 0.3rem;
      background: #333; color: white; font-size: clamp(10px, 2vmin, 14px);
    }
    #edit-profile-form input::placeholder { color: #ccc; }
    .profile-info {
      display: flex; flex-direction: column; gap: 0.5vmin; padding: 1vmin; background: rgba(255,255,255,0.1);
      border-radius: 0.3rem; margin-bottom: 1vmin;
    }
    .profile-info div { color: white; font-size: clamp(10px, 2vmin, 14px); }
    #user-profile-content { flex: 1; padding: 1vmin; overflow-y: auto; }
    #toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7);
      color: white; padding: 0.8vmin 1.5vmin; border-radius: 0.4rem; z-index: 1003; transition: opacity 0.5s;
      opacity: 0; font-size: clamp(10px, 2vmin, 14px); pointer-events: none; max-width: 90vw; text-align: center;
    }
    #toast.visible-toast { opacity: 1; }
    #tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.8rem;
      z-index: 1004;
      pointer-events: none;
      display: none;
      white-space: nowrap;
      box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.2);
    }
    .alerts-tab-content, .leaderboard-tab-content, .admin-tab-content {
      flex: 1; overflow-y: auto; padding: 1.5vmin; display: none;
    }
    .alert-item {
      margin-bottom: 1.5vmin; padding: 1vmin; border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 0.3rem; background: rgba(255, 255, 255, 0.1);
    }
    .alert-field {
      font-size: clamp(10px, 2vmin, 14px); margin-bottom: 0.5vmin; color: white;
    }
    .alert-field a { color: #4CAF50; text-decoration: none; cursor: pointer; }
    .alert-field a:hover { text-decoration: underline; }
    .alert-votes {
      display: flex; justify-content: space-between; margin: 0.5vmin 0;
    }
    .vote-btn {
      padding: 0.5vmin 1vmin; border: none; border-radius: 0.3rem; cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    .upvote-btn { background: #4CAF50; }
    .upvote-btn:hover { background: #45a049; }
    .downvote-btn { background: #d32f2f; }
    .downvote-btn:hover { background: #b71c1c; }
    .alert-actions { display: flex; gap: 1vmin; margin-top: 1vmin; }
    .center-btn, .delete-btn, #center-alerts-btn {
      background: #4CAF50; color: white; border: none; padding: 0.5vmin 1vmin; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px);
    }
    .delete-btn { background: #d32f2f; margin-left: 0.5vmin; }
    .center-btn:hover, #center-alerts-btn:hover { background: #45a049; }
    .delete-btn:hover { background: #b71c1c; }
    .traffic-cam-marker { width: 40px; height: 40px; }
    #camera-hud, #arrival-hud, #verification-hud {
      display: none; flex-direction: column; gap: 1vmin; padding: 1vmin; text-align: center;
    }
    #camera-hud.active, #arrival-hud.active, #verification-hud.active { display: flex; }
    #camera-hud h3, #arrival-hud h3, #verification-hud h3 { margin: 0; font-size: clamp(14px, 2.5vmin, 18px); color: white; }
    #camera-hud p, #arrival-hud p, #verification-hud p { margin: 0.5vmin 0; font-size: clamp(10px, 2vmin, 14px); color: white; }
    #dismiss-camera-button, #arrival-ok-button, .verification-btn {
      margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem;
      cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white;
    }
    #dismiss-camera-button { background-color: #d32f2f; }
    #arrival-ok-button { background-color: #d32f2f; }
    #dismiss-camera-button:hover, #arrival-ok-button:hover, .verification-btn:hover { background-color: #b71c1c; }
    .verification-btn { background-color: #d32f2f; }
    .confirm-btn { background-color: #4CAF50; }
    .confirm-btn:hover { background-color: #45a049; }
    #high-contrast { filter: contrast(1.5); }
    .ping {
      animation: ping 1s ease-in-out infinite;
    }
    @keyframes ping {
      0% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.5); opacity: 0.4; }
      100% { transform: scale(1); opacity: 0.8; }
    }
    #multi-stop-inputs {
      display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;
    }
    #multi-stop-inputs input {
      padding: 0.5rem; border: 1px solid #ccc; border-radius: 0.3rem; font-size: 0.9rem;
    }
    .family-member {
      display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: rgba(255,255,255,0.1); margin-bottom: 0.5rem; border-radius: 0.3rem;
    }
    .remove-family { background: #d32f2f; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 0.2rem; cursor: pointer; }
    #offline-download-btn { background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; margin-top: 0.5rem; }
    #admin-search { width: 100%; padding: 0.5rem; margin-bottom: 1rem; border-radius: 0.3rem; border: none; background: #333; color: white; }
    #admin-search::placeholder { color: #ccc; }
    #search-users-btn { background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; margin-left: 0.5rem; }
    #users-list table { width: 100%; border-collapse: collapse; color: white; margin-top: 1rem; }
    #users-list th, #users-list td { border: 1px solid rgba(255,255,255,0.3); padding: 0.5rem; text-align: left; }
    #users-list button { margin-right: 0.5rem; padding: 0.3rem 0.6rem; font-size: clamp(8px, 1.5vmin, 12px); cursor: pointer; border-radius: 0.2rem; border: none; }
    #admin-user-activity { margin-top: 1rem; }
    #admin-user-activity ul { list-style: none; padding: 0; }
    #admin-user-activity li { padding: 0.5rem; background: rgba(255,255,255,0.1); margin-bottom: 0.5rem; border-radius: 0.3rem; }
    .admin-action-btn { background: #d32f2f; color: white; }
    .admin-action-btn:hover { background: #b71c1c; }
    .admin-promote-btn { background: #4CAF50; color: white; }
    .admin-promote-btn:hover { background: #45a049; }
    .accordion-header {
      background: rgba(255, 255, 255, 0.2); color: white; padding: 0.8vmin; cursor: pointer;
      border-radius: 0.3rem; margin-bottom: 0.5vmin; font-size: clamp(12px, 2.2vmin, 16px);
      transition: background 0.2s; display: flex; align-items: center; justify-content: space-between;
    }
    .accordion-header:hover { background: rgba(255, 255, 255, 0.3); }
    .accordion-header::after {
      content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1rem; color: white;
    }
    .accordion-header.active::after { content: '\f077'; }
    .accordion-content {
      display: none; padding: 1vmin; background: rgba(255, 255, 255, 0.1); border-radius: 0.3rem;
    }
    .accordion-content.active { display: block; }
    @media (max-width: 414px) {
      #button-container { right: 3vw; gap: 1.5vh; padding: 1.5vmin; }
      #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
        width: 8vw; height: 8vw; max-width: 32px; max-height: 32px;
      }
      #compass { width: 32px; height: 32px; top: 12vh; right: 3vw; }
      #hazard-button::before, #recenter-button::before, #settings-button::before, #current-alerts-button::before, #voice-button::before, #share-button::before, #leaderboard-button::before, #admin-button::before {
        font-size: 1rem;
      }
      #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
        width: 90vw; max-width: none; padding: 1.5vmin;
      }
      #admin-hud-container {
        width: 95vw;
        max-width: none;
      }
      #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
        padding: 1vmin 0; margin-bottom: 1vmin;
      }
      .report-options { gap: 1.5vmin; padding-top: 2.5vmin; }
      .report-button { font-size: clamp(9px, 1.8vmin, 13px); }
      .report-button i { font-size: clamp(11px, 2.2vmin, 14px); }
      #toast { width: 90vw; max-width: none; }
      .alert-field { font-size: clamp(9px, 1.8vmin, 13px); }
      .center-btn, .delete-btn, #center-alerts-btn { font-size: clamp(9px, 1.8vmin, 13px); }
      .traffic-cam-marker { width: 32px; height: 32px; }
      .settings-option .slider-value { font-size: clamp(9px, 1.8vmin, 13px); }
      .vote-btn { font-size: clamp(9px, 1.8vmin, 13px); }
      #users-list th, #users-list td { padding: 0.3rem; font-size: 0.8rem; }
    }
    @media (min-width: 415px) and (max-width: 768px) {
      #button-container { right: 2.5vw; gap: 1.2vh; padding: 1.5vmin; }
      #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
        width: 6vw; height: 6vw; max-width: 36px; max-height: 36px;
      }
      #compass { width: 36px; height: 36px; top: 11vh; right: 2.5vw; }
      #hazard-button::before, #recenter-button::before, #settings-button::before, #current-alerts-button::before, #voice-button::before, #share-button::before, #leaderboard-button::before, #admin-button::before {
        font-size: 1.1rem;
      }
      #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
        width: 80vw; max-width: 320px; padding: 1.2vmin;
      }
      #admin-hud-container {
        width: 85vw;
        max-width: 500px;
      }
      #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
        padding: 1vmin 0; margin-bottom: 1vmin;
      }
      .report-options { gap: 1.2vmin; padding-top: 2vmin; }
      .report-button { font-size: clamp(10px, 2vmin, 14px); }
      #toast { width: 80vw; max-width: 320px; }
    }
    @media (min-width: 769px) {
      #button-container { right: 2vw; gap: 1vh; padding: 1.5vmin; }
      #hazard-button, #recenter-button, #settings-button, #current-alerts-button, #voice-button, #share-button, #leaderboard-button, #admin-button {
        width: 5vw; height: 5vw; max-width: 40px; max-height: 40px;
      }
      #compass { width: 40px; height: 40px; top: 10vh; right: 2vw; }
      #hazard-button::before, #recenter-button::before, #settings-button::before, #current-alerts-button::before, #voice-button::before, #share-button::before, #leaderboard-button::before, #admin-button::before {
        font-size: 1.2rem;
      }
      #report-box, #reroute-hud-container, #settings-hud-container, #alerts-hud-container, #camera-hud-container, #leaderboard-hud-container, #arrival-hud-container, #admin-hud-container, #verification-hud-container, #user-profile-hud-container {
        width: 30vw; max-width: 300px; padding: 1vmin;
      }
      #admin-hud-container {
        width: 60vw;
        max-width: 800px;
      }
      #report-box header, #reroute-hud-container header, #settings-hud-container header, #alerts-hud-container header, #camera-hud-container header, #leaderboard-hud-container header, #arrival-hud-container header, #admin-hud-container header, #verification-hud-container header, #user-profile-hud-container header {
        padding: 1vmin 0; margin-bottom: 1vmin;
      }
      .report-options { gap: 1vmin; padding-top: 2vmin; }
      .report-button { font-size: clamp(10px, 2vmin, 14px); }
      #toast { width: 30vw; max-width: 300px; }
    }
    @media (orientation: landscape) { #hud-container, #bottom-hud-container { width: 60%; } }
    @media (orientation: portrait) { #hud-container, #bottom-hud-container { width: 80%; } }
    #auth-container {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8);
      z-index: 10000; display: none; justify-content: center; align-items: center; flex-direction: column;
      color: white; font-family: Arial, sans-serif;
    }
    #auth-title { font-size: 2rem; margin-bottom: 1rem; }
    #auth-form {
      display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 300px;
      padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem;
    }
    #auth-form input {
      padding: 0.5rem; border: none; border-radius: 0.3rem; font-size: 1rem;
      background: #333; color: white; outline: none;
    }
    #auth-form input::placeholder { color: #ccc; }
    #auth-form button {
      background: #4CAF50; color: white; border: none; padding: 0.5rem; border-radius: 0.3rem;
      cursor: pointer; font-size: 1rem; transition: background 0.2s;
    }
    #auth-form button:hover { background: #45a049; }
    #auth-switch { margin-top: 1rem; font-size: 0.9rem; }
    #auth-switch a { color: #4CAF50; text-decoration: none; }
    #auth-switch a:hover { text-decoration: underline; }
    #admin-content { flex: 1; padding: 1vmin; overflow-y: auto; display: flex; flex-direction: column; }
    #admin-tabs { margin-bottom: 1rem; }
    .admin-tab-content { padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem; }
    #user-search-container { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
    #user-search { flex: 1; padding: 0.5rem; border-radius: 0.3rem; border: none; background: #333; color: white; }
    #search-users-btn { background: #4CAF50; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; }
    #show-all-users-btn { background: #2196F3; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.3rem; cursor: pointer; margin-top: 0.5rem; }
    #users-list { margin-top: 1rem; overflow-x: auto; }
    #users-list table { width: 100%; border-collapse: collapse; color: white; min-width: 600px; }
    #users-list th, #users-list td { border: 1px solid rgba(255,255,255,0.3); padding: 0.8rem; text-align: left; }
    #users-list th { background: rgba(255,255,255,0.1); }
    #users-list button { margin-right: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.9rem; cursor: pointer; border-radius: 0.3rem; border: none; }
    .delete-btn, .ban-btn { background: #d32f2f; color: white; }
    .delete-btn:hover, .ban-btn:hover { background: #b71c1c; }
    .ipban-btn { background: #f44336; color: white; }
    .ipban-btn:hover { background: #d32f2f; }
    .promote-btn { background: #4CAF50; color: white; }
    .promote-btn:hover { background: #45a049; }
    .demote-btn { background: #FF9800; color: white; }
    .demote-btn:hover { background: #F57C00; }
    .view-activity-btn { background: #2196F3; color: white; }
    .view-activity-btn:hover { background: #1976D2; }
    #user-activity-list { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; }
    #user-activity-list li { padding: 0.5rem; background: rgba(255,255,255,0.05); margin-bottom: 0.5rem; border-radius: 0.3rem; border-left: 3px solid #4CAF50; }
    #user-activity-list li strong { color: #4CAF50; }
    .no-activity { text-align: center; color: #ccc; font-style: italic; }
#subscription-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 10001;
  display: none;
  justify-content: center;
  align-items: center;
  animation: fadeIn 0.3s ease;
  opacity: 0;
  transition: opacity 0.3s ease;
}
#subscription-modal.show {
  opacity: 1;
}
#subscription-content {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 1rem;
  padding: 2rem;
  max-width: 500px;
  width: 90%;
  color: white;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: slideUp 0.4s ease;
  transform: translateY(20px);
  opacity: 0;
  transition: all 0.3s ease;
}
#subscription-modal.show #subscription-content {
  transform: translateY(0);
  opacity: 1;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
@keyframes slideUp {
  from { transform: translateY(50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}
#subscription-content h2 {
  margin: 0 0 1rem 0;
  font-size: 1.8rem;
  text-align: center;
}
#subscription-content p {
  margin: 0.5rem 0;
  font-size: 1rem;
  line-height: 1.6;
}
.premium-features {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 0.5rem;
  padding: 1rem;
  margin: 1rem 0;
}
.premium-features ul {
  list-style: none;
  padding: 0;
  margin: 0.5rem 0;
}
.premium-features li {
  padding: 0.5rem 0;
  padding-left: 1.5rem;
  position: relative;
}
.premium-features li:before {
  content: 'âœ“';
  position: absolute;
  left: 0;
  color: #4CAF50;
  font-weight: bold;
  font-size: 1.2rem;
}
.pricing {
  text-align: center;
  font-size: 2rem;
  font-weight: bold;
  margin: 1rem 0;
  color: #FFD700;
}
.trial-info {
  background: rgba(255, 165, 0, 0.2);
  border-left: 4px solid #FFA500;
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 0.3rem;
}
.button-group {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
}
#upgrade-button, #maybe-later-button {
  flex: 1;
  padding: 1rem;
  border: none;
  border-radius: 0.5rem;
  font-size: 1rem;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}
#upgrade-button {
  background: #4CAF50;
  color: white;
}
#upgrade-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
}
#maybe-later-button {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
}
#maybe-later-button:hover {
  background: rgba(255, 255, 255, 0.3);
}
.locked-feature {
  opacity: 0.5;
  pointer-events: none;
  position: relative;
  cursor: not-allowed;
}
.locked-feature::after {
  content: 'ðŸ”’ Premium';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.9); /* Darker for better visibility */
  color: #FFD700;
  padding: 0.5rem 1rem; /* Larger for better touch targets */
  border-radius: 0.3rem;
  font-size: 0.9rem; /* Slightly larger */
  font-weight: bold;
  white-space: nowrap;
  pointer-events: none;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Add depth */
}
.locked-feature:hover::after {
  background: rgba(0, 0, 0, 1);
  transform: translate(-50%, -50%) scale(1.05); /* Slight scale on hover */
  transition: all 0.2s ease;
}
#trial-banner {
  position: fixed;
  bottom: 4vh;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  max-width: 300px;
  background: linear-gradient(90deg, #FFA500, #FF8C00);
  color: white;
  padding: 0.5rem;
  text-align: center;
  z-index: 9999;
  font-weight: normal;
  font-size: 0.9rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  border-radius: 0.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#trial-banner:hover {
  background: linear-gradient(90deg, #FF8C00, #FFA500);
}
#trial-banner-close {
  background: none;
  border: none;
  color: white;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0 0.5rem;
}
#subscription-loading {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10002;
  color: white;
  font-size: 1.2rem;
}
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="compass"></div>
  <div id="search-container">
    <input id="search-input" type="text" placeholder="Enter destination address">
    <div id="multi-stop-inputs" style="display: none;">
      <input type="text" placeholder="Add stop 1">
      <input type="text" placeholder="Add stop 2">
      <input type="text" placeholder="Add stop 3">
    </div>
    <button id="start-button">Start</button>
    <button id="simulate-position-button" style="display: none;">Simulate</button>
  </div>
  <div id="hud-container">
    <div id="hud-turn">Follow the road</div>
    <div id="hud-street">Current street: Unknown</div>
    <div id="hud-heading">Heading: Unknown</div>
  </div>
  <div id="bottom-hud-container">
    <button id="bottom-hud-stop">X</button>
    <div id="bottom-hud-info">
      <div id="bottom-hud-time">0 Mins</div>
      <div id="bottom-hud-distance">0 miles - Unknown</div>
    </div>
  </div>
  <div id="button-container">
    <div id="hazard-button"></div>
    <div id="recenter-button"></div>
    <div id="voice-button"></div>
    <div id="share-button"></div>
    <div id="settings-button"></div>
    <div id="current-alerts-button"></div>
    <div id="leaderboard-button"></div>
    <div id="admin-button"></div>
  </div>
  <div id="tooltip"></div>
  <div class="report-container">
    <div id="report-box">
      <header>
        <button id="report-close">X</button>
      </header>
      <div class="report-options">
        <div class="report-button" data-alert-type="Slowdown"><i class="fas fa-car"></i>Slowdown&nbsp;</div>
        <div class="report-button" data-alert-type="Crash"><i class="fas fa-car-crash"></i>Crash&nbsp;</div>
        <div class="report-button" data-alert-type="Construction"><i class="fas fa-tools"></i>Construction&nbsp;</div>
        <div class="report-button" data-alert-type="Police"><i class="fas fa-user-shield"></i>Police&nbsp;</div>
        <div class="report-button" data-alert-type="Object on Road"><i class="fas fa-road"></i>Object on Road&nbsp;</div>
        <div class="report-button" data-alert-type="Lane Closure"><i class="fas fa-road-barrier"></i>Lane Closure&nbsp;</div>
        <div class="report-button" data-alert-type="Manual Report"><i class="fas fa-comment"></i>Manual Report&nbsp;</div>
        <div class="report-button" data-alert-type="Low Visibility"><i class="fas fa-eye-slash"></i>Low Visibility&nbsp;</div>
        <div class="report-button" data-alert-type="Traffic Camera"><i class="fas fa-camera"></i>Traffic Camera&nbsp;</div>
        <div class="report-button" data-alert-type="Manual Traffic Camera"><i class="fas fa-camera-retro"></i>Manual Traffic Camera&nbsp;</div>
      </div>
      <div id="confirm-alert">
        <h3>Confirm Alert Location</h3>
        <p>Alert Type: <span id="alert-type-display"></span></p>
        <p>Location: <span id="location-display"></span></p>
        <p>Timestamp: <span id="timestamp-display"></span></p>
        <button id="post-alert-button">Post</button>
        <button id="cancel-alert-button">Cancel</button>
      </div>
    </div>
  </div>
  <div id="reroute-hud-container">
    <header>
      <button id="reroute-close">X</button>
    </header>
    <div id="reroute-hud">
      <h3>Reroute Available</h3>
      <p id="hazard-message"></p>
      <button id="accept-reroute-button">Accept</button>
      <button id="reject-reroute-button">Reject</button>
    </div>
  </div>
  <div id="settings-hud-container">
    <header>
      <button id="settings-close">X</button>
    </header>
    <div id="settings-content">
      <div class="accordion">
        <div class="accordion-item">
          <div class="accordion-header active" onclick="toggleAccordion(this)">Map Settings</div>
          <div class="accordion-content active">
            <div class="settings-option">
              <label for="map-type">Map Type</label>
              <select id="map-type">
                <option value="roadmap">Roadmap</option>
                <option value="satellite">Satellite</option>
                <option value="hybrid">Hybrid</option>
                <option value="terrain">Terrain</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="map-skin">Map Skin</label>
              <select id="map-skin">
                <option value="default">Default</option>
                <option value="dark">Dark</option>
                <option value="green">Green</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="map-orientation">Map Orientation</label>
              <select id="map-orientation">
                <option value="heading-up">Heading-Up</option>
                <option value="north-up">North-Up</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="high-contrast-toggle">High Contrast Mode</label>
              <input type="checkbox" id="high-contrast-toggle">
            </div>
            <div class="settings-option">
              <label for="main-route-color">Main Route Color</label>
              <select id="main-route-color">
                <option value="#4285F4">Blue</option>
                <option value="#FF0000">Red</option>
                <option value="#008000">Green</option>
                <option value="#800080">Purple</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="alt-route-color">Alternate Route Color</label>
              <select id="alt-route-color">
                <option value="#FFA500">Orange</option>
                <option value="#FFFF00">Yellow</option>
                <option value="#FF69B4">Pink</option>
                <option value="#00CED1">Cyan</option>
              </select>
            </div>
            <div class="settings-option">
              <label for="traffic-layer-toggle">Show Traffic Layer</label>
              <input type="checkbox" id="traffic-layer-toggle">
            </div>
            <div class="settings-option">
              <label for="traffic-camera-toggle">Show Traffic Camera Alerts</label>
              <input type="checkbox" id="traffic-camera-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="hazard-alert-distance">Hazard Alert Distance (miles)</label>
              <div>
                <input type="range" id="hazard-alert-distance" min="1" max="5" value="2" step="0.5">
                <span class="slider-value" id="hazard-distance-value">2 miles</span>
              </div>
            </div>
            <div class="settings-option">
              <label for="camera-alert-distance">Camera Alert Distance (miles)</label>
              <div>
                <input type="range" id="camera-alert-distance" min="0.5" max="2" value="0.5" step="0.5">
                <span class="slider-value" id="camera-distance-value">0.5 miles</span>
              </div>
            </div>
            <div class="settings-option">
              <label for="use-default-distances">Use Default Distances</label>
              <input type="checkbox" id="use-default-distances" checked>
            </div>
            <div class="settings-option">
              <label for="auto-recenter-toggle">Auto-Recenter</label>
              <input type="checkbox" id="auto-recenter-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="voice-assistant-toggle">Voice Assistant (Nova)</label>
              <input type="checkbox" id="voice-assistant-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="push-notifications-toggle">Push Notifications</label>
              <input type="checkbox" id="push-notifications-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="show-tooltips-toggle">Show Tooltips</label>
              <input type="checkbox" id="show-tooltips-toggle" checked>
            </div>
            <div class="settings-option">
              <label for="recalibrate-compass-button">Recalibrate Compass</label>
              <button id="recalibrate-compass-button">Calibrate</button>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Advanced Alerts</div>
          <div class="accordion-content">
            <div class="settings-option">
              <label for="alert-radius">Alert Radius (miles)</label>
              <div>
                <input type="range" id="alert-radius" min="1" max="20" value="10" step="1">
                <span class="slider-value" id="alert-radius-value">10 miles</span>
              </div>
            </div>
            <div class="settings-option">
              <label>Custom Filters</label>
              <div style="display: flex; flex-direction: column; gap: 0.5vmin; width: 50%;">
                <label><input type="checkbox" id="filter-police" checked> Police Only</label>
                <label><input type="checkbox" id="filter-crash"> Crashes</label>
                <label><input type="checkbox" id="filter-construction"> Construction</label>
              </div>
            </div>
            <div class="settings-option">
              <label for="traffic-forecast-toggle">Enable Traffic Forecast</label>
              <input type="checkbox" id="traffic-forecast-toggle" checked>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Route Options</div>
          <div class="accordion-content">
            <div class="settings-option">
              <label for="multi-stop-toggle">Enable Multi-Stop Planning</label>
              <input type="checkbox" id="multi-stop-toggle">
            </div>
            <div class="settings-option">
              <label for="ev-charging-toggle">Integrate EV Charging</label>
              <input type="checkbox" id="ev-charging-toggle">
            </div>
            <div class="settings-option">
              <label for="route-preset">Route Preset</label>
              <select id="route-preset">
                <option value="default">Default</option>
                <option value="scenic">Scenic</option>
                <option value="avoid-toll">Avoid Tolls</option>
                <option value="family">Family Road Trip</option>
              </select>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Offline Maps</div>
          <div class="accordion-content">
            <div class="settings-option">
              <label>Downloaded Regions</label>
              <div id="offline-regions-list" style="display: flex; flex-direction: column; gap: 0.5vmin; width: 50%;"></div>
            </div>
            <button id="offline-download-btn">Download Current Region</button>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Family Sharing</div>
          <div class="accordion-content">
            <div class="settings-option">
              <label>Family Members (up to 5)</label>
              <div id="family-list" style="display: flex; flex-direction: column; gap: 0.5vmin; width: 50%;"></div>
            </div>
            <input id="add-family-input" type="text" placeholder="Add family member email">
            <button id="add-family-btn">Add</button>
            <button id="share-route-btn">Share Current Route</button>
          </div>
        </div>
        <div class="accordion-item">
          <div class="accordion-header" onclick="toggleAccordion(this)">Account</div>
          <div class="accordion-content">
            <div class="profile-info">
              <div><strong>Username:</strong> <span id="username-display">Loading...</span></div>
              <div><strong>Email:</strong> <span id="email-display">Loading...</span></div>
              <div><strong>Join Date:</strong> <span id="join-date-display">Loading...</span></div>
              <div><strong>Total Alerts Posted:</strong> <span id="total-alerts-display">Loading...</span></div>
              <div><strong>Active Alerts:</strong> <span id="active-alerts-display">Loading...</span></div>
              <div><strong>Points:</strong> <span id="points-display">Loading...</span></div>
            </div>
            <button id="edit-profile-button">Edit Profile</button>
            <div id="edit-profile-form" style="display: none;">
              <input id="edit-username" placeholder="New Username" type="text">
              <input id="edit-email" placeholder="New Email" type="email">
              <input id="edit-password" placeholder="New Password (optional)" type="password">
              <button id="save-profile">Save</button>
              <button id="cancel-edit">Cancel</button>
            </div>
            <button id="logout-button">Logout</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="alerts-hud-container">
    <header>
      <button id="alerts-close">X</button>
    </header>
    <div id="alerts-tabs">
      <div class="alerts-tab active" data-tab="information">Information</div>
      <div class="alerts-tab" data-tab="tools">Tools</div>
    </div>
    <div id="information" class="alerts-tab-content"></div>
    <div id="tools" class="alerts-tab-content" style="display: none;">
      <button id="center-alerts-btn">Center on Alerts</button>
    </div>
  </div>
  <div id="camera-hud-container">
    <header>
      <button id="camera-close">X</button>
    </header>
    <div id="camera-hud">
      <h3>Traffic Camera Ahead</h3>
      <p>Traffic enforcement camera in the area. Drive safely!</p>
      <button id="dismiss-camera-button">Dismiss</button>
    </div>
  </div>
  <div id="arrival-hud-container">
    <header>
      <button id="arrival-close">X</button>
    </header>
    <div id="arrival-hud">
      <h3>You've arrived!</h3>
      <button id="arrival-ok-button">OK</button>
    </div>
  </div>
  <div id="verification-hud-container">
    <header>
      <button id="verification-close">X</button>
    </header>
    <div id="verification-hud">
      <h3>Alert Verification</h3>
      <p id="verification-message">You have passed an alert. Is it still valid?</p>
      <button class="verification-btn confirm-btn" id="confirm-alert-btn">Confirm (Still Valid)</button>
      <button class="verification-btn" id="dismiss-alert-btn">Dismiss (No Longer Valid)</button>
    </div>
  </div>
  <div id="leaderboard-hud-container">
    <header>
      <button id="leaderboard-close">X</button>
    </header>
    <div id="leaderboard-content" class="leaderboard-tab-content"></div>
  </div>
  <div id="admin-hud-container">
    <header>
      <button id="admin-close">X</button>
      <h2>Admin Panel</h2>
    </header>
    <div id="admin-tabs">
      <div class="admin-tab active" data-tab="users">Users</div>
      <div class="admin-tab" data-tab="activity">User Activity</div>
    </div>
    <div id="admin-content">
      <div id="users" class="admin-tab-content">
        <div id="user-search-container">
          <input id="user-search" type="text" placeholder="Search users by username or email">
          <button id="search-users-btn">Search</button>
        </div>
        <button id="show-all-users-btn">Show All Users</button>
        <div id="users-list"></div>
      </div>
      <div id="activity" class="admin-tab-content">
        <div id="user-search-container">
          <input id="activity-user-search" type="text" placeholder="Enter user ID or username for activity">
          <button id="load-activity-btn">Load Activity</button>
        </div>
        <div id="user-activity-list"></div>
      </div>
    </div>
  </div>
  <div id="user-profile-hud-container">
    <header>
      <button id="user-profile-close">X</button>
    </header>
    <div id="user-profile-content">
      <div class="profile-info">
        <div><strong>Username:</strong> <span id="hud-username">Loading...</span></div>
        <div><strong>Join Date:</strong> <span id="hud-join-date">Loading...</span></div>
        <div><strong>Total Alerts Posted:</strong> <span id="hud-total-alerts">Loading...</span></div>
        <div><strong>Active Alerts:</strong> <span id="hud-active-alerts">Loading...</span></div>
        <div><strong>Points:</strong> <span id="hud-points">Loading...</span></div>
      </div>
    </div>
  </div>
  <div id="toast"></div>
  <div id="auth-container" style="display: none;">
    <h2 id="auth-title">Login</h2>
    <form id="auth-form" style="display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 300px; padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem;">
      <input type="text" id="username" name="username" placeholder="Username" style="display: none;">
      <input type="email" id="email" name="email" placeholder="Email" required>
      <input type="password" id="password" name="password" placeholder="Password" required>
      <label style="display: flex; align-items: center; gap: 0.5rem; color: white; font-size: 0.9rem;">
        <input type="checkbox" id="stay-logged-in" checked style="width: auto;">
        <span>Stay logged in</span>
      </label>
      <button type="submit">Submit</button>
    </form>
    <p id="auth-switch">Don't have an account? <a href="#" style="color: #4CAF50;" onclick="switchAuthMode()">Register</a></p>
  </div>
  <!-- Trial Banner -->
<div id="trial-banner" style="display: none;">
  <span id="trial-banner-text">ðŸŽ‰ Free Trial Active - <span id="trial-days-remaining">7</span> days remaining</span>
  <button id="trial-banner-close" title="Hide Banner">Ã—</button>
</div>
<!-- Subscription Modal -->
<div id="subscription-modal">
  <div id="subscription-content">
    <h2 id="modal-title">ðŸš€ Unlock Premium Features</h2>
    <p id="modal-message">Your 7-day free trial has ended. Upgrade to Premium to continue enjoying all features!</p>
    <div class="premium-features">
      <strong>Premium Features Include:</strong>
      <ul>
        <li>Advanced Alert Types (Traffic Cameras, Construction)</li>
        <li>Multi-Stop Route Planning</li>
        <li>Traffic Forecast & AI Predictions</li>
        <li>Offline Maps Download</li>
        <li>Family Sharing (Up to 5 Members)</li>
        <li>EV Charging Station Integration</li>
        <li>Custom Route Presets</li>
        <li>Priority Rerouting</li>
        <li>Ad-Free Experience</li>
        <li>Leaderboard Access</li>
      </ul>
    </div>
    <div class="pricing">$4.99<span style="font-size: 1rem;">/month</span></div>
    <div class="trial-info" id="trial-info-box" style="display: none;">
      <strong>â° Trial Info:</strong>
      <p id="trial-status-text"></p>
    </div>
    <div class="button-group">
      <button id="upgrade-button">Upgrade Now</button>
      <button id="maybe-later-button">Maybe Later</button>
    </div>
  </div>
</div>
  <!-- Add before closing </body> -->
<div id="subscription-loading" style="display: none;">
  <div>Checking subscription status...</div>
</div>
<div id="map-loading" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 2rem; border-radius: 0.5rem; z-index: 10000; display: none;">
  Loading Map...
</div>
  <script>
    const CONFIG = Object.freeze({
      REROUTE_CHECK_INTERVAL: 2000,
      OFF_ROUTE_TOLERANCE: 50,
      MIN_REROUTE_DISTANCE: 100,
      MIN_ALERT_DISTANCE: 152.4,
      CAMERA_CHECK_INTERVAL: 10000,
      ALERT_POLL_INTERVAL: 5000,
      HEADING_SMOOTHING_WINDOW: 10,
      POSITION_HISTORY_WINDOW: 10,
      MIN_ZOOM: 16,
      MAX_ZOOM: 19,
      TURN_ZOOM: 19,
      STRAIGHT_ZOOM: 16.5,
      TURN_THRESHOLD: 300,
      HEADING_CHANGE_THRESHOLD: 15,
      MIN_HEADING_CHANGE: 8,
      CAMERA_UPDATE_THRESHOLD: 50,
      STATIONARY_SPEED_THRESHOLD: 2.2352,
      ARRIVAL_RADIUS: 50,
      ANNOUNCEMENT_COOLDOWN: 10000,
      ALERT_FETCH_INTERVAL: 30000,
      ALTERNATE_TRIGGER_DISTANCE: 50,
      SNAP_BUFFER: 100,
      MAX_GPS_DISTANCE: 300,
      SMOOTH_THRESHOLD: 100,
      HEADING_VARIANCE_THRESHOLD: 30,
      SIGNIFICANT_TURN_THRESHOLD: 30,
      VERIFICATION_DISTANCE: 50,
      BATCH_UPDATE_INTERVAL: 5000,
      ALERT_CACHE_TTL: 60000,
      ALERT_CACHE_CLEANUP: 30000,
      DEBOUNCE_DELAY: 100,
      FETCH_RETRIES: 3,
      FETCH_BACKOFF: 1000,
      NAV_STATE_SAVE_INTERVAL: 10000,
      NAV_STATE_EXPIRY: 300000
    });
    const VAPID_PUBLIC_KEY = 'BNclrc97FLwjMZNchCLjpVHHOMtP4FfxR9gvXZAT0tv0rzPREQ91v37M-Aa-D0hAygzmIKhMDeSLpmhG-NohTvs';
    const mapId = '2666b5bd496d9c6026f43f82';
    const mapSkins = {
      default: [],
      dark: [
        {elementType: 'geometry', stylers: [{color: '#242f3e'}]},
        {elementType: 'labels.text.stroke', stylers: [{color: '#242f3e'}]},
        {elementType: 'labels.text.fill', stylers: [{color: '#746855'}]},
        {featureType: 'administrative.locality', elementType: 'labels.text.fill', stylers: [{color: '#d59563'}]},
        {featureType: 'poi', elementType: 'labels.text.fill', stylers: [{color: '#d59563'}]},
        {featureType: 'poi.park', elementType: 'geometry', stylers: [{color: '#263c3f'}]},
        {featureType: 'poi.park', elementType: 'labels.text.fill', stylers: [{color: '#6b9a76'}]},
        {featureType: 'road', elementType: 'geometry', stylers: [{color: '#38414e'}]},
        {featureType: 'road', elementType: 'geometry.stroke', stylers: [{color: '#212a37'}]},
        {featureType: 'road', elementType: 'labels.text.fill', stylers: [{color: '#9ca5b3'}]},
        {featureType: 'road.highway', elementType: 'geometry', stylers: [{color: '#746855'}]},
        {featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{color: '#1f2835'}]},
        {featureType: 'road.highway', elementType: 'labels.text.fill', stylers: [{color: '#f3d19c'}]},
        {featureType: 'transit', elementType: 'geometry', stylers: [{color: '#2f3948'}]},
        {featureType: 'transit.station', elementType: 'labels.text.fill', stylers: [{color: '#d59563'}]},
        {featureType: 'water', elementType: 'geometry', stylers: [{color: '#17263c'}]},
        {featureType: 'water', elementType: 'labels.text.fill', stylers: [{color: '#515c6d'}]},
        {featureType: 'water', elementType: 'labels.text.stroke', stylers: [{color: '#17263c'}]}
      ],
      green: [
        {featureType: 'all', elementType: 'all', stylers: [{saturation: 20}, {lightness: 10}]},
        {featureType: 'poi.park', elementType: 'geometry', stylers: [{color: '#4a8a4a'}, {lightness: 0}]},
        {featureType: 'landscape', elementType: 'geometry', stylers: [{color: '#8dc869'}, {lightness: 10}]},
        {featureType: 'road', elementType: 'geometry', stylers: [{lightness: 10}, {color: '#a3c6a3'}]},
        {featureType: 'road.highway', elementType: 'geometry', stylers: [{color: '#90c690'}]},
        {featureType: 'water', elementType: 'geometry', stylers: [{color: '#6bb6ff'}, {lightness: 10}]},
        {featureType: 'administrative', elementType: 'labels.text.fill', stylers: [{color: '#4a8a4a'}]}
      ]
    };
    let map, userMarker, destMarker, directionsService, directionsRenderer, alternativeRenderer, trafficLayer, watchId, socket, speechRecognition, routePolyline, offRoadPolyline;
    let currentHeadingTween = null;
    let lastProgrammaticZoom = null;
    let dragTimer;
    let dragStartPos = null;
    let currentAlerts = [];
    let cameraCheckInterval = null;
    let alertPollInterval = null;
    let cameraPositions = [];
    let cameraAlertShown = new Set();
    let positionHistory = [];
    let showTrafficCameras = localStorage.getItem('showTrafficCameras') !== 'false';
    let hazardAlertDistance = parseFloat(localStorage.getItem('hazardAlertDistance')) || 2;
    let cameraAlertDistance = parseFloat(localStorage.getItem('cameraAlertDistance')) || 0.5;
    let useDefaultDistances = localStorage.getItem('useDefaultDistances') !== 'false';
    let highContrastMode = localStorage.getItem('highContrastMode') === 'true';
    let pushNotificationsEnabled = localStorage.getItem('pushNotificationsEnabled') !== 'false';
    let mapOrientation = localStorage.getItem('mapOrientation') || 'heading-up';
    let mapSkin = localStorage.getItem('mapSkin') || 'default';
    let voiceAssistantEnabled = localStorage.getItem('voiceAssistantEnabled') !== 'false';
    let showTooltips = localStorage.getItem('showTooltips') !== 'false';
    let isInitialized = false;
    let toastTimeout = null;
    let lastHeading = 0;
    let lastCameraPosition = null;
    let lastStableHeading = 0;
    let lastSpokenTurn = '';
    let lastAnnouncementTime = 0;
    let headingHistory = [];
    let lastLocationUpdate = 0;
    let lastAlertFetchTime = 0;
    let lastPosition = null;
    let compassHeading = 0;
    let retryCount = 0;
    let rawUserLocation = null;
    let needsCalibration = false;
    let lastCameraUpdate = 0;
    let isAdmin = localStorage.getItem('isAdmin') === 'true';
    let trackingUsers = [];
    let trackedMarkers = new Map();
    const markers = new Map();
    const MAX_RETRIES = 5;
    const alertCache = new Map();
    const headingCache = new Map();
    const markerPool = [];
    const MAX_MARKER_POOL_SIZE = 50;
    let routeSpatialIndex = null;
    let lastBoundsCheck = 0;
    const BOUNDS_CHECK_INTERVAL = 1000;
    let lastHeadingUpdate = 0;
    const ProgrammaticUpdateManager = {
  _isUpdating: false,
  _callbacks: [],
  _startTime: 0,
  _timeoutId: null,
  start() {
    this._isUpdating = true;
    this._startTime = Date.now();
    this._callbacks = [];
    // Auto-reset after 5 seconds
    clearTimeout(this._timeoutId);
    this._timeoutId = setTimeout(() => {
      if (this._isUpdating) {
        console.error('ProgrammaticUpdateManager stuck, force resetting');
        this.end();
      }
    }, 5000);
  },
  end(callback = null) {
    clearTimeout(this._timeoutId);
    if (callback) this._callbacks.push(callback);
    requestAnimationFrame(() => {
      this._isUpdating = false;
      this._callbacks.forEach(cb => cb());
      this._callbacks = [];
    });
  },
  get isActive() {
    return this._isUpdating;
  }
};
    let navState = {
      currentRoute: null,
      isNavigating: false,
      isFollowing: localStorage.getItem('isFollowing') === 'true',
      mapOrientation: mapOrientation,
      destination: null,
      userLocation: { lat: 33.083270, lng: -83.233040 },
      previousUserLocation: null,
      lastKnownPosition: null,
      routePolyline: null,
      detailedPath: [],
      lastSnapIndex: 0,
      rerouteCheckTimeout: null,
      hazardCheckInterval: null,
      currentHeading: 0,
      alertState: 'IDLE',
      tempMarker: null,
      tempAlertData: null,
      alternativeRoute: null,
      originalRoute: null,
      mapClickListener: null,
      ignoredHazards: [],
      currentHazard: null,
      pendingReroute: null,
      navigationZoom: 18,
      mainRouteColor: localStorage.getItem('mainRouteColor') || '#4285F4',
      altRouteColor: localStorage.getItem('altRouteColor') || '#FFA500',
      mapType: localStorage.getItem('mapType') || 'roadmap',
      showTraffic: localStorage.getItem('showTraffic') === 'true',
      useDefaultDistances: useDefaultDistances,
      lastValidHeading: 0,
      isInitialSnap: true,
      lastCameraUpdate: 0,
      lastCameraUpdateTime: 0,
      hasArrived: false,
      alertProximities: new Map(),
      waypoints: [],
      avoidTolls: false,
      avoidHighways: false,
      evCharging: false,
      routePreset: 'default',
      alertRadius: parseInt(localStorage.getItem('alertRadius')) || 10,
      alertFilters: JSON.parse(localStorage.getItem('alertFilters')) || { police: true, crash: true, construction: true },
      trafficForecast: localStorage.getItem('trafficForecast') === 'true',
      multiStop: localStorage.getItem('multiStop') === 'true',
      offlineRegions: JSON.parse(localStorage.getItem('offlineRegions')) || [],
      familyMembers: JSON.parse(localStorage.getItem('familyMembers')) || []
    };
    let mockSimulationInterval = null;
    let isRegister = false;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const LOCATION_UPDATE_THRESHOLD = isMobile ? 1000 : 100;
    let wakeLock = null;
    let isLowBattery = false;
    let visibilityHandler = null;
    let currentVerificationAlertId = null;
    let wakeWordRecognizer = null;
    let commandSpeechRecognition = null;
    const tooltipTexts = {
      'hazard-button': 'Report hazard ahead',
      'recenter-button': 'Recenter on location',
      'voice-button': 'Voice commands',
      'share-button': 'Share current route',
      'settings-button': 'App settings',
      'current-alerts-button': 'View current alerts',
      'leaderboard-button': 'View leaderboard',
      'admin-button': 'Admin panel'
    };
    let tooltipTimer = null;
    let tooltipHideTimer = null;
    let selectedUserId = null; // For admin activity view
    const updateMetrics = {
      lastUpdateDuration: 0,
      averageDuration: 0,
      totalUpdates: 0
    };
    let isPostingAlert = false; // Guard for race condition in postAlert
    let postingTimeout = null;
    // TokenManager
    const TokenManager = {
      get() {
        return localStorage.getItem('token') || sessionStorage.getItem('token');
      },
      set(token, remember = true) {
        if (remember) {
          localStorage.setItem('token', token);
        }
        sessionStorage.setItem('token', token);
      },
      clear() {
        localStorage.removeItem('token');
        localStorage.removeItem('userId');
        sessionStorage.removeItem('token');
        sessionStorage.removeItem('userId');
      },
      isValid() {
        const token = this.get();
        if (!token || !token.includes('.') || token === 'undefined') {
          return false;
        }
        // Check expiration
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          return payload.exp * 1000 > Date.now();
        } catch {
          return false;
        }
      }
    };
    // Debounce utility
    const debounce = (fn, delay) => {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
      };
    };
    // Safe execute wrapper
    function safeExecute(fn, fallback, context = '') {
      try {
        return fn();
      } catch (error) {
        console.error(`Error in ${context}:`, error);
        if (fallback) return fallback();
        showToast(`Error: ${context}. Retrying...`);
      }
    }
    // Error Boundary
    function withErrorBoundary(fn, fallback, context) {
      return async function(...args) {
        try {
          return await fn.apply(this, args);
        } catch (error) {
          console.error(`Error in ${context}:`, error);
          // Log to Sentry in production
          if (window.Sentry && window.location.hostname !== 'localhost') {
            Sentry.captureException(error, {
              tags: { context, feature: 'navigation' },
              extra: {
                args: args.slice(0, 3), // Limit to prevent PII
                navState: {
                  isNavigating: navState.isNavigating,
                  isFollowing: navState.isFollowing
                }
              },
              level: 'error'
            });
          }
          if (fallback) {
            return fallback(error);
          }
          showToast(`An error occurred. Please refresh the page.`);
        }
      };
    }
    // Close HUD helper
    function closeHUD(hudId, cleanupFn) {
      const hud = document.getElementById(hudId);
      hud.classList.remove('active');
      if (cleanupFn) cleanupFn();
      if (navState.isNavigating && navState.isFollowing) {
        lockNavigation();
      }
    }
    // Marker pool functions
    function getMarker(config) {
      const marker = markerPool.pop();
      if (marker) {
        Object.assign(marker, config);
        return marker;
      }
      return new google.maps.marker.AdvancedMarkerElement(config);
    }
    function releaseMarker(marker) {
      marker.map = null;
      if (markerPool.length < MAX_MARKER_POOL_SIZE) {
        markerPool.push(marker);
      }
    }
    // Cached heading
    function getCachedHeading(p1, p2) {
      const key = `${p1.lat()},${p1.lng()}-${p2.lat()},${p2.lng()}`;
      if (!headingCache.has(key)) {
        headingCache.set(key, google.maps.geometry.spherical.computeHeading(p1, p2));
      }
      return headingCache.get(key);
    }
    // Batch update
    async function batchUpdate() {
      const [locationRes, alertsRes] = await Promise.all([
        updateServerLocation(navState.userLocation),
        pollAlerts()
      ]);
      return { locationRes, alertsRes };
    }
    // Alert cache TTL cleanup
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of alertCache.entries()) {
        if (now - value.timestamp > CONFIG.ALERT_CACHE_TTL) { // 1 min TTL
          alertCache.delete(key);
        }
      }
    }, CONFIG.ALERT_CACHE_CLEANUP); // Clean every 30s
    function showTooltip(buttonId, text) {
      if (!showTooltips) return;
      const tooltip = document.getElementById('tooltip');
      tooltip.textContent = text;
      tooltip.style.display = 'block';
      const button = document.getElementById(buttonId);
      const rect = button.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let top = rect.top - 50;
      let left = rect.left + (rect.width / 2);
      if (top < 10) top = rect.bottom + 10;
      if (left + 100 > viewportWidth) left = rect.right - 100;
      if (left < 10) left = rect.left;
      if (top + 30 > viewportHeight) top = viewportHeight - 40;
      tooltip.style.top = top + 'px';
      tooltip.style.left = left + 'px';
      if (tooltipHideTimer) clearTimeout(tooltipHideTimer);
      tooltipHideTimer = setTimeout(() => hideTooltip(), 2000);
    }
    function hideTooltip() {
      const tooltip = document.getElementById('tooltip');
      tooltip.style.display = 'none';
      if (tooltipTimer) clearTimeout(tooltipTimer);
      if (tooltipHideTimer) clearTimeout(tooltipHideTimer);
    }
    function setupTooltips() {
      Object.keys(tooltipTexts).forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (!button) return;
        const text = tooltipTexts[buttonId];
        if (isMobile) {
          let holdStart = 0;
          button.addEventListener('touchstart', (e) => {
            hideTooltip();
            holdStart = Date.now();
            tooltipTimer = setTimeout(() => showTooltip(buttonId, text), 500);
          });
          button.addEventListener('touchend', (e) => {
            const holdTime = Date.now() - holdStart;
            if (holdTime >= 500) {
              e.preventDefault();
            }
            clearTimeout(tooltipTimer);
            holdStart = 0;
          });
        } else {
          button.addEventListener('mouseenter', () => showTooltip(buttonId, text));
          button.addEventListener('mouseleave', hideTooltip);
        }
      });
      document.addEventListener('touchstart', hideTooltip, { passive: true });
    }
    function normalizeHeadingDelta(current, target) {
      let delta = target - current;
      while (delta > 180) delta -= 360;
      while (delta < -180) delta += 360;
      return delta;
    }
    async function requestWakeLock() {
      if (!('wakeLock' in navigator)) {
        console.warn('Wake Lock API not supported');
        return;
      }
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
          console.log('Wake Lock released');
          wakeLock = null;
        });
        console.log('Wake Lock acquired');
      } catch (err) {
        console.error('Wake Lock request failed:', err);
      }
    }
    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
        console.log('Wake Lock released');
      }
    }
    function setupPageVisibility() {
      visibilityHandler = () => {
        if (!document.hidden && navState.isNavigating) {
          console.log('Page became visible, re-initializing GPS and Socket.IO');
          if (socket && !socket.connected) {
            socket.connect();
          }
          if (watchId) {
            navigator.geolocation.clearWatch(watchId);
          }
          watchId = navigator.geolocation.watchPosition(
            onPositionUpdate,
            (error) => handleGeolocationError(error),
            { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
          );
          restoreNavigationView();
          requestWakeLock();
          // Enhanced restore
          if (navState.currentRoute) {
            directionsRenderer.setDirections(navState.currentRoute);
            updateRouteAhead(navState.userLocation);
          }
          fetchCurrentAlerts();
          if (navState.hazardCheckInterval) {
            clearInterval(navState.hazardCheckInterval);
          }
          navState.hazardCheckInterval = setInterval(checkHazardsAndOfferReroute, 5000);
          startRerouteCheck();
          // Reset smoothing histories for fresh start after timeout
          positionHistory = [];
          headingHistory = [];
          lastStableHeading = navState.currentHeading;
          console.log('Enhanced restore complete after visibility change');
        }
      };
      document.addEventListener('visibilitychange', visibilityHandler);
    }
    function cleanupPageVisibility() {
      if (visibilityHandler) {
        document.removeEventListener('visibilitychange', visibilityHandler);
        visibilityHandler = null;
      }
    }
    window.addEventListener('beforeunload', cleanupResources);
    navigator.getBattery?.().then(battery => {
      isLowBattery = battery.level < 0.2;
      battery.addEventListener('levelchange', () => {
        isLowBattery = battery.level < 0.2;
        if (isLowBattery && navState.isNavigating) {
          releaseWakeLock();
          showToast('Low battery detected. Screen wake lock released to save power.');
        }
      });
    });
    function switchAuthMode() {
      isRegister = !isRegister;
      console.log('Switching auth mode:', isRegister ? 'Register' : 'Login');
      const authTitle = document.getElementById('auth-title');
      const usernameInput = document.getElementById('username');
      const authSwitch = document.getElementById('auth-switch');
      authTitle.textContent = isRegister ? 'Register' : 'Login';
      usernameInput.style.display = isRegister ? 'block' : 'none';
      authSwitch.innerHTML = isRegister
        ? 'Already have an account? <a href="#" style="color: #4CAF50;" onclick="switchAuthMode()">Login</a>'
        : 'Don\'t have an account? <a href="#" style="color: #4CAF50;" onclick="switchAuthMode()">Register</a>';
      console.log('Auth form updated:', { isRegister, title: authTitle.textContent, usernameVisible: usernameInput.style.display });
    }
    document.getElementById('auth-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      console.log('Auth form submitted:', { isRegister });
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value.trim();
      const username = isRegister ? document.getElementById('username').value.trim() : '';
      const stayLoggedIn = document.getElementById('stay-logged-in').checked;
      console.log('Form data:', { email, password, username, endpoint: isRegister ? '/api/auth/register' : '/api/auth/login' });
      if (!email || !password || (isRegister && !username)) {
        console.error('Missing required fields:', { email, password, username });
        showToast('Please fill in all required fields.');
        return;
      }
      const endpoint = isRegister ? '/api/auth/register' : '/api/auth/login';
      const body = isRegister ? { email, password, username } : { email, password };
      try {
        console.log('Sending fetch request to:', endpoint);
        const response = await fetch(endpoint, {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        console.log('Response received:', { status: response.status, ok: response.ok });
        console.log('Response headers:', [...response.headers.entries()]);
        const data = await response.json();
        console.log('Response data:', data);
        if (response.ok && data.token && data.user) {
          TokenManager.set(data.token, stayLoggedIn);
          localStorage.setItem('userId', data.user.id);
          sessionStorage.setItem('userId', data.user.id);
          isAdmin = data.user.email === 'imhoggbox@gmail.com' || data.user.isAdmin;
          localStorage.setItem('isAdmin', isAdmin);
          sessionStorage.setItem('isAdmin', isAdmin);
          document.getElementById('admin-button').style.display = isAdmin ? 'flex' : 'none';
          console.log('Token and userId saved:', { token: data.token.substring(0, 20) + '...', userId: data.user.id, isAdmin });
          document.getElementById('auth-container').style.display = 'none';
          showToast(isRegister ? 'Registration successful!' : 'Login successful!');
          console.log(isRegister ? 'User registered' : 'User logged in', { userId: data.user.id });
          initApp();
        } else {
          console.error('Auth failed:', { status: response.status, error: data.error || 'No error message' });
          showToast(data.error || (isRegister ? 'Registration failed.' : 'Login failed.'));
        }
      } catch (error) {
        console.error('Fetch error:', error.message);
        showToast('Error: Unable to connect to server. Check your network.');
      }
    });
    function animate() {
      if (typeof TWEEN !== 'undefined') {
        TWEEN.update();
        requestAnimationFrame(animate);
      }
    }
    animate();
    function adjustHud() {
      const reportBox = document.getElementById('report-box');
      const rerouteHudContainer = document.getElementById('reroute-hud-container');
      const settingsHudContainer = document.getElementById('settings-hud-container');
      const alertsHudContainer = document.getElementById('alerts-hud-container');
      const cameraHudContainer = document.getElementById('camera-hud-container');
      const leaderboardHudContainer = document.getElementById('leaderboard-hud-container');
      const arrivalHudContainer = document.getElementById('arrival-hud-container');
      const adminHudContainer = document.getElementById('admin-hud-container');
      const verificationHudContainer = document.getElementById('verification-hud-container');
      const userProfileHudContainer = document.getElementById('user-profile-hud-container');
      const currentWidth = window.innerWidth;
      const currentHeight = window.innerHeight;
      const maxHeight = Math.min(currentHeight * 0.5, 400);
      const hudElements = [reportBox, rerouteHudContainer, settingsHudContainer, alertsHudContainer, cameraHudContainer, leaderboardHudContainer, arrivalHudContainer, adminHudContainer, verificationHudContainer, userProfileHudContainer];
      hudElements.forEach(element => {
        element.style.maxHeight = `${maxHeight}px`;
        element.style.width = currentWidth <= 414 ? '90vw' : currentWidth <= 768 ? '80vw' : '30vw';
        element.style.maxWidth = currentWidth <= 414 ? 'none' : currentWidth <= 768 ? '320px' : '300px';
      });
      console.log('HUDs adjusted: MaxHeight:', maxHeight, 'Width:', reportBox.style.width, 'Screen:', currentWidth, 'x', currentHeight);
    }
    function updateCompass() {
      const compass = document.getElementById('compass');
      if (compass && map) {
        const mapHeading = navState.mapOrientation === 'north-up' ? 0 : map.getHeading() || navState.currentHeading;
        compass.style.transform = `rotate(${-mapHeading}deg)`;
        console.log('Compass updated:', { mapHeading, rotation: -mapHeading });
      }
    }
    async function requestDeviceOrientationPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission === 'granted') {
            console.log('Device orientation permission granted');
            setupDeviceOrientation();
          } else {
            console.warn('Device orientation permission denied');
            showToast('Compass access denied. Using GPS heading.');
          }
        } catch (error) {
          console.error('Error requesting device orientation permission:', error);
          showToast('Failed to access compass. Using GPS heading.');
        }
      } else {
        setupDeviceOrientation();
      }
    }
    function setupDeviceOrientation() {
      window.addEventListener('deviceorientation', (event) => {
        if (event.alpha !== null) {
          compassHeading = 360 - event.alpha;
          console.log('Raw compass heading (alpha):', event.alpha, 'Adjusted:', compassHeading);
          checkHeadingVariance(compassHeading);
        } else {
          console.warn('Device orientation alpha is null');
          needsCalibration = true;
        }
      });
    }
    function checkHeadingVariance(newHeading) {
      if (headingHistory.length > 2) {
        const variance = Math.max(...headingHistory) - Math.min(...headingHistory);
        needsCalibration = variance > CONFIG.HEADING_VARIANCE_THRESHOLD;
        console.log('Heading variance checked:', { variance, threshold: CONFIG.HEADING_VARIANCE_THRESHOLD, needsCalibration });
      }
    }
    function recalibrateCompass() {
      needsCalibration = false;
      headingHistory = [];
      showToast('Move phone in a figure-eight pattern to calibrate compass.');
      console.log('Calibration triggered manually');
      setTimeout(() => {
        console.log('Calibration completed, resetting heading history');
      }, 5000);
    }
    /**
     * @param {google.maps.LatLng} userLatLng
     * @param {Array<google.maps.LatLng>} path
     * @param {number} heading
     * @param {number} speed
     * @returns {{point: {lat: number, lng: number}, index: number}}
     */
    function findClosestRoutePoint(currentPos, path, heading, speed) {
      if (!path || path.length < 2) return { point: currentPos, index: 0 };
      const currentLatLng = new google.maps.LatLng(currentPos);
      let bestPoint = currentPos;
      let bestScore = -Infinity;
      let closestIndex = 0;
      if (!routeSpatialIndex) routeSpatialIndex = buildRouteIndex(path);
      const gridSize = 0.001;
      const candidates = [];
      // Collect candidates from nearby grid cells
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const nearbyKey = `${Math.floor(currentPos.lat / gridSize) + dx},${Math.floor(currentPos.lng / gridSize) + dy}`;
          if (routeSpatialIndex.has(nearbyKey)) {
            candidates.push(...routeSpatialIndex.get(nearbyKey));
          }
        }
      }
      // Search candidates with early exit for very close matches
      for (const { point, idx } of candidates) {
        const distance = google.maps.geometry.spherical.computeDistanceBetween(currentLatLng, point);
        if (distance <= CONFIG.SNAP_BUFFER) {
          const nextPoint = idx < path.length - 1 ? path[idx + 1] : point;
          const pointHeading = getCachedHeading(point, nextPoint);
          const headingDiff = Math.abs(((pointHeading - heading + 180) % 360) - 180);
          const proximityScore = (CONFIG.SNAP_BUFFER - distance) / CONFIG.SNAP_BUFFER * 0.6;
          const headingScore = (1 - headingDiff / 180) * 0.3;
          const speedScore = speed > 20 ? 0.1 : speed < 10 ? 0.05 : 0;
          const contextScore = idx < path.length - 1 ? 0.1 : 0.05;
          const totalScore = proximityScore + headingScore + speedScore + contextScore;
          if (totalScore > bestScore) {
            bestScore = totalScore;
            bestPoint = { lat: point.lat(), lng: point.lng() };
            closestIndex = idx;
          }
          // Early exit for very close matches
          if (distance < 20) break;
        }
      }
      console.log('Map-matching score:', { point: bestPoint, score: bestScore, closestIndex });
      return { point: bestPoint, index: closestIndex };
    }
    function computeHeadingFromMovement() {
      if (!navState.previousUserLocation || !navState.userLocation) return navState.currentHeading || 0;
      return google.maps.geometry.spherical.computeHeading(
        new google.maps.LatLng(navState.previousUserLocation),
        new google.maps.LatLng(navState.userLocation)
      );
    }
    function smoothHeading(newHeading, source = 'unknown', speed = 0, isSnapped = false) {
      console.log('smoothHeading called:', { newHeading, source, speed, isSnapped });
      if (isNaN(newHeading) || newHeading === null || speed <= CONFIG.STATIONARY_SPEED_THRESHOLD) {
        console.log('Stationary or invalid heading used:', { heading: navState.lastValidHeading, source: 'lastValid', speed });
        return navState.lastValidHeading;
      }
      const now = Date.now();
      const headingVariance = Math.abs(navState.currentHeading - navState.lastValidHeading);
      if (speed > CONFIG.STATIONARY_SPEED_THRESHOLD &&
          headingVariance < 0.1 &&
          now - lastHeadingUpdate > 5000) {
        console.warn('Heading stale while moving, forcing recalculation');
        return computeHeadingFromMovement();
      }
      const headingDiff = Math.abs(((newHeading - lastStableHeading + 180) % 360) - 180);
      if (headingDiff < CONFIG.MIN_HEADING_CHANGE) {
        console.log('Ignoring small heading change:', { newHeading, lastStableHeading, headingDiff });
        return lastStableHeading;
      }
      // Add heading momentum for highway driving
      const isHighSpeed = speed > 15; // ~35 mph
      if (isHighSpeed && headingHistory.length > 2) {
        const recentHeadings = headingHistory.slice(-3).map(h => h.heading);
        const variance = Math.max(...recentHeadings) - Math.min(...recentHeadings);
        // Reduce sensitivity during stable highway driving
        if (variance < 10) {
          const headingDiff = Math.abs(((newHeading - lastStableHeading + 180) % 360) - 180);
          if (headingDiff < 15) {
            console.log('Ignoring small heading change during stable highway driving');
            return lastStableHeading;
          }
        }
      }
      // Use weighted average instead of simple average
      headingHistory.push({ heading: newHeading, weight: speed > 5 ? 1.0 : 0.5 });
      if (headingHistory.length > CONFIG.HEADING_SMOOTHING_WINDOW) {
        headingHistory = headingHistory.slice(-CONFIG.HEADING_SMOOTHING_WINDOW);
      }
      let totalWeight = 0;
      let weightedSum = 0;
      headingHistory.forEach(entry => {
        weightedSum += entry.heading * entry.weight;
        totalWeight += entry.weight;
      });
      // Add minimum weight floor to prevent near-zero divisions
      const minTotalWeight = headingHistory.length * 0.3; // At least 0.3 per entry
      if (totalWeight < minTotalWeight) {
        totalWeight = minTotalWeight;
      }
      let smoothedHeading = (weightedSum / totalWeight) % 360;
      const gpsWeight = speed > CONFIG.STATIONARY_SPEED_THRESHOLD ? 0.8 : 0.2;
      const compassWeight = needsCalibration ? 0.1 : 0.4;
      const polylineWeight = isSnapped ? 0.8 : needsCalibration ? 0.2 : 0.2;
      for (let i = 0; i < headingHistory.length; i++) {
        let delta = headingHistory[i].heading - smoothedHeading;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        smoothedHeading += (source === 'gps' ? gpsWeight : source === 'compass' ? compassWeight : polylineWeight) * delta / headingHistory.length;
      }
      smoothedHeading = smoothedHeading % 360;
      if (smoothedHeading < 0) smoothedHeading += 360;
      navState.lastValidHeading = smoothedHeading;
      lastStableHeading = smoothedHeading;
      lastHeadingUpdate = now;
      console.log('Heading stabilized:', { newHeading, smoothed: smoothedHeading, source, speed, gpsWeight, compassWeight, polylineWeight, isSnapped });
      return smoothedHeading;
    }
    function smoothPosition(rawPos) {
      positionHistory.push(rawPos);
      // FIXED: Cap array size
      if (positionHistory.length > CONFIG.POSITION_HISTORY_WINDOW) {
        positionHistory = positionHistory.slice(-CONFIG.POSITION_HISTORY_WINDOW);
      }
      const avgLat = positionHistory.reduce((sum, p) => sum + p.lat, 0) / positionHistory.length;
      const avgLng = positionHistory.reduce((sum, p) => sum + p.lng, 0) / positionHistory.length;
      const smoothedPos = { lat: avgLat, lng: avgLng };
      console.log('Position smoothed:', { raw: rawPos, smoothed: smoothedPos, historyLength: positionHistory.length });
      return smoothedPos;
    }
    function predictPosition(currentPos, heading, speed, ms) {
      const distance = (speed * ms) / 1000;
      return google.maps.geometry.spherical.computeOffset(
        new google.maps.LatLng(currentPos),
        distance,
        heading
      );
    }
    // Reverse geocode via backend proxy
    async function reverseGeocode(lat, lng) {
      // Validate coordinates
      if (isNaN(lat) || isNaN(lng) ||
          lat < -90 || lat > 90 ||
          lng < -180 || lng > 180) {
        throw new Error('Invalid coordinates');
      }
      const token = TokenManager.get();
      if (!TokenManager.isValid()) {
        throw new Error('Invalid token');
      }
      const response = await fetchWithRetry('/api/geocode', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          lat: parseFloat(lat.toFixed(6)), // Limit precision
          lng: parseFloat(lng.toFixed(6))
        })
      });
      if (!response.ok) {
        throw new Error('Geocoding failed');
      }
      return response.json();
    }
    function loadGoogleMaps() {
  document.getElementById('map-loading').style.display = 'block';
  console.log('Loading Google Maps API...');
  const script = document.createElement('script');
  script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyBSW8iQAE1AjjouEu4df-Cvq1ceUMLBit4&map_ids=${mapId}&v=beta&callback=initMap&libraries=places,geometry,marker,routes&loading=async`;
  script.async = true;
  script.defer = true;
  script.onerror = () => {
    console.error('Failed to load Google Maps script');
    document.getElementById('map-loading').style.display = 'none';
    showToast('Failed to load map. Retrying in 5 seconds...');
    setTimeout(loadGoogleMaps, 5000); // Retry with longer delay
  };
  script.onload = () => {
    console.log('Google Maps script loaded successfully');
    document.getElementById('map-loading').style.display = 'none';
  };
  document.head.appendChild(script);
}
    window.initMap = function() {
  console.log('initMap called');
  // CRITICAL: Verify all required libraries loaded
  if (!window.google || !google.maps || !google.maps.Map ||
      !google.maps.marker || !google.maps.places ||
      !google.maps.routes || !google.maps.geometry) {
    console.error('Google Maps libraries not fully loaded, retrying in 2s...');
    setTimeout(() => {
      if (window.google?.maps?.Map) {
        initializeMap(); // Retry once
      } else {
        showToast('Map loading failed. Please refresh the page.');
      }
    }, 2000);
    return;
  }
  initializeMap();
};
    function initializeMap() {
      console.log('Initializing map...');
      // Add validation check
      if (!document.getElementById('map')) {
        console.error('Map container element not found!');
        return;
      }
      if (!google || !google.maps) {
        console.error('Google Maps not loaded yet, retrying...');
        setTimeout(initializeMap, 500);
        return;
      }
      if (map) {
        console.warn('Map already initialized, skipping to prevent multiple instances');
        return;
      }
      try {
        map = new google.maps.Map(document.getElementById('map'), {
          center: navState.userLocation,
          zoom: navState.navigationZoom,
          mapId: mapId,
          tilt: 45,
          heading: navState.mapOrientation === 'heading-up' ? navState.currentHeading : 0,
          disableDefaultUI: true,
          gestureHandling: 'cooperative',
          mapTypeControl: false,
          streetViewControl: false,
          clickableIcons: false,
          zoomControl: false,
          disableDoubleClickZoom: true
        });
        map.setOptions({ styles: mapSkins[mapSkin] });
        console.log('Map initialized:', { center: navState.userLocation, zoom: navState.navigationZoom, mapId });
        map.setMapTypeId(navState.mapType);
        trafficLayer = new google.maps.TrafficLayer({ map: navState.showTraffic ? map : null });
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
          map: null,
          suppressMarkers: true,
          preserveViewport: true,
          polylineOptions: {
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            zIndex: 5
          }
        });
        alternativeRenderer = new google.maps.DirectionsRenderer({
          map: null,
          suppressMarkers: true,
          polylineOptions: {
            strokeColor: navState.altRouteColor,
            strokeOpacity: 0,
            zIndex: 10,
            icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 }, offset: '0', repeat: '12px' }]
          }
        });
        const markerElement = document.createElement('div');
        markerElement.style.borderLeft = '15px solid transparent';
        markerElement.style.borderRight = '15px solid transparent';
        markerElement.style.borderBottom = '30px solid #4285F4';
        markerElement.style.width = '0';
        markerElement.style.height = '0';
        markerElement.style.boxShadow = '0 0 5px rgba(0,0,0,0.5)';
        markerElement.style.transformOrigin = 'center 75%';
        userMarker = new google.maps.marker.AdvancedMarkerElement({
          map: map,
          position: navState.userLocation,
          content: markerElement,
          title: 'Your Location'
        });
        google.maps.event.addListener(userMarker, 'position_changed', () => {
          const pos = userMarker.position;
          if (pos && navState.isFollowing && navState.isNavigating) {
            const { zoom, tilt, turnHeading } = getDynamicZoom(pos, 0);
            const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
            const lookaheadPoint = getLookaheadPoint(pos, heading, 0);
            requestAnimationFrame(() => {
              map.panTo(lookaheadPoint);
              map.setZoom(zoom);
              updateMapHeading(heading);
              map.setTilt(tilt);
              userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
              console.log('User marker position changed, map panned:', { lat: pos.lat, lng: pos.lng, heading, zoom, tilt, orientation: navState.mapOrientation });
              updateCompass();
            });
          }
        });
        if (showTrafficCameras) {
          const trafficCamImage = 'https://i.postimg.cc/jjN0JrPZ/New-Project-5.png';
          const trafficCamLocations = [
            { coords: { lat: 33.0921, lng: -83.2246 }, title: 'Traffic Camera - Baldwin High School' },
            { coords: { lat: 33.0785, lng: -83.2251 }, title: 'Traffic Camera - The Kidd Center' },
            { coords: { lat: 33.1087, lng: -83.2168 }, title: 'Traffic Camera - John Milledge Academy' }
          ];
          trafficCamLocations.forEach(location => {
            fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(location.title.split(' - ')[1] + ', Milledgeville, GA, USA')}`)
              .then(response => response.json())
              .then(data => {
                let position = location.coords;
                if (data.status === 'OK' && data.results[0]) {
                  position = data.results[0].geometry.location;
                  console.log(`Geocoding successful for ${location.title}:`, position);
                } else {
                  console.warn(`Geocoding failed for ${location.title}, using fallback coords:`, position);
                  showToast(`Using fallback coordinates for ${location.title}.`);
                }
                const markerImage = document.createElement('img');
                markerImage.src = trafficCamImage;
                markerImage.className = 'traffic-cam-marker';
                new google.maps.marker.AdvancedMarkerElement({
                  map: map,
                  position: position,
                  content: markerImage,
                  title: location.title
                });
                cameraPositions.push(position);
                console.log(`Traffic camera marker placed at ${location.title}:`, position);
              })
              .catch(error => {
                console.error(`Error geocoding ${location.title}:`, error);
                const markerImage = document.createElement('img');
                markerImage.src = trafficCamImage;
                markerImage.className = 'traffic-cam-marker';
                new google.maps.marker.AdvancedMarkerElement({
                  map: map,
                  position: location.coords,
                  content: markerImage,
                  title: location.title
                });
                cameraPositions.push(location.coords);
                showToast(`Error geocoding ${location.title}, using fallback coordinates.`);
                console.log(`Traffic camera marker placed at ${location.title} using fallback:`, location.coords);
              });
          });
        }
        const input = document.getElementById('search-input');
        const autocomplete = new google.maps.places.Autocomplete(input, { fields: ['geometry', 'formatted_address'] });
        autocomplete.bindTo('bounds', map);
        console.log('Autocomplete initialized');
        autocomplete.addListener('place_changed', () => {
          const place = autocomplete.getPlace();
          if (place && place.geometry && place.geometry.location) {
            navState.destination = {
              lat: place.geometry.location.lat(),
              lng: place.geometry.location.lng()
            };
            console.log('Destination selected:', navState.destination);
            if (destMarker) destMarker.map = null;
            const destMarkerElement = document.createElement('div');
            destMarkerElement.style.width = '20px';
            destMarkerElement.style.height = '20px';
            destMarkerElement.style.backgroundColor = 'green';
            destMarkerElement.style.borderRadius = '50%';
            destMarkerElement.style.border = '2px solid white';
            destMarker = new google.maps.marker.AdvancedMarkerElement({
              map: map,
              position: navState.destination,
              content: destMarkerElement,
              title: 'Destination'
            });
            calculateAndDisplayRoute(navState.userLocation, navState.destination, () => {
              console.log('Route preview displayed:', { destination: navState.destination });
              document.getElementById('start-button').style.display = 'block';
              document.getElementById('simulate-position-button').style.display = 'block';
            });
          } else {
            console.error('No location for selected place:', place);
            showToast('Invalid address selected. Please try again.');
          }
        });
        document.getElementById('traffic-layer-toggle').checked = navState.showTraffic;
        document.getElementById('main-route-color').value = navState.mainRouteColor;
        document.getElementById('alt-route-color').value = navState.altRouteColor;
        document.getElementById('map-type').value = navState.mapType;
        document.getElementById('map-skin').value = mapSkin;
        document.getElementById('map-orientation').value = navState.mapOrientation;
        document.getElementById('auto-recenter-toggle').checked = navState.isFollowing;
        document.getElementById('traffic-camera-toggle').checked = showTrafficCameras;
        document.getElementById('push-notifications-toggle').checked = pushNotificationsEnabled;
        document.getElementById('voice-assistant-toggle').checked = voiceAssistantEnabled;
        document.getElementById('show-tooltips-toggle').checked = showTooltips;
        document.getElementById('hazard-alert-distance').value = hazardAlertDistance;
        document.getElementById('hazard-distance-value').textContent = `${hazardAlertDistance} miles`;
        document.getElementById('camera-alert-distance').value = cameraAlertDistance;
        document.getElementById('camera-distance-value').textContent = `${cameraAlertDistance} miles`;
        document.getElementById('use-default-distances').checked = navState.useDefaultDistances;
        document.getElementById('high-contrast-toggle').checked = highContrastMode;
        if (highContrastMode) document.body.classList.add('high-contrast');
        document.getElementById('alert-radius').value = navState.alertRadius;
        document.getElementById('alert-radius-value').textContent = `${navState.alertRadius} miles`;
        document.getElementById('filter-police').checked = navState.alertFilters.police;
        document.getElementById('filter-crash').checked = navState.alertFilters.crash;
        document.getElementById('filter-construction').checked = navState.alertFilters.construction;
        document.getElementById('traffic-forecast-toggle').checked = navState.trafficForecast;
        document.getElementById('multi-stop-toggle').checked = navState.multiStop;
        document.getElementById('ev-charging-toggle').checked = navState.evCharging;
        document.getElementById('route-preset').value = navState.routePreset;
        fetchAndDisplayMarkers(map, navState.userLocation);
        const ownId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
        fetchProfile(ownId, true).then(populateAccountProfile);
        loadOfflineRegions();
        loadFamilyMembers();
        setupEventListeners();
        setupTooltips();
        updateCompass();
        checkURLForAlert();
        setupPageVisibility();
        if (isAdmin) {
          document.getElementById('admin-button').style.display = 'flex';
        }
        if (voiceAssistantEnabled) {
          setTimeout(startWakeWordDetection, 1000); // Delay to ensure permissions
        }
        // FIXED: Log ProgrammaticUpdateManager state
        setInterval(() => {
          if (ProgrammaticUpdateManager.isActive) {
            const now = Date.now();
            if (now - ProgrammaticUpdateManager._startTime > 5000) { // Stuck for 5s
              console.error('ProgrammaticUpdateManager stuck, force resetting');
              ProgrammaticUpdateManager._isUpdating = false;
              ProgrammaticUpdateManager._callbacks = [];
            }
          }
        }, 5000);
        // Viewport-based marker culling
        const debouncedUpdateVisibleMarkers = debounce(updateVisibleMarkers, 500);
        map.addListener('idle', debouncedUpdateVisibleMarkers);
        console.log('Map initialization complete');
      } catch (error) {
        console.error('Map initialization error:', error);
        showToast('Failed to initialize map. Retrying...');
        setTimeout(initializeMap, 2000);
      }
    }
    function updateVisibleMarkers() {
      if (!map) return;
      const bounds = map.getBounds();
      if (!bounds) return;
      const visible = new Set();
      markers.forEach((marker, id) => {
        const pos = marker.position;
        if (bounds.contains(pos)) {
          if (!marker.map) marker.map = map;
          visible.add(id);
        } else {
          if (marker.map) marker.map = null;
        }
      });
      console.log(`Visible markers: ${visible.size}/${markers.size}`);
    }
    function updateMapHeading(targetHeading) {
  if (navState.mapOrientation !== 'heading-up') return;
  // Cancel existing tween
  if (currentHeadingTween) {
    currentHeadingTween.stop();
    TWEEN.remove(currentHeadingTween);
    currentHeadingTween = null;
  }
  const currentHeading = map.getHeading() || 0;
  const delta = normalizeHeadingDelta(currentHeading, targetHeading);
  if (Math.abs(delta) < 3) return; // Skip tiny changes
  const tweenObj = { heading: currentHeading };
  currentHeadingTween = new TWEEN.Tween(tweenObj)
    .to({ heading: currentHeading + delta }, 300)
    .easing(TWEEN.Easing.Quadratic.Out)
    .onUpdate(() => map.setHeading(tweenObj.heading))
    .onComplete(() => {
      currentHeadingTween = null;
      TWEEN.remove(currentHeadingTween); // â† Ensure cleanup
    })
    .onStop(() => { // â† Handle manual stops
      currentHeadingTween = null;
      TWEEN.remove(currentHeadingTween);
    })
    .start();
  // Safety timeout - force cleanup after 2 seconds (not 5)
  setTimeout(() => {
    if (currentHeadingTween) {
      currentHeadingTween.stop();
      TWEEN.remove(currentHeadingTween);
      currentHeadingTween = null;
    }
  }, 2000);
}
    const debouncedCameraUpdate = debounce(updateNavigationCamera, 100);
    function shouldUpdateCameraView(newPos, newHeading, timeSinceLastUpdate) {
      if (!navState.isFollowing || !navState.isNavigating) return false;
      // Always update if significant time has passed
      if (timeSinceLastUpdate > 500) return true;
      // Update if moved more than 3 meters
      if (lastCameraPosition) {
        const distance = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(lastCameraPosition),
          new google.maps.LatLng(newPos)
        );
        if (distance > 3) return true;
      }
      // Update if heading changed > 5 degrees (reduced from higher thresholds)
      if (Math.abs(newHeading - lastHeading) > 5) return true;
      return false;
    }
    function updateNavigationCamera(actualPos, predictedPos, heading, speed) {
      if (!shouldUpdateCameraView(actualPos, heading, Date.now() - navState.lastCameraUpdateTime)) {
        return;
      }
      const { zoom, tilt, turnHeading } = getDynamicZoom(actualPos, speed);
      const finalHeading = navState.mapOrientation === 'north-up' ? 0 : (turnHeading || heading);
      const lookaheadPoint = new google.maps.LatLng(predictedPos);
      // All updates in ONE tween to prevent desync
      const tweenTimeoutId = setTimeout(() => {
        if (ProgrammaticUpdateManager.isActive) {
          currentHeadingTween?.stop();
          ProgrammaticUpdateManager.end();
          console.error('Camera tween timeout, force cleanup');
        }
      }, 5000);
      ProgrammaticUpdateManager.start();
      new TWEEN.Tween({
        lat: map.getCenter().lat(),
        lng: map.getCenter().lng(),
        heading: map.getHeading() || 0,
        zoom: map.getZoom()
      })
      .to({
        lat: lookaheadPoint.lat(),
        lng: lookaheadPoint.lng(),
        heading: finalHeading,
        zoom: zoom
      }, 300)
      .easing(TWEEN.Easing.Quadratic.Out)
      .onUpdate(obj => {
        map.setCenter({ lat: obj.lat, lng: obj.lng });
        map.setHeading(obj.heading);
        map.setZoom(obj.zoom);
        // Remove userMarker sync here
      })
      .onComplete(() => {
        clearTimeout(tweenTimeoutId); // â† Add this
        map.setTilt(tilt);
        userMarker.position = actualPos; // â† Sync ONCE at end
        ensureMarkerInView(actualPos);
        ProgrammaticUpdateManager.end();
      })
      .start();
      lastCameraPosition = actualPos;
      lastHeading = finalHeading;
      navState.lastCameraUpdateTime = Date.now();
    }
    function getDynamicZoom(currentPos, speed) {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) {
        return { zoom: navState.navigationZoom, tilt: 45, turnHeading: null };
      }
      const path = navState.currentRoute.routes[0].overview_path;
      let closestPoint = null;
      let minDistance = Infinity;
      let closestIndex = 0;
      const currentLatLng = new google.maps.LatLng(currentPos);
      path.forEach((point, index) => {
        const distance = google.maps.geometry.spherical.computeDistanceBetween(currentLatLng, point);
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = point;
          closestIndex = index;
        }
      });
      let currentStep = null;
      let nextStep = null;
      const legs = navState.currentRoute.routes[0].legs[0];
      for (let i = 0; i < legs.steps.length; i++) {
        const stepPath = legs.steps[i].path;
        if (stepPath.some(pt => google.maps.geometry.spherical.computeDistanceBetween(pt, closestPoint) < 20)) {
          currentStep = legs.steps[i];
          nextStep = legs.steps[i + 1] || null;
          break;
        }
      }
      let zoom = CONFIG.STRAIGHT_ZOOM;
      let tilt = 45;
      let turnHeading = null;
      if (nextStep && nextStep.maneuver && navState.mapOrientation === 'heading-up') {
        const distanceToTurn = google.maps.geometry.spherical.computeDistanceBetween(currentLatLng, new google.maps.LatLng(nextStep.start_location));
        if (distanceToTurn < CONFIG.TURN_THRESHOLD) {
          zoom = CONFIG.TURN_ZOOM;
          tilt = 60;
          const turnPoint = new google.maps.LatLng(nextStep.start_location);
          turnHeading = google.maps.geometry.spherical.computeHeading(currentLatLng, turnPoint);
          console.log('Turn detected:', { distanceToTurn, turnHeading });
        }
      }
      const speedMph = speed ? speed * 2.23694 : 0;
      if (speedMph > 40) {
        zoom -= 0.5;
      } else if (speedMph < 10 && speedMph > 0) {
        zoom += 0.5;
      }
      if (closestIndex < path.length - 1 && !turnHeading) {
        turnHeading = google.maps.geometry.spherical.computeHeading(currentLatLng, path[closestIndex + 1]);
      }
      return { zoom: Math.min(CONFIG.MAX_ZOOM, Math.max(CONFIG.MIN_ZOOM, zoom)), tilt, turnHeading };
    }
    function getLookaheadPoint(currentPos, heading, distance = 50) {
      return google.maps.geometry.spherical.computeOffset(
        new google.maps.LatLng(currentPos),
        distance,
        heading
      );
    }
    function loadOfflineRegions() {
      const list = document.getElementById('offline-regions-list');
      list.innerHTML = '';
      navState.offlineRegions.forEach((region, index) => {
        const div = document.createElement('div');
        div.textContent = `Region ${index + 1}: ${region.bounds}`;
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => deleteOfflineRegion(index);
        div.appendChild(deleteBtn);
        list.appendChild(div);
      });
    }
    function deleteOfflineRegion(index) {
      navState.offlineRegions.splice(index, 1);
      localStorage.setItem('offlineRegions', JSON.stringify(navState.offlineRegions));
      loadOfflineRegions();
      showToast('Region deleted');
    }
    function loadFamilyMembers() {
      const list = document.getElementById('family-list');
      list.innerHTML = '';
      navState.familyMembers.forEach(member => {
        const div = document.createElement('div');
        div.className = 'family-member';
        div.innerHTML = `<span>${member.email}</span><button class="remove-family" onclick="removeFamilyMember('${member.email}')">Remove</button>`;
        list.appendChild(div);
      });
    }
    function removeFamilyMember(email) {
      navState.familyMembers = navState.familyMembers.filter(m => m.email !== email);
      localStorage.setItem('familyMembers', JSON.stringify(navState.familyMembers));
      loadFamilyMembers();
      showToast('Family member removed');
    }
    function checkURLForAlert() {
      const urlParams = new URLSearchParams(window.location.search);
      const alertId = urlParams.get('alertId');
      const lat = parseFloat(urlParams.get('lat'));
      const lng = parseFloat(urlParams.get('lng'));
      if (alertId && !isNaN(lat) && !isNaN(lng) && map) {
        const position = { lat, lng };
        map.setCenter(position);
        map.setZoom(15);
        console.log('Centered map on alert from URL:', { alertId, lat, lng });
        try {
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          console.log('âœ… URL cleaned:', cleanUrl);
        } catch (historyError) {
          console.warn('Could not clean URL:', historyError);
        }
        const token = TokenManager.get();
        fetchWithRetry(`/api/markers?lat=${lat}&lng=${lng}&maxDistance=100`, {
          headers: { 'Authorization': `Bearer ${token}` }
        })
          .then(response => response.json())
          .then(alerts => {
            const alert = alerts.find(a => a._id === alertId);
            if (alert) {
              const isTrafficCamera = alert.type === 'Traffic Camera';
              if (isTrafficCamera && !showTrafficCameras) return;
              const marker = new google.maps.marker.AdvancedMarkerElement({
                map,
                position: { lat: alert.location.coordinates[1], lng: alert.location.coordinates[0] },
                content: isTrafficCamera ? createTrafficCameraContent() : createAlertContent(),
                title: `${alert.type} Alert`
              });
              markers.set(alertId, marker);
              console.log('Alert marker placed from URL:', { alertId, position });
            }
          })
          .catch(error => {
            console.error('Error fetching alert for URL centering:', error);
            showToast('Failed to load alert details.');
          });
      } else {
        console.log('No valid URL alert parameters or map not initialized:', { alertId, lat, lng, map: !!map });
      }
    }
    function setupEventListeners() {
      console.log('Setting up event listeners...');
      document.getElementById('start-button').addEventListener('click', startGPS);
      document.getElementById('bottom-hud-stop').addEventListener('click', stopGPS);
      document.getElementById('simulate-position-button').addEventListener('click', () => {
        if (mockSimulationInterval) {
          clearInterval(mockSimulationInterval);
          mockSimulationInterval = null;
          document.getElementById('simulate-position-button').textContent = 'Simulate';
          console.log('Position simulation stopped');
          document.getElementById('hud-container').style.display = 'none';
          document.getElementById('bottom-hud-container').style.display = 'none';
          // FIXED: Reset lastCameraPosition after simulation
          lastCameraPosition = null;
          if (routePolyline) {
            routePolyline.setMap(null);
            routePolyline = null;
          }
          if (offRoadPolyline) {
            offRoadPolyline.setMap(null);
            offRoadPolyline = null;
          }
          directionsRenderer.setMap(map);
          navState.isNavigating = false;
          navState.isFollowing = false;
          localStorage.setItem('isFollowing', navState.isFollowing);
          sessionStorage.setItem('isFollowing', navState.isFollowing);
          map.setOptions({ gestureHandling: 'cooperative', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
          requestAnimationFrame(() => {
            map.setCenter(navState.userLocation);
            map.setZoom(navState.navigationZoom);
            map.setHeading(navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading);
            console.log('Simulation completed, map re-centered to user location');
          });
          return;
        }
        // FIXED: Set navigation flags for simulation
        navState.isNavigating = true;
        navState.isFollowing = true;
        lockNavigation();
        document.getElementById('hud-container').style.display = 'flex';
        document.getElementById('bottom-hud-container').style.display = 'flex';
        updateHUD(navState.currentRoute, navState.userLocation);
        updateBottomHUD(navState.currentRoute);
        startPositionSimulation();
        document.getElementById('simulate-position-button').textContent = 'Stop Simulation';
        console.log('Position simulation started with navigation flags');
      });
      document.getElementById('hazard-button').addEventListener('click', () => {
        if (navState.alertState === 'OFFERING_REROUTE') return;
        closeAllHuds();
        const reportBox = document.getElementById('report-box');
        const reportOptions = document.querySelector('.report-options');
        const confirmAlert = document.getElementById('confirm-alert');
        reportBox.classList.add('active');
        reportOptions.style.display = 'grid';
        confirmAlert.classList.remove('active');
        navState.alertState = 'IDLE';
        if (navState.isNavigating) {
          unlockNavigation();
          console.log('Map unlocked for manual report during navigation');
        }
        console.log('Hazard button clicked, report box opened in IDLE state');
      });
      document.getElementById('report-close').addEventListener('click', () => {
        cancelAlert();
        console.log('Report box closed');
      });
      document.getElementById('settings-button').addEventListener('click', () => {
        closeAllHuds();
        const settingsHudContainer = document.getElementById('settings-hud-container');
        settingsHudContainer.classList.add('active');
        console.log('Settings button clicked, settings HUD opened');
      });
      document.getElementById('settings-close').addEventListener('click', () => {
        closeHUD('settings-hud-container');
      });
      document.getElementById('current-alerts-button').addEventListener('click', () => {
        closeAllHuds();
        fetchCurrentAlerts();
        const alertsHudContainer = document.getElementById('alerts-hud-container');
        alertsHudContainer.classList.add('active');
        document.getElementById('information').style.display = 'block';
        console.log('Current alerts button clicked, alerts HUD opened');
      });
      document.getElementById('alerts-close').addEventListener('click', () => {
        closeHUD('alerts-hud-container');
      });
      document.getElementById('leaderboard-button').addEventListener('click', () => {
        closeAllHuds();
        fetchLeaderboard();
        const leaderboardHudContainer = document.getElementById('leaderboard-hud-container');
        leaderboardHudContainer.classList.add('active');
        console.log('Leaderboard button clicked, leaderboard HUD opened');
      });
      document.getElementById('leaderboard-close').addEventListener('click', () => {
        closeHUD('leaderboard-hud-container');
      });
      document.getElementById('admin-button').addEventListener('click', () => {
        window.location.href = 'admin.html';
      });
      document.getElementById('admin-close').addEventListener('click', () => {
        closeHUD('admin-hud-container');
      });
      document.querySelectorAll('.admin-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.admin-tab-content').forEach(c => c.style.display = 'none');
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).style.display = 'block';
          if (tab.dataset.tab === 'activity' && selectedUserId) {
            loadUserActivity(selectedUserId);
          }
        });
      });
      document.getElementById('search-users-btn').addEventListener('click', () => {
        const query = document.getElementById('user-search').value;
        fetchUsers(query);
      });
      document.getElementById('show-all-users-btn').addEventListener('click', () => loadAllUsers());
      document.getElementById('load-activity-btn').addEventListener('click', () => {
        const query = document.getElementById('activity-user-search').value;
        if (query) {
          fetchUserForActivity(query);
        }
      });
      document.getElementById('voice-button').addEventListener('click', () => {
  if (wakeWordRecognizer) {
    // Stop if running
    stopWakeWordDetection();
    showToast('Voice assistant stopped');
  } else {
    // Start if not running
    startWakeWordDetection();
  }
});
      document.getElementById('share-button').addEventListener('click', shareRoute);
      document.getElementById('recalibrate-compass-button').addEventListener('click', () => {
        recalibrateCompass();
        console.log('Recalibrate Compass button clicked');
      });
      document.getElementById('push-notifications-toggle').addEventListener('change', async (e) => {
        pushNotificationsEnabled = e.target.checked;
        localStorage.setItem('pushNotificationsEnabled', pushNotificationsEnabled);
        sessionStorage.setItem('pushNotificationsEnabled', pushNotificationsEnabled);
        console.log('Push notifications toggled:', pushNotificationsEnabled);
        if (pushNotificationsEnabled) {
          await requestPushPermission();
        } else {
          await unsubscribeFromPush();
        }
      });
      document.getElementById('show-tooltips-toggle').addEventListener('change', (e) => {
        showTooltips = e.target.checked;
        localStorage.setItem('showTooltips', showTooltips);
        sessionStorage.setItem('showTooltips', showTooltips);
        console.log('Tooltips toggled:', showTooltips);
        if (!showTooltips) hideTooltip();
      });
      document.getElementById('voice-assistant-toggle').addEventListener('change', (e) => {
        voiceAssistantEnabled = e.target.checked;
        localStorage.setItem('voiceAssistantEnabled', voiceAssistantEnabled);
        if (voiceAssistantEnabled) {
          startWakeWordDetection();
        } else {
          stopWakeWordDetection();
        }
        console.log('Voice assistant toggled:', voiceAssistantEnabled);
      });
      document.getElementById('map-skin').addEventListener('change', (e) => {
        mapSkin = e.target.value;
        localStorage.setItem('mapSkin', mapSkin);
        sessionStorage.setItem('mapSkin', mapSkin);
        if (map) {
          map.setOptions({ styles: mapSkins[mapSkin] });
        }
        console.log('Map skin changed to:', mapSkin);
      });
      document.getElementById('alert-radius').addEventListener('input', (e) => {
        navState.alertRadius = parseInt(e.target.value);
        localStorage.setItem('alertRadius', navState.alertRadius);
        document.getElementById('alert-radius-value').textContent = `${navState.alertRadius} miles`;
        console.log('Alert radius set to:', navState.alertRadius);
      });
      document.getElementById('filter-police').addEventListener('change', (e) => {
        navState.alertFilters.police = e.target.checked;
        localStorage.setItem('alertFilters', JSON.stringify(navState.alertFilters));
      });
      document.getElementById('filter-crash').addEventListener('change', (e) => {
        navState.alertFilters.crash = e.target.checked;
        localStorage.setItem('alertFilters', JSON.stringify(navState.alertFilters));
      });
      document.getElementById('filter-construction').addEventListener('change', (e) => {
        navState.alertFilters.construction = e.target.checked;
        localStorage.setItem('alertFilters', JSON.stringify(navState.alertFilters));
      });
      document.getElementById('traffic-forecast-toggle').addEventListener('change', (e) => {
        navState.trafficForecast = e.target.checked;
        localStorage.setItem('trafficForecast', navState.trafficForecast);
        console.log('Traffic forecast toggled:', navState.trafficForecast);
      });
      document.getElementById('multi-stop-toggle').addEventListener('change', (e) => {
        navState.multiStop = e.target.checked;
        localStorage.setItem('multiStop', navState.multiStop);
        document.getElementById('multi-stop-inputs').style.display = navState.multiStop ? 'flex' : 'none';
        console.log('Multi-stop toggled:', navState.multiStop);
      });
      document.getElementById('ev-charging-toggle').addEventListener('change', (e) => {
        navState.evCharging = e.target.checked;
        localStorage.setItem('evCharging', navState.evCharging);
        console.log('EV charging toggled:', navState.evCharging);
      });
      document.getElementById('route-preset').addEventListener('change', (e) => {
        navState.routePreset = e.target.value;
        localStorage.setItem('routePreset', navState.routePreset);
        if (navState.routePreset === 'avoid-toll') navState.avoidTolls = true;
        if (navState.routePreset === 'scenic') navState.avoidHighways = true;
        console.log('Route preset set to:', navState.routePreset);
      });
      document.getElementById('offline-download-btn').addEventListener('click', () => {
        if (map) {
          const bounds = map.getBounds();
          const region = { bounds: bounds.toJSON(), name: `Region ${navState.offlineRegions.length + 1}`, timestamp: new Date().toISOString() };
          navState.offlineRegions.push(region);
          localStorage.setItem('offlineRegions', JSON.stringify(navState.offlineRegions));
          navigator.serviceWorker.controller?.postMessage({ type: 'CACHE_REGION', region });
          loadOfflineRegions();
          showToast('Region downloaded for offline use');
          console.log('Offline region downloaded:', region);
        }
      });
      document.getElementById('add-family-btn').addEventListener('click', () => {
        const email = document.getElementById('add-family-input').value.trim();
        if (email && navState.familyMembers.length < 5) {
          navState.familyMembers.push({ email });
          localStorage.setItem('familyMembers', JSON.stringify(navState.familyMembers));
          loadFamilyMembers();
          document.getElementById('add-family-input').value = '';
          showToast('Family member added');
        } else {
          showToast('Max 5 members or invalid email');
        }
      });
      document.getElementById('share-route-btn').addEventListener('click', () => {
        if (navState.currentRoute) {
          const shareData = { route: navState.currentRoute, family: navState.familyMembers };
          const shareUrl = `${window.location.href}?familyShare=${encodeURIComponent(JSON.stringify(shareData))}`;
          if (navigator.share) {
            navigator.share({ title: 'Share Route', url: shareUrl });
          } else {
            navigator.clipboard.writeText(shareUrl);
            showToast('Route shared via clipboard');
          }
          console.log('Route shared with family:', shareUrl);
        }
      });
      document.querySelectorAll('.report-button').forEach(button => {
        button.addEventListener('click', async () => {
          if (navState.alertState === 'IDLE') {
            const alertType = button.getAttribute('data-alert-type');
            console.log('Report button clicked:', { alertType });
            if (navState.alertFilters[alertType.toLowerCase()] === false) {
              showToast(`Filter disabled for ${alertType}`);
              return;
            }
            if (alertType === 'Manual Report' || alertType === 'Manual Traffic Camera') {
              const reportBox = document.getElementById('report-box');
              reportBox.classList.remove('active');
              navState.alertState = alertType === 'Manual Report' ? 'PLACING_ALERT' : 'PLACING_TRAFFIC_CAMERA';
              showToast(`Press a location on the map to place a ${alertType === 'Manual Report' ? 'hazard' : 'traffic camera'} alert.`);
              navState.mapClickListener = google.maps.event.addListener(map, 'click', (event) => {
                if (navState.alertState === 'PLACING_ALERT' || navState.alertState === 'PLACING_TRAFFIC_CAMERA') {
                  console.log('Map clicked for alert placement:', { lat: event.latLng.lat(), lng: event.latLng.lng() });
                  confirmAlertLocation(event.latLng, alertType === 'Manual Report' ? 'Manual Report' : 'Traffic Camera');
                }
              });
            } else {
              const location = new google.maps.LatLng(navState.userLocation);
              console.log('Placing alert at user location:', { alertType, location: navState.userLocation });
              confirmAlertLocation(location, alertType);
            }
          }
        });
      });
      document.getElementById('post-alert-button').addEventListener('click', postAlert);
      document.getElementById('cancel-alert-button').addEventListener('click', cancelAlert);
      document.getElementById('reroute-close').addEventListener('click', rejectReroute);
      document.getElementById('accept-reroute-button').addEventListener('click', acceptReroute);
      document.getElementById('reject-reroute-button').addEventListener('click', rejectReroute);
      document.getElementById('camera-close').addEventListener('click', dismissCameraAlert);
      document.getElementById('dismiss-camera-button').addEventListener('click', dismissCameraAlert);
      document.getElementById('arrival-close').addEventListener('click', endArrival);
      document.getElementById('arrival-ok-button').addEventListener('click', endArrival);
      document.getElementById('confirm-alert-btn').addEventListener('click', () => voteOnAlert(currentVerificationAlertId, 'up'));
      document.getElementById('dismiss-alert-btn').addEventListener('click', () => voteOnAlert(currentVerificationAlertId, 'down'));
      document.getElementById('verification-close').addEventListener('click', dismissVerificationHud);
      document.getElementById('user-profile-close').addEventListener('click', () => {
        document.getElementById('user-profile-hud-container').classList.remove('active');
      });
      // Add logout button event listener
      document.getElementById('logout-button').addEventListener('click', () => {
      console.log('Logout button clicked');
      TokenManager.clear();
      isAdmin = false;
      document.getElementById('admin-button').style.display = 'none';
      document.getElementById('auth-container').style.display = 'flex';
      document.getElementById('settings-hud-container').classList.remove('active');
      showToast('Logged out successfully');
      if (socket) {
        socket.disconnect();
        socket = null;
      }
      stopGPS();
      console.log('User logged out, auth container shown');
    });
      // Fixed drag listeners with distance-based confirmation
      let dragDistance = 0;
      map.addListener('dragstart', (e) => {
        if (ProgrammaticUpdateManager.isActive) return;
        if (!navState.isNavigating || !navState.isFollowing) return;
        dragStartPos = map.getCenter();
      });
      map.addListener('drag', () => {
        if (!dragStartPos || ProgrammaticUpdateManager.isActive) return;
        const currentPos = map.getCenter();
        const dragDistance = google.maps.geometry.spherical.computeDistanceBetween(
          dragStartPos, currentPos
        );
        // Only unlock after 20+ meter drag
        if (dragDistance > 20 && navState.isFollowing) {
          unlockNavigation();
          showToast('Auto-follow disabled. Tap recenter to resume.');
        }
      });
      map.addListener('dragend', () => {
        dragStartPos = null;
        dragDistance = 0;
      });
      // Fixed zoom change detection
      map.addListener('zoom_changed', () => {
        if (ProgrammaticUpdateManager.isActive) {
          lastProgrammaticZoom = map.getZoom();
        }
      });
      map.addListener('heading_changed', () => {
        updateCompass();
      });
      document.getElementById('recenter-button').addEventListener('click', () => {
        if (navState.isNavigating) {
          lockNavigation();
          console.log('Recenter button clicked, locking navigation, camera auto-follow resumed');
        } else {
          recenterNonNavigation();
          console.log('Recenter button clicked, re-centered to user location (non-navigation)');
        }
      });
      document.getElementById('traffic-layer-toggle').addEventListener('change', (e) => {
        navState.showTraffic = e.target.checked;
        localStorage.setItem('showTraffic', navState.showTraffic);
        sessionStorage.setItem('showTraffic', navState.showTraffic);
        trafficLayer.setMap(navState.showTraffic ? map : null);
        console.log('Traffic layer toggled:', navState.showTraffic);
      });
      document.getElementById('main-route-color').addEventListener('change', (e) => {
        navState.mainRouteColor = e.target.value;
        localStorage.setItem('mainRouteColor', navState.mainRouteColor);
        sessionStorage.setItem('mainRouteColor', navState.mainRouteColor);
        if (routePolyline) {
          routePolyline.setOptions({
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            zIndex: 5
          });
        }
        directionsRenderer.setOptions({
          polylineOptions: {
            strokeColor: navState.mainRouteColor,
            strokeWeight: 6,
            strokeOpacity: 0.8,
            zIndex: 5
          }
        });
        console.log('Main route color changed to:', navState.mainRouteColor);
      });
      document.getElementById('alt-route-color').addEventListener('change', (e) => {
        navState.altRouteColor = e.target.value;
        localStorage.setItem('altRouteColor', navState.altRouteColor);
        sessionStorage.setItem('altRouteColor', navState.altRouteColor);
        alternativeRenderer.setOptions({
          polylineOptions: {
            strokeColor: navState.altRouteColor,
            strokeOpacity: 0,
            zIndex: 10,
            icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 }, offset: '0', repeat: '12px' }]
          }
        });
        if (navState.alternativeRoute) {
          alternativeRenderer.setDirections(navState.alternativeRoute);
        }
        console.log('Alternate route color changed to:', navState.altRouteColor);
      });
      document.getElementById('map-type').addEventListener('change', (e) => {
        navState.mapType = e.target.value;
        localStorage.setItem('mapType', navState.mapType);
        sessionStorage.setItem('mapType', navState.mapType);
        map.setMapTypeId(navState.mapType);
        console.log('Map type changed to:', navState.mapType);
      });
      document.getElementById('map-orientation').addEventListener('change', (e) => {
        navState.mapOrientation = e.target.value;
        localStorage.setItem('mapOrientation', navState.mapOrientation);
        sessionStorage.setItem('mapOrientation', navState.mapOrientation);
        console.log('Map orientation changed to:', navState.mapOrientation);
        if (navState.isNavigating && navState.isFollowing) {
          restoreNavigationView();
          updateCompass();
        }
      });
      document.getElementById('auto-recenter-toggle').addEventListener('change', (e) => {
        navState.isFollowing = e.target.checked;
        localStorage.setItem('isFollowing', navState.isFollowing);
        sessionStorage.setItem('isFollowing', navState.isFollowing);
        console.log('Auto-recenter toggled:', navState.isFollowing);
        if (navState.isFollowing && navState.isNavigating) {
          lockNavigation();
        } else if (navState.isNavigating) {
          unlockNavigation();
        }
      });
      document.getElementById('traffic-camera-toggle').addEventListener('change', (e) => {
        showTrafficCameras = e.target.checked;
        localStorage.setItem('showTrafficCameras', showTrafficCameras);
        sessionStorage.setItem('showTrafficCameras', showTrafficCameras);
        console.log('Traffic camera alerts toggled:', showTrafficCameras);
        cameraPositions = [];
        cameraAlertShown.clear();
        markers.forEach((marker, id) => {
          if (marker.title.includes('Traffic Camera') && !showTrafficCameras) {
            marker.setMap(null);
            markers.delete(id);
            console.log('Removed traffic camera marker due to toggle off:', id);
          }
        });
        fetchAndDisplayMarkers(map, navState.userLocation);
      });
      document.getElementById('high-contrast-toggle').addEventListener('change', (e) => {
        highContrastMode = e.target.checked;
        localStorage.setItem('highContrastMode', highContrastMode);
        sessionStorage.setItem('highContrastMode', highContrastMode);
        if (highContrastMode) {
          document.body.classList.add('high-contrast');
        } else {
          document.body.classList.remove('high-contrast');
        }
        console.log('High contrast mode toggled:', highContrastMode);
      });
      document.getElementById('hazard-alert-distance').addEventListener('change', (e) => {
        if (!navState.useDefaultDistances) {
          hazardAlertDistance = parseFloat(e.target.value);
          localStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          sessionStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          document.getElementById('hazard-distance-value').textContent = `${hazardAlertDistance} miles`;
          console.log('Hazard alert distance set to:', hazardAlertDistance, 'miles');
        }
      });
      document.getElementById('camera-alert-distance').addEventListener('change', (e) => {
        if (!navState.useDefaultDistances) {
          cameraAlertDistance = parseFloat(e.target.value);
          localStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          sessionStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          document.getElementById('camera-distance-value').textContent = `${cameraAlertDistance} miles`;
          console.log('Camera alert distance set to:', cameraAlertDistance, 'miles');
        }
      });
      document.getElementById('use-default-distances').addEventListener('change', (e) => {
        navState.useDefaultDistances = e.target.checked;
        localStorage.setItem('useDefaultDistances', navState.useDefaultDistances);
        sessionStorage.setItem('useDefaultDistances', navState.useDefaultDistances);
        if (navState.useDefaultDistances) {
          hazardAlertDistance = 2;
          cameraAlertDistance = 0.5;
          localStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          sessionStorage.setItem('hazardAlertDistance', hazardAlertDistance);
          localStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          sessionStorage.setItem('cameraAlertDistance', cameraAlertDistance);
          document.getElementById('hazard-alert-distance').value = hazardAlertDistance;
          document.getElementById('hazard-distance-value').textContent = `${hazardAlertDistance} miles`;
          document.getElementById('camera-alert-distance').value = cameraAlertDistance;
          document.getElementById('camera-distance-value').textContent = `${cameraAlertDistance} miles`;
          console.log('Restored default distances: hazard=2 miles, camera=0.5 miles');
        }
      });
      document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.settings-tab-content').forEach(c => c.style.display = 'none');
          tab.classList.add('active');
          document.getElementById(tab.getAttribute('data-tab')).style.display = 'block';
          console.log('Switched to settings tab:', tab.getAttribute('data-tab'));
        });
      });
      document.querySelectorAll('.alerts-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.alerts-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.alerts-tab-content').forEach(c => c.style.display = 'none');
          tab.classList.add('active');
          document.getElementById(tab.getAttribute('data-tab')).style.display = 'block';
          console.log('Switched to alerts tab:', tab.getAttribute('data-tab'));
        });
      });
      window.addEventListener('orientationchange', () => {
        adjustHud();
        if (navState.isFollowing) {
          restoreNavigationView();
        }
      });
      // Network resilience
      window.addEventListener('online', () => {
        console.log('Network connection restored');
        showToast('Connection restored');
        if (socket && !socket.connected) {
          socket.connect();
        }
        // Resync data
        const token = TokenManager.get();
        if (TokenManager.isValid()) {
          checkSubscriptionStatus();
          pollAlerts();
        }
        OfflineQueue.process();
      });
      window.addEventListener('offline', () => {
        console.log('Network connection lost');
        showToast('Connection lost. Using offline mode.');
        // Switch to offline map tiles if available
        if (navState.offlineRegions.length > 0) {
          showToast('Switching to offline maps');
        }
      });
    }
    // Offline Queue
    const OfflineQueue = {
      queue: JSON.parse(localStorage.getItem('offlineQueue') || '[]'),
      add(action) {
        this.queue.push({
          ...action,
          timestamp: Date.now(),
          id: Math.random().toString(36).substr(2, 9)
        });
        this.save();
      },
      save() {
        localStorage.setItem('offlineQueue', JSON.stringify(this.queue));
      },
      async process() {
        if (!navigator.onLine || this.queue.length === 0) return;
        const pending = [...this.queue];
        this.queue = [];
        this.save();
        for (const action of pending) {
          try {
            await this.executeAction(action);
          } catch (error) {
            console.error('Failed to execute queued action:', error);
            this.queue.push(action); // Re-queue
          }
        }
        this.save();
      },
      async executeAction(action) {
        switch (action.type) {
          case 'postAlert':
            await postAlert(); // With stored data
            break;
          case 'updateLocation':
            await updateServerLocation(action.data);
            break;
        }
      }
    };
    // AppHealth
    const AppHealth = {
      lastGPSUpdate: 0,
      lastSocketMessage: 0,
      errors: [],
      check() {
        const now = Date.now();
        const issues = [];
        // Check GPS
        if (navState.isNavigating && now - this.lastGPSUpdate > 10000) {
          issues.push('GPS signal lost');
        }
        // Check Socket
        if (socket && !socket.connected) {
          issues.push('Server connection lost');
        }
        // Check token expiration
        if (!TokenManager.isValid()) {
          issues.push('Session expired');
          this.handleSessionExpired();
        }
        // Check memory usage (if available)
        if (performance.memory) {
          const usedMB = performance.memory.usedJSHeapSize / 1048576;
          if (usedMB > 200) {
            issues.push('High memory usage');
            console.warn('Memory usage:', usedMB.toFixed(2), 'MB');
          }
        }
        if (issues.length > 0) {
          console.warn('Health check issues:', issues);
          this.reportIssues(issues);
        }
        return issues.length === 0;
      },
      handleSessionExpired() {
        showToast('Session expired. Please log in again.');
        TokenManager.clear();
        document.getElementById('auth-container').style.display = 'flex';
      },
      reportIssues(issues) {
        // Send to analytics/monitoring service
        if (window.gtag) {
          window.gtag('event', 'health_check_failed', {
            issues: issues.join(', ')
          });
        }
      }
    };
    // Run health check every minute
    setInterval(() => AppHealth.check(), 60000);
    async function startWakeWordDetection() {
  if (!voiceAssistantEnabled) return;
  
  // Check if permission already denied
  if (localStorage.getItem('micPermissionDenied') === 'true') {
    console.log('Mic permission previously denied, skipping');
    return;
  }

  // Check browser support
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    console.warn('Speech recognition not supported');
    showToast('Voice assistant not supported in this browser');
    return;
  }

  try {
    // Request mic permission
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => track.stop());
    localStorage.removeItem('micPermissionDenied');
    
    // âœ… CREATE THE WAKE WORD RECOGNIZER
    wakeWordRecognizer = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    wakeWordRecognizer.lang = 'en-US';
    wakeWordRecognizer.continuous = true; // â† Keep listening
    wakeWordRecognizer.interimResults = false;
    wakeWordRecognizer.maxAlternatives = 1;

    wakeWordRecognizer.onresult = (event) => {
      const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
      console.log('Wake word recognizer heard:', transcript);
      
      // Check for wake word
      if (transcript.includes('hey nova') || transcript.includes('nova')) {
        console.log('Wake word detected!');
        showToast('Listening...');
        
        // Play feedback sound (optional)
        if ('speechSynthesis' in window) {
          const utterance = new SpeechSynthesisUtterance('Yes?');
          utterance.lang = 'en-US';
          utterance.volume = 0.5;
          speechSynthesis.speak(utterance);
        }
        
        // Stop wake word detection and start command recognition
        wakeWordRecognizer.stop();
        startCommandRecognition();
      }
    };

    wakeWordRecognizer.onerror = (event) => {
      console.error('Wake word recognizer error:', event.error);
      
      // Auto-restart on certain errors
      if (event.error === 'no-speech' || event.error === 'audio-capture') {
        setTimeout(() => {
          if (voiceAssistantEnabled && wakeWordRecognizer) {
            wakeWordRecognizer.start();
          }
        }, 1000);
      }
    };

    wakeWordRecognizer.onend = () => {
      console.log('Wake word recognizer stopped');
      // Auto-restart if still enabled
      if (voiceAssistantEnabled) {
        setTimeout(() => {
          try {
            wakeWordRecognizer.start();
            console.log('Wake word recognizer restarted');
          } catch (err) {
            console.error('Failed to restart wake word recognizer:', err);
          }
        }, 500);
      }
    };

    // Start listening
    wakeWordRecognizer.start();
    console.log('Wake word detection started - listening for "Hey Nova"');
    showToast('Voice assistant active - say "Hey Nova" to start');
    
  } catch (err) {
    console.error('Mic access denied:', err);
    localStorage.setItem('micPermissionDenied', 'true');
    showToast('Voice assistant disabled - mic access denied');
    document.getElementById('voice-assistant-toggle').checked = false;
    voiceAssistantEnabled = false;
  }
}
    function parseAndExecuteCommand(command) {
  console.log('Parsing command:', command);
  
  // âœ… FIX: Handle "go to" or "navigate to" commands
  if (command.includes('go to') || command.includes('navigate to')) {
    const addressMatch = command.match(/(?:go to|navigate to)\s+(.+)/i);
    if (addressMatch) {
      const address = addressMatch[1].trim();
      console.log('Navigation command detected, address:', address);
      
      showToast(`Navigating to ${address}...`);
      
      // âœ… Use Google Places Autocomplete Service to find the address
      const service = new google.maps.places.AutocompleteService();
      service.getPlacePredictions({ input: address }, (predictions, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && predictions && predictions.length > 0) {
          const placeId = predictions[0].place_id;
          
          // Get place details
          const detailService = new google.maps.places.PlacesService(map);
          detailService.getDetails({ placeId: placeId }, (place, status) => {
            if (status === google.maps.places.PlacesServiceStatus.OK && place.geometry) {
              navState.destination = {
                lat: place.geometry.location.lat(),
                lng: place.geometry.location.lng()
              };
              
              console.log('Destination set:', navState.destination);
              
              // Create destination marker
              if (destMarker) destMarker.map = null;
              const destMarkerElement = document.createElement('div');
              destMarkerElement.style.width = '20px';
              destMarkerElement.style.height = '20px';
              destMarkerElement.style.backgroundColor = 'green';
              destMarkerElement.style.borderRadius = '50%';
              destMarkerElement.style.border = '2px solid white';
              destMarker = new google.maps.marker.AdvancedMarkerElement({
                map: map,
                position: navState.destination,
                content: destMarkerElement,
                title: 'Destination'
              });
              
              // Calculate route
              calculateAndDisplayRoute(navState.userLocation, navState.destination, () => {
                console.log('Route calculated via voice command');
                showToast(`Route to ${address} ready. Say "start navigation" to begin.`);
                
                // Speak confirmation
                if ('speechSynthesis' in window) {
                  const utterance = new SpeechSynthesisUtterance(`Route ready. Say start navigation to begin.`);
                  utterance.lang = 'en-US';
                  speechSynthesis.speak(utterance);
                }
              });
            } else {
              console.error('Failed to get place details:', status);
              showToast(`Sorry, I couldn't find ${address}`);
            }
          });
        } else {
          console.error('No predictions found for:', address);
          showToast(`Sorry, I couldn't find ${address}`);
        }
      });
    }
  } 
  // âœ… Handle "start navigation" command
  else if (command.includes('start navigation') || command.includes('begin navigation')) {
    if (navState.destination) {
      showToast('Starting navigation...');
      setTimeout(() => startGPS(), 500);
      
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance('Starting navigation');
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
      }
    } else {
      showToast('Please set a destination first');
    }
  }
  // âœ… Handle "place an alert" commands
  else if (command.includes('place an alert at my location') || command.includes('place alert here')) {
    if (navState.isNavigating) {
      showToast('Placing alert at your current location...');
      document.getElementById('hazard-button').click();
      
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance('What type of alert?');
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
      }
    } else {
      showToast('Please start navigation first to place alerts');
    }
  }
  // Handle recenter
  else if (command.includes('recenter') || command.includes('center map')) {
    document.getElementById('recenter-button').click();
    showToast('Recentering map');
  }
  // Handle stop navigation
  else if (command.includes('stop navigation') || command.includes('end navigation')) {
    document.getElementById('bottom-hud-stop')?.click();
    showToast('Stopping navigation');
  }
  // Handle share route
  else if (command.includes('share route')) {
    shareRoute();
  }
  // Unknown command
  else {
    showToast(`Sorry, I didn't understand: "${command}"`);
    console.log('Unknown command:', command);
  }
}
    function stopWakeWordDetection() {
      if (wakeWordRecognizer) {
        wakeWordRecognizer.stop();
        wakeWordRecognizer = null;
        console.log('Wake word detection stopped');
      }
      if (commandSpeechRecognition) {
        commandSpeechRecognition.stop();
        commandSpeechRecognition = null;
        console.log('Command recognition stopped');
      }
    }
    function startCommandRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('Speech recognition not supported');
        showToast('Command recognition not supported');
        return;
      }
      if (commandSpeechRecognition) {
        commandSpeechRecognition.stop();
      }
      commandSpeechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      commandSpeechRecognition.lang = 'en-US';
      commandSpeechRecognition.interimResults = false;
      commandSpeechRecognition.maxAlternatives = 1;
      commandSpeechRecognition.onresult = (event) => {
        const command = event.results[0][0].transcript.toLowerCase().trim();
        console.log('Command recognized:', command);
        parseAndExecuteCommand(command);
      };
      commandSpeechRecognition.onerror = (event) => {
        console.error('Command recognition error:', event.error);
        showToast('Command recognition error: ' + event.error);
      };
      commandSpeechRecognition.onend = () => {
        console.log('Command recognition ended');
        commandSpeechRecognition = null;
        if (voiceAssistantEnabled) {
          startWakeWordDetection();
        }
      };
      commandSpeechRecognition.start();
      console.log('Command recognition started');
    }
    async function fetchProfile(targetId, isOwn) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          throw new Error('Invalid token format in storage');
        }
        console.log('Fetching profile with token:', token.substring(0, 20) + '...');
        let response = await fetchWithRetry(`/api/auth/profile/${targetId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Profile fetch response:', { status: response.status, ok: response.ok });
        const data = await response.json();
        if (!response.ok) throw new Error(`Profile fetch failed: ${data.error || response.statusText}`);
        isAdmin = data.email === 'imhoggbox@gmail.com' || data.isAdmin;
        localStorage.setItem('isAdmin', isAdmin);
        sessionStorage.setItem('isAdmin', isAdmin);
        if (isAdmin) {
          document.getElementById('admin-button').style.display = 'flex';
        }
        return data;
      } catch (err) {
        console.error('Failed to fetch profile:', err);
        showToast('Failed to load profile data. Please log in again.');
        TokenManager.clear();
        document.getElementById('auth-container').style.display = 'flex';
        throw err;
      }
    }
    function populateAccountProfile(data) {
      document.getElementById('username-display').textContent = data.username || 'N/A';
      document.getElementById('email-display').textContent = data.email || 'N/A';
      document.getElementById('join-date-display').textContent = data.joinDate ? new Date(data.joinDate).toLocaleDateString() : 'N/A';
      document.getElementById('total-alerts-display').textContent = data.totalAlerts || 0;
      document.getElementById('active-alerts-display').textContent = data.activeAlerts || 0;
      document.getElementById('points-display').textContent = `Points: ${data.points || 0}`;
      document.getElementById('edit-username').value = data.username || '';
      document.getElementById('edit-email').value = data.email || '';
      document.getElementById('edit-password').value = '';
    }
    function viewUserProfile(userId) {
      fetchProfile(userId, false).then(data => {
        document.getElementById('hud-username').textContent = data.username || 'N/A';
        document.getElementById('hud-join-date').textContent = data.joinDate ? new Date(data.joinDate).toLocaleDateString() : 'N/A';
        document.getElementById('hud-total-alerts').textContent = data.totalAlerts || 0;
        document.getElementById('hud-active-alerts').textContent = data.activeAlerts || 0;
        document.getElementById('hud-points').textContent = `Points: ${data.points || 0}`;
        document.getElementById('user-profile-hud-container').classList.add('active');
      }).catch(err => {
        console.error('Failed to fetch user profile:', err);
        showToast('Failed to load user profile.');
      });
    }
    window.viewUserProfile = viewUserProfile;
    async function requestPushPermission() {
      if (!pushNotificationsEnabled) {
        console.log('Push notifications disabled, skipping permission request');
        return;
      }
      if ('PushManager' in window) {
        try {
          const permission = await Notification.requestPermission();
          if (permission === 'granted') {
            console.log('Push notification permission granted');
            await subscribeToPush();
          } else {
            console.warn('Push notification permission denied');
            showToast('Notifications blocked. Enable in browser settings for alerts.');
            localStorage.setItem('pushNotificationsEnabled', false);
            sessionStorage.setItem('pushNotificationsEnabled', false);
            document.getElementById('push-notifications-toggle').checked = false;
            pushNotificationsEnabled = false;
          }
        } catch (err) {
          console.error('Error requesting push permission:', err);
          showToast('Failed to request notification permission.');
        }
      } else {
        console.warn('Push notifications not supported');
        showToast('Push notifications not supported by this browser.');
        localStorage.setItem('pushNotificationsEnabled', false);
        sessionStorage.setItem('pushNotificationsEnabled', false);
        document.getElementById('push-notifications-toggle').checked = false;
        pushNotificationsEnabled = false;
      }
    }
    async function subscribeToPush() {
      if (!pushNotificationsEnabled) {
        console.log('Push notifications disabled, skipping subscription');
        return;
      }
      try {
        const reg = await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlB64ToUint8Array(VAPID_PUBLIC_KEY)
        });
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, cannot subscribe to push');
          return;
        }
        console.log('Subscribing to push with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry('/api/auth/subscribe', {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(sub)
        });
        console.log('Push subscription response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error(`Failed to subscribe: ${response.statusText}`);
        console.log('Subscribed to push notifications');
      } catch (err) {
        console.error('Failed to subscribe to push:', err);
        showToast('Failed to enable notifications.');
      }
    }
    async function unsubscribeFromPush() {
      try {
        const reg = await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.getSubscription();
        if (sub) {
          const token = TokenManager.get();
          if (!TokenManager.isValid()) {
            console.error('Invalid token, cannot unsubscribe from push');
            return;
          }
          console.log('Unsubscribing from push with token:', token.substring(0, 20) + '...');
          await fetchWithRetry('/api/auth/unsubscribe', {
            method: 'POST',
            mode: 'cors',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(sub)
          });
          await sub.unsubscribe();
          console.log('Unsubscribed from push notifications');
        } else {
          console.log('No push subscription to unsubscribe');
        }
      } catch (err) {
        console.error('Failed to unsubscribe from push:', err);
        showToast('Failed to disable notifications.');
      }
    }
    function urlB64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }
    async function fetchLeaderboard() {
      const token = TokenManager.get();
      if (!TokenManager.isValid()) {
        console.error('Invalid token, showing auth form');
        TokenManager.clear();
        document.getElementById('auth-container').style.display = 'flex';
        return;
      }
      try {
        console.log('Fetching leaderboard with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry('/api/leaderboard', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Leaderboard fetch response:', { status: response.status, ok: response.ok });
        if (!response.ok) throw new Error(`Leaderboard fetch failed: ${response.statusText}`);
        const users = await response.json();
        const content = document.getElementById('leaderboard-content');
        content.innerHTML = '';
        users.forEach((user, index) => {
          const item = document.createElement('div');
          item.className = 'alert-item';
          item.innerHTML = `
            <div class="alert-field"><strong>#${index + 1} ${user.username}</strong> - Points: ${user.points}</div>
            <div class="alert-field">Achievements: ${Array.isArray(user.achievements) ? user.achievements.join(', ') : 'None'}</div>
          `;
          content.appendChild(item);
        });
        console.log('Leaderboard fetched:', users.length);
      } catch (err) {
        console.error('Failed to fetch leaderboard:', err);
        showToast('Failed to load leaderboard.');
      }
    }
    function startVoiceRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('Speech recognition not supported');
        showToast('Speech recognition not supported');
        return;
      }
      if (!speechRecognition) {
        speechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        speechRecognition.lang = 'en-US';
        speechRecognition.interimResults = false;
        speechRecognition.maxAlternatives = 1;
        speechRecognition.onresult = (event) => {
          const command = event.results[0][0].transcript.toLowerCase();
          console.log('Voice command:', command);
          if (command.includes('report hazard')) {
            document.getElementById('hazard-button').click();
          } else if (command.includes('start navigation')) {
            document.getElementById('start-button').click();
          } else if (command.includes('stop navigation')) {
            document.getElementById('bottom-hud-stop').click();
          }
        };
        speechRecognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          showToast('Speech recognition error: ' + event.error);
        };
      }
      speechRecognition.start();
      console.log('Speech recognition started');
    }
    function shareRoute() {
      if (navigator.share && navState.currentRoute) {
        const shareData = { route: navState.currentRoute, family: navState.familyMembers };
        navigator.share({
          title: 'My Route',
          text: 'Check out my current route!',
          url: `${window.location.href}?route=${encodeURIComponent(JSON.stringify(shareData))}`
        }).then(() => console.log('Route shared successfully'))
          .catch(err => {
            console.error('Share failed:', err);
            showToast('Sharing not supported');
          });
      } else {
        showToast('Sharing not supported');
      }
    }
    // Add exponential backoff with jitter
async function fetchWithRetry(url, options, retries = CONFIG.FETCH_RETRIES, backoff = CONFIG.FETCH_BACKOFF) {
  for (let i = 0; i < retries; i++) {
    try {
      const token = TokenManager.get();
      if (options?.headers && token) {
        options.headers['Authorization'] = `Bearer ${token}`;
      }
      const response = await fetch(url, options);
      // Check for rate limiting
      if (response.status === 429) {
        const retryAfter = parseInt(response.headers.get('Retry-After') || '60');
        console.warn(`Rate limited. Retrying after ${retryAfter}s`);
        showToast(`Too many requests. Retrying in ${retryAfter} seconds...`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        continue;
      }
      if (response.ok) return response;
      if (response.status === 401) {
        const refreshed = await refreshToken();
        if (refreshed) {
          const newToken = TokenManager.get();
          if (options.headers) {
            options.headers['Authorization'] = `Bearer ${newToken}`;
          }
          return await fetch(url, options);
        }
      }
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (i === retries - 1) throw error;
      // Exponential backoff with jitter AND ceiling
      const jitter = Math.random() * 500;
      const delay = Math.min(backoff * Math.pow(2, i) + jitter, 30000); // â† MAX 30s delay
      console.warn(`Retry ${i + 1}/${retries} after ${delay}ms for ${url}`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
    async function refreshToken() {
  try {
    const token = TokenManager.get();
    if (!token || !TokenManager.isValid()) {
      throw new Error('No valid token to refresh');
    }
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` }
    });
    if (response.ok) {
      const data = await response.json();
      TokenManager.set(data.token);
      return true;
    } else if (response.status === 401) {
      // Token can't be refreshed - log out
      TokenManager.clear();
      document.getElementById('auth-container').style.display = 'flex';
      showToast('Session expired. Please log in again.');
      return false;
    }
    throw new Error('Refresh failed');
  } catch (error) {
    console.error('Token refresh failed:', error);
    TokenManager.clear();
    document.getElementById('auth-container').style.display = 'flex';
    return false;
  }
}
    function isDuplicateAlert(alert) {
  const now = Date.now();
  // Create fuzzy key (round to ~10m precision)
  const lat = Math.round(alert.location.coordinates[1] * 1000) / 1000;
  const lng = Math.round(alert.location.coordinates[0] * 1000) / 1000;
  const key = `${alert.type}-${lat}-${lng}`;
  const cached = alertCache.get(key);
  if (cached && now - cached.timestamp < 30000) { // 30s window
    return true;
  }
  alertCache.set(key, { timestamp: now, id: alert._id });
  return false;
}
    async function confirmAlertLocation(location, alertType) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Checking nearby alerts with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry(`/api/markers?lat=${location.lat()}&lng=${location.lng()}&maxDistance=${CONFIG.MIN_ALERT_DISTANCE}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Nearby alerts response:', { status: response.status, ok: response.ok });
        const nearbyAlerts = await response.json();
        if (nearbyAlerts.length > 0) {
          showToast('Cannot place alert within 500ft of another alert. Please choose a different location.');
          navState.alertState = 'IDLE';
          if (navState.mapClickListener) {
            google.maps.event.removeListener(navState.mapClickListener);
            navState.mapClickListener = null;
          }
          return;
        }
      } catch (error) {
        console.error('Error checking nearby alerts:', error);
        showToast('Error checking nearby alerts. Proceeding with placement.');
      }
      navState.alertState = 'CONFIRMING_ALERT';
      if (navState.mapClickListener) {
        google.maps.event.removeListener(navState.mapClickListener);
        navState.mapClickListener = null;
      }
      navState.tempMarker = getMarker({
        map: map,
        position: location,
        content: alertType === 'Traffic Camera' && showTrafficCameras ? createTrafficCameraContent() : createAlertContent(),
        title: `Temporary ${alertType} Alert`,
        gmpDraggable: false
      });
      navState.tempAlertData = {
        type: alertType,
        location: {
          type: 'Point',
          coordinates: [location.lng(), location.lat()]
        },
        timestamp: new Date(),
        votes: { up: 0, down: 0 }
      };
      try {
        console.log('Reverse geocoding for alert location:', location);
        const geocoded = await reverseGeocode(location.lat(), location.lng());
        if (geocoded.status === 'OK' && geocoded.results[0]) {
          navState.tempAlertData.address = geocoded.results[0].formatted_address;
          console.log('Reverse geocoding successful:', navState.tempAlertData.address);
        } else {
          console.warn('Reverse geocoding failed, using coordinates:', geocoded.status);
          navState.tempAlertData.address = `Lat: ${location.lat().toFixed(4)}, Lng: ${location.lng().toFixed(4)}`;
        }
      } catch (error) {
        console.error('Reverse geocoding failed:', error);
        showToast('Failed to get address for alert location.');
        navState.tempAlertData.address = `Lat: ${location.lat().toFixed(4)}, Lng: ${location.lng().toFixed(4)}`;
      }
      const reportBox = document.getElementById('report-box');
      const confirmAlert = document.getElementById('confirm-alert');
      const reportOptions = document.querySelector('.report-options');
      reportOptions.style.display = 'none';
      confirmAlert.classList.add('active');
      const alertTypeDisplay = document.getElementById('alert-type-display');
      const locationDisplay = document.getElementById('location-display');
      const timestampDisplay = document.getElementById('timestamp-display');
      alertTypeDisplay.textContent = alertType;
      locationDisplay.textContent = navState.tempAlertData.address;
      timestampDisplay.textContent = navState.tempAlertData.timestamp.toLocaleString();
      reportBox.classList.add('active');
      console.log(`Confirming ${alertType} alert at`, navState.tempAlertData.location);
    }
    async function postAlert() {
      if (isPostingAlert) {
        console.log('postAlert already in progress, skipping');
        return;
      }
      isPostingAlert = true;
      // Safety timeout - release lock after 10 seconds
      postingTimeout = setTimeout(() => {
        console.warn('postAlert timeout, releasing lock');
        isPostingAlert = false;
      }, 10000);
      if (!navState.tempAlertData || !navState.tempMarker) {
        console.error('No alert data or marker to post');
        showToast('Failed to post alert: No data available.');
        isPostingAlert = false;
        clearTimeout(postingTimeout);
        return;
      }
      const isTrafficCamera = navState.tempAlertData.type === 'Traffic Camera';
      if (isTrafficCamera && !showTrafficCameras) {
        console.log('Traffic camera alert not posted: traffic cameras disabled');
        releaseMarker(navState.tempMarker);
        navState.tempMarker = null;
        navState.tempAlertData = null;
        navState.alertState = 'IDLE';
        showToast('Traffic camera alert not posted: cameras disabled in settings.');
        isPostingAlert = false;
        clearTimeout(postingTimeout);
        return;
      }
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Posting alert with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry('/api/alerts', {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(navState.tempAlertData)
        });
        console.log('Post alert response:', { status: response.status, ok: response.ok });
        const result = await response.json();
        console.log('Post alert result:', result);
        if (response.status === 201 && result.alert && result.alert._id) {
          const alertId = result.alert._id;
          const alert = result.alert;
          if (!isDuplicateAlert(alert)) {
            if (!currentAlerts.some(a => a._id === alertId)) {
              currentAlerts.push(alert);
              console.log('Added new alert to currentAlerts:', alertId);
            }
            displayAlertsInHud(currentAlerts);
          } else {
            console.log('Duplicate alert ignored via cache:', alertId);
          }
          // Create marker only if not already present
          if (!markers.has(alertId)) {
            const marker = getMarker({
              map,
              position: { lat: navState.tempAlertData.location.coordinates[1], lng: navState.tempAlertData.location.coordinates[0] },
              content: isTrafficCamera ? createTrafficCameraContent() : createAlertContent(),
              title: `${navState.tempAlertData.type} Alert`
            });
            markers.set(alertId, marker);
            console.log('Created new marker for alert:', alertId);
          } else {
            console.log('Marker already exists for alert, skipping creation:', alertId);
          }
          console.log('Alert saved to MongoDB:', result.alert);
          showToast(`Thank you, your ${navState.tempAlertData.type} alert has been posted.`);
          if (isTrafficCamera) {
            cameraPositions.push({
              lat: navState.tempAlertData.location.coordinates[1],
              lng: navState.tempAlertData.location.coordinates[0]
            });
          } else if (navState.isNavigating) {
            checkHazardsAndOfferReroute();
          }
          if (socket && socket.connected) {
            socket.emit('alert', result.alert);
            console.log('Emitted alert event:', alertId);
          }
          // Refresh profile
          const ownId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
          fetchProfile(ownId, true).then(populateAccountProfile);
          // Final sync via poll to catch any server-side changes
          setTimeout(() => pollAlerts(), 1000);
        } else if (response.status === 409 && result.alert && result.alert._id) {
          const alertId = result.alert._id;
          const alert = result.alert;
          if (!isDuplicateAlert(alert)) {
            if (!currentAlerts.some(a => a._id === alertId)) {
              currentAlerts.push(alert);
              displayAlertsInHud(currentAlerts);
            }
          }
          showToast(result.message || 'Duplicate alert ignored.');
          console.log('Duplicate alert ignored:', alertId);
          setTimeout(() => pollAlerts(), 1000);
        } else {
          console.error('Failed to save alert:', result.error || 'Unknown server error', 'Status:', response.status);
          showToast(`Failed to save alert: ${result.error || 'Server error'}`);
        }
      } catch (error) {
        console.error('Error posting alert:', error);
        showToast(`Error posting alert: ${error.message}`);
      } finally {
        // Always clean up temp state
        if (navState.tempMarker) {
          releaseMarker(navState.tempMarker);
          navState.tempMarker = null;
        }
        navState.tempAlertData = null;
        navState.alertState = 'IDLE';
        const reportBox = document.getElementById('report-box');
        const confirmAlert = document.getElementById('confirm-alert');
        const reportOptions = document.querySelector('.report-options');
        reportBox.classList.remove('active');
        confirmAlert.classList.remove('active');
        reportOptions.style.display = 'grid';
        if (navState.isNavigating && navState.isFollowing) {
          lockNavigation();
          console.log('Navigation view re-locked after manual report');
        }
        isPostingAlert = false;
        clearTimeout(postingTimeout);
      }
    }
    function cancelAlert() {
      if (navState.tempMarker) {
        releaseMarker(navState.tempMarker);
        navState.tempMarker = null;
      }
      if (navState.mapClickListener) {
        google.maps.event.removeListener(navState.mapClickListener);
        navState.mapClickListener = null;
      }
      const reportBox = document.getElementById('report-box');
      const reportOptions = document.querySelector('.report-options');
      const confirmAlert = document.getElementById('confirm-alert');
      reportBox.classList.remove('active');
      reportOptions.style.display = 'grid';
      confirmAlert.classList.remove('active');
      navState.alertState = 'IDLE';
      navState.tempAlertData = null;
      showToast('Alert placement cancelled.');
      console.log('Alert placement cancelled');
      if (navState.isNavigating && navState.isFollowing) {
        lockNavigation();
        console.log('Navigation view re-locked after cancelling manual report');
      }
    }
    async function voteOnAlert(alertId, voteType) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log(`Voting ${voteType} on alert ${alertId} with token:`, token.substring(0, 20) + '...');
        const response = await fetchWithRetry(`/api/alerts/${alertId}/vote`, {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ voteType })
        });
        console.log('Vote response:', { status: response.status, ok: response.ok });
        const updatedAlert = await response.json();
        console.log('Vote successful, updated alert:', updatedAlert);
        if (!response.ok) {
          throw new Error(`Failed to vote: ${updatedAlert.error || response.statusText}`);
        }
        const index = currentAlerts.findIndex(a => a._id === alertId);
        if (index !== -1) {
          currentAlerts[index] = updatedAlert;
          displayAlertsInHud(currentAlerts);
        }
        if (updatedAlert.votes.down > updatedAlert.votes.up * 2) {
          console.log('Downvotes exceed threshold, removing alert');
          deleteAlert(alertId);
        } else if (updatedAlert.votes.up > updatedAlert.votes.down) {
          console.log('Upvotes exceed downvotes, extending alert duration');
          if (socket) {
            socket.emit('extendAlert', alertId);
          }
        }
        dismissVerificationHud();
        showToast(`Voted ${voteType} on alert.`);
      } catch (error) {
        console.error('Error voting on alert:', error);
        showToast(`Failed to vote on alert: ${error.message}`);
      }
    }
    function dismissVerificationHud() {
      const verificationHudContainer = document.getElementById('verification-hud-container');
      const verificationHud = document.getElementById('verification-hud');
      verificationHudContainer.classList.remove('active');
      verificationHud.classList.remove('active');
      currentVerificationAlertId = null;
      console.log('Verification HUD dismissed');
    }
    async function deleteAlert(id, item) {
  // âœ… Save state BEFORE modifying UI
  const removedFromUI = item;
  const markerBackup = markers.get(id);
  const alertBackup = currentAlerts.find(a => a._id === id);
  // Remove from UI immediately
  item?.remove();
  const marker = markers.get(id);
  if (marker) {
    releaseMarker(marker);
    markers.delete(id);
  }
  try {
    const token = TokenManager.get();
    if (!TokenManager.isValid()) {
      console.error('Invalid token, showing auth form');
      TokenManager.clear();
      document.getElementById('auth-container').style.display = 'flex';
      return;
    }
    console.log('Deleting alert with token:', token.substring(0, 20) + '...');
    const response = await fetchWithRetry(`/api/alerts/${id}`, {
      method: 'DELETE',
      mode: 'cors',
      credentials: 'include',
      headers: { 'Authorization': `Bearer ${token}` }
    });
    if (!response.ok) {
      throw new Error(`Failed to delete alert: ${response.statusText}`);
    }
    console.log('Delete alert response:', { status: response.status, ok: response.ok });
    // Now handle local cleanup on success
    // Remove from currentAlerts and update HUD
    const alertIndex = currentAlerts.findIndex(a => a._id === id);
    if (alertIndex !== -1) {
      const removedAlert = currentAlerts.splice(alertIndex, 1)[0];
      if (removedAlert && removedAlert.type === 'Traffic Camera') {
        cameraPositions = cameraPositions.filter(pos =>
          pos.lat !== removedAlert.location.coordinates[1] || pos.lng !== removedAlert.location.coordinates[0]
        );
        cameraAlertShown.delete(`mongo-${id}`);
      }
      displayAlertsInHud(currentAlerts);
      console.log('Alert removed from currentAlerts:', id);
    }
    showToast('Alert deleted successfully.');
    console.log('Alert deletion complete:', id);
    // Emit deletion event if socket connected
    if (socket && socket.connected) {
      socket.emit('alertDeleted', id);
      console.log('Emitted alertDeleted event:', id);
    } else {
      // Fallback to polling if no socket
      console.warn('Socket not connected, relying on polling for alert deletion:', id);
      setTimeout(() => pollAlerts(), 1000);
    }
    // Refresh profile if own alert
    const ownId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
    fetchProfile(ownId, true).then(populateAccountProfile);
  } catch (error) {
    // âœ… ROLLBACK on failure
    if (removedFromUI && alertBackup) {
      currentAlerts.push(alertBackup);
      displayAlertsInHud(currentAlerts); // Re-render
    
      if (markerBackup) {
        markers.set(id, markerBackup);
        markerBackup.map = map; // Re-show marker
      }
    }
    showToast('Failed to delete alert. Restored.');
    console.error('Delete rollback executed:', error);
  }
}
    async function pollAlerts() {
  if (!navState.userLocation) return;
  try {
    const token = TokenManager.get();
    if (!TokenManager.isValid()) return;
  
    const response = await fetchWithRetry(/* ... */);
    const serverAlerts = await response.json();
  
    // âœ… Dedupe first
    const serverAlertIds = new Set(serverAlerts.map(a => a._id));
  
    // âœ… THEN remove stale markers
    markers.forEach((marker, id) => {
      if (!serverAlertIds.has(id)) {
        releaseMarker(marker);
        markers.delete(id);
        console.log('Removed stale marker:', id);
      }
    });
  
    // âœ… Update currentAlerts
    currentAlerts = [...new Map(serverAlerts.map(a => [a._id, a])).values()];
    displayAlertsInHud(currentAlerts);
  } catch (error) {
    console.error('Poll error:', error);
  }
}
    async function fetchAndDisplayMarkers(map, center) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, skipping marker fetch');
          return;
        }
        console.log('Fetching markers with token:', token.substring(0, 20) + '...');
        const url = `/api/markers?lat=${center.lat}&lng=${center.lng}&maxDistance=${navState.alertRadius * 1609.34}`;
        const response = await fetchWithRetry(url, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Markers fetch response:', { status: response.status, ok: response.ok });
        const markersData = await response.json();
        markers.forEach((marker, id) => {
          releaseMarker(marker);
          markers.delete(id);
        });
        cameraPositions = [];
        markersData.filter(markerData => {
          if (markerData.type === 'Traffic Camera' && !showTrafficCameras) return false;
          const filterKey = markerData.type.toLowerCase().replace(/\s+/g, '-');
          return navState.alertFilters[filterKey] !== false;
        }).forEach(markerData => {
          const isTrafficCamera = markerData.type === 'Traffic Camera';
          const marker = getMarker({
            map,
            position: {
              lat: markerData.location.coordinates[1],
              lng: markerData.location.coordinates[0]
            },
            content: isTrafficCamera ? createTrafficCameraContent() : createAlertContent(),
            title: `${markerData.type} Alert`
          });
          markers.set(markerData._id, marker);
          if (isTrafficCamera) {
            cameraPositions.push({
              lat: markerData.location.coordinates[1],
              lng: markerData.location.coordinates[0]
            });
          }
        });
        currentAlerts = [...new Map(markersData.filter(alert => {
          if (alert.type === 'Traffic Camera' && !showTrafficCameras) return false;
          const filterKey = alert.type.toLowerCase().replace(/\s+/g, '-');
          return navState.alertFilters[filterKey] !== false;
        }).map(a => [a._id, a])).values()];
        displayAlertsInHud(currentAlerts);
        console.log('Fetched and displayed markers:', markersData.length);
      } catch (error) {
        console.error('Error fetching markers:', error);
        showToast('Failed to load alerts.');
      }
    }
    async function fetchCurrentAlerts() {
      const center = navState.userLocation;
      const token = TokenManager.get();
      if (!TokenManager.isValid()) {
        console.error('Invalid token, showing auth form');
        TokenManager.clear();
        document.getElementById('auth-container').style.display = 'flex';
        return;
      }
      try {
        console.log('Fetching current alerts with token:', token.substring(0, 20) + '...');
        const url = `/api/markers?lat=${center.lat}&lng=${center.lng}&maxDistance=${navState.alertRadius * 1609.34}`;
        const response = await fetchWithRetry(url, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Current alerts fetch response:', { status: response.status, ok: response.ok });
        const alerts = await response.json();
        currentAlerts = [...new Map(alerts.filter(alert => {
          if (alert.type === 'Traffic Camera' && !showTrafficCameras) return false;
          const filterKey = alert.type.toLowerCase().replace(/\s+/g, '-');
          return navState.alertFilters[filterKey] !== false;
        }).map(a => [a._id, a])).values()];
        lastAlertFetchTime = Date.now();
        displayAlertsInHud(currentAlerts);
        if (navState.isNavigating) {
          checkHazardsAndOfferReroute();
        }
        console.log('Fetched current alerts:', currentAlerts.length);
      } catch (error) {
        console.error('Error fetching alerts:', error);
        showToast(`Failed to load current alerts: ${error.message}`);
      }
    }
    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      if (days > 0) return `${days} days`;
      if (hours > 0) return `${hours} hours`;
      if (minutes > 0) return `${minutes} minutes`;
      return `${seconds} seconds`;
    }
    function displayAlertsInHud(alerts) {
      const content = document.getElementById('information');
      content.innerHTML = '';
      if (alerts.length === 0) {
        content.innerHTML = '<p>No current alerts nearby.</p>';
        return;
      }
      const ownId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
      alerts.forEach(alert => {
        const dateObj = new Date(alert.timestamp);
        const now = Date.now();
        const durationMs = now - dateObj;
        const item = document.createElement('div');
        item.className = 'alert-item';
        const postedBy = alert.userId && alert.userId.username ? `<a href="#" onclick="viewUserProfile('${alert.userId._id}')">${alert.userId.username}</a>` : 'Anonymous';
        const isOwn = alert.userId && alert.userId._id === ownId;
        const showDelete = isOwn || isAdmin;
        item.innerHTML = `
          <div class="alert-field"><strong>Exact Location:</strong> ${alert.address || `${alert.location.coordinates[1].toFixed(4)}, ${alert.location.coordinates[0].toFixed(4)}`}</div>
          <div class="alert-field"><strong>Date:</strong> ${dateObj.toLocaleDateString()}</div>
          <div class="alert-field"><strong>Timestamp:</strong> ${dateObj.toLocaleTimeString()}</div>
          <div class="alert-field"><strong>How long active:</strong> ${formatDuration(durationMs)}</div>
          <div class="alert-field"><strong>User who posted:</strong> ${postedBy}</div>
          <div class="alert-votes">
            <span>Votes: ðŸ‘ ${alert.votes?.up || 0} ðŸ‘Ž ${alert.votes?.down || 0}</span>
          </div>
          <div class="alert-actions">
            <button class="center-btn" data-lat="${alert.location.coordinates[1]}" data-lng="${alert.location.coordinates[0]}">Center</button>
            ${showDelete ? `<button class="delete-btn" data-id="${alert._id}">Delete</button>` : ''}
            <button class="vote-btn upvote-btn" data-id="${alert._id}" data-type="up">ðŸ‘ Upvote</button>
            <button class="vote-btn downvote-btn" data-id="${alert._id}" data-type="down">ðŸ‘Ž Downvote</button>
          </div>
        `;
        content.appendChild(item);
      });
      content.querySelectorAll('.center-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const lat = parseFloat(btn.dataset.lat);
          const lng = parseFloat(btn.dataset.lng);
          map.setCenter({ lat, lng });
          map.setZoom(15);
          console.log('Centered map on alert:', { lat, lng });
        });
      });
      content.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.dataset.id;
          const item = btn.closest('.alert-item');
          deleteAlert(id, item);
        });
      });
      content.querySelectorAll('.vote-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.dataset.id;
          const type = btn.dataset.type;
          voteOnAlert(id, type);
        });
      });
    }
    function closeAllHuds() {
      document.getElementById('report-box').classList.remove('active');
      document.getElementById('reroute-hud-container').classList.remove('active');
      document.getElementById('settings-hud-container').classList.remove('active');
      document.getElementById('alerts-hud-container').classList.remove('active');
      document.getElementById('camera-hud-container').classList.remove('active');
      document.getElementById('arrival-hud-container').classList.remove('active');
      document.getElementById('leaderboard-hud-container').classList.remove('active');
      document.getElementById('admin-hud-container').classList.remove('active');
      document.getElementById('verification-hud-container').classList.remove('active');
      document.getElementById('user-profile-hud-container').classList.remove('active');
      if (navState.tempMarker) {
        releaseMarker(navState.tempMarker);
        navState.tempMarker = null;
      }
      if (navState.mapClickListener) {
        google.maps.event.removeListener(navState.mapClickListener);
        navState.mapClickListener = null;
      }
      navState.alertState = 'IDLE';
      navState.tempAlertData = null;
      console.log('All HUDs closed');
      if (navState.isNavigating && navState.isFollowing) {
        lockNavigation();
        console.log('Navigation view re-locked after closing HUDs');
        if (navState.pendingReroute) {
          const { hazard, timeSaved } = navState.pendingReroute;
          showRerouteHud(hazard, timeSaved);
          navState.pendingReroute = null;
          console.log('Showing pending reroute HUD after closing HUDs');
        }
      }
    }
    function recenterNonNavigation() {
      if (!map) return;
      requestAnimationFrame(() => {
        map.setCenter(navState.userLocation);
        map.setZoom(15);
        map.setHeading(navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading);
        map.setTilt(0);
        console.log('Non-navigation recenter:', navState.userLocation, 'Heading:', navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading);
        updateCompass();
      });
    }
    function checkArrival(currentPos) {
      if (!navState.isNavigating || !navState.destination || navState.hasArrived) {
        return false;
      }
      const userLatLng = new google.maps.LatLng(currentPos);
      const destLatLng = new google.maps.LatLng(navState.destination);
      const distance = google.maps.geometry.spherical.computeDistanceBetween(userLatLng, destLatLng);
      if (distance <= CONFIG.ARRIVAL_RADIUS) {
        console.log('User arrived at destination:', { distance });
        navState.hasArrived = true;
        showToast('You have arrived at your destination.');
        if ('speechSynthesis' in window) {
          const utterance = new SpeechSynthesisUtterance('You have arrived at your destination.');
          utterance.lang = 'en-US';
          speechSynthesis.speak(utterance);
        }
        destMarker.content.classList.add('ping');
        document.getElementById('arrival-hud-container').classList.add('active');
        document.getElementById('arrival-hud').classList.add('active');
        return true;
      }
      return false;
    }
    function endArrival() {
      document.getElementById('arrival-hud-container').classList.remove('active');
      document.getElementById('arrival-hud').classList.remove('active');
      requestAnimationFrame(() => {
        destMarker.content.style.opacity = 0;
        destMarker.content.classList.remove('ping');
        destMarker.content.style.opacity = 1;
        stopGPS();
        console.log('Navigation ended after arrival');
      });
    }
    function updateRouteAhead(currentPos) {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) {
        if (routePolyline) {
          routePolyline.setMap(null);
          routePolyline = null;
        }
        if (offRoadPolyline) {
          offRoadPolyline.setMap(null);
          offRoadPolyline = null;
        }
        return;
      }
      const path = navState.currentRoute.routes[0].overview_path;
      const currentLatLng = new google.maps.LatLng(currentPos);
      let closestIndex = 0;
      let minDistance = Infinity;
      path.forEach((point, index) => {
        const distance = google.maps.geometry.spherical.computeDistanceBetween(currentLatLng, point);
        if (distance < minDistance) {
          minDistance = distance;
          closestIndex = index;
        }
      });
      const fullPath = path.slice(closestIndex);
      if (routePolyline) {
        routePolyline.setPath(fullPath);
      } else {
        routePolyline = new google.maps.Polyline({
          path: fullPath,
          strokeColor: navState.mainRouteColor,
          strokeWeight: 6,
          strokeOpacity: 0.8,
          zIndex: 5,
          map: map
        });
      }
      console.log('Route ahead updated:', { points: fullPath.length, endPoint: fullPath[fullPath.length - 1] });
    }
    function updateOffRoadPolyline(rawPos, targetPos) {
      if (!rawPos || !targetPos || !navState.isNavigating) {
        if (offRoadPolyline) {
          offRoadPolyline.setMap(null);
          offRoadPolyline = null;
          console.log('Off-road polyline cleared: no position data or not navigating');
        }
        return;
      }
      const rawLatLng = new google.maps.LatLng(rawPos);
      const targetLatLng = new google.maps.LatLng(targetPos);
      const distance = google.maps.geometry.spherical.computeDistanceBetween(rawLatLng, targetLatLng);
      if (distance > CONFIG.SNAP_BUFFER) {
        const path = [rawPos, targetPos];
        if (offRoadPolyline) {
          offRoadPolyline.setPath(path);
        } else {
          offRoadPolyline = new google.maps.Polyline({
            path: path,
            strokeColor: '#808080',
            strokeOpacity: 0.6,
            strokeWeight: 4,
            zIndex: 4,
            icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 }, offset: '0', repeat: '10px' }],
            map: map
          });
        }
        console.log('Off-road polyline updated:', { from: rawPos, to: targetPos, distance });
      } else {
        if (offRoadPolyline) {
          offRoadPolyline.setMap(null);
          offRoadPolyline = null;
          console.log('Off-road polyline cleared: snapped to route');
        }
      }
    }
    function buildRouteIndex(path) {
      const index = new Map();
      const gridSize = 0.001; // ~100m cells
      path.forEach((point, idx) => {
        const key = `${Math.floor(point.lat() / gridSize)},${Math.floor(point.lng() / gridSize)}`;
        if (!index.has(key)) index.set(key, []);
        index.get(key).push({ point, idx });
      });
      return index;
    }
    const safeOnPositionUpdate = withErrorBoundary(
      _onPositionUpdate,
      (error) => {
        // Fallback: use last known position
        if (navState.lastKnownPosition) {
          _onPositionUpdate({
            coords: {
              latitude: navState.lastKnownPosition.lat,
              longitude: navState.lastKnownPosition.lng,
              speed: 0,
              heading: navState.currentHeading
            }
          }, true);
        }
      },
      'onPositionUpdate'
    );
    function _onPositionUpdate(position, isSimulation = false) {
      console.log('onPositionUpdate called:', { isSimulation });
      try {
        const { latitude, longitude, speed = 0, heading = null } = position.coords;
        console.log('Location update received:', { lat: latitude, lng: longitude, speed, gpsHeading: heading, isSimulation });
        console.log('Navigation state:', { isNavigating: navState.isNavigating, isFollowing: navState.isFollowing });
        const now = Date.now();
        // Allow marker updates always, but throttle camera/route updates
        const shouldUpdateCamera = (now - lastLocationUpdate >= LOCATION_UPDATE_THRESHOLD);
        if (shouldUpdateCamera) {
          lastLocationUpdate = now;
        }
        if (now - lastAlertFetchTime > CONFIG.ALERT_FETCH_INTERVAL && navState.isNavigating) {
          fetchCurrentAlerts();
          lastAlertFetchTime = now;
        }
        navState.previousUserLocation = navState.userLocation;
        rawUserLocation = { lat: latitude, lng: longitude };
        let pos = rawUserLocation;
        let snapped = false;
        let computedHeading = heading;
        if (navState.currentRoute && navState.currentRoute.routes && navState.currentRoute.routes[0]) {
          if (navState.isNavigating && checkArrival(pos)) {
            return;
          }
          checkAlertProximity();
          const path = navState.detailedPath.length > 0 ? navState.detailedPath : navState.currentRoute.routes[0].overview_path;
          // FIXED: Destructure index from findClosestRoutePoint
          const { point, index } = findClosestRoutePoint(pos, path, heading || navState.currentHeading, speed);
          navState.lastSnapIndex = index;
          const distanceToRoute = google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(pos), new google.maps.LatLng(point));
          if (distanceToRoute < CONFIG.SNAP_BUFFER) {
            pos = point; // Snapped to route, don't smooth
            snapped = true;
          } else {
            pos = smoothPosition(rawUserLocation); // Only smooth when off-route
          }
          if (navState.previousUserLocation) {
            const distance = google.maps.geometry.spherical.computeDistanceBetween(
              new google.maps.LatLng(navState.previousUserLocation),
              new google.maps.LatLng(pos)
            );
            // FIXED: Use SMOOTH_THRESHOLD for interpolation (>100m)
            if (distance > CONFIG.MAX_GPS_DISTANCE) {
              const numPoints = Math.ceil(distance / 100);
              const interpolatedPath = [];
              for (let i = 1; i < numPoints; i++) {
                const fraction = i / numPoints;
                const interpolated = google.maps.geometry.spherical.interpolate(
                  new google.maps.LatLng(navState.previousUserLocation),
                  new google.maps.LatLng(pos),
                  fraction
                );
                interpolatedPath.push(interpolated);
              }
              // Animate marker along interpolated path for smoother movement
              let interpIndex = 0;
              const interpInterval = setInterval(() => {
                if (interpIndex < interpolatedPath.length) {
                  const interpPos = interpolatedPath[interpIndex];
                  userMarker.position = interpPos;
                  interpIndex++;
                } else {
                  clearInterval(interpInterval);
                  userMarker.position = pos;
                }
              }, 50);
              console.log('Interpolated path used for smoother marker movement:', { numPoints, distance });
            }
          }
          // FIXED: Use the destructured index
          if (heading == null && speed > CONFIG.STATIONARY_SPEED_THRESHOLD && index < path.length - 1) {
            computedHeading = google.maps.geometry.spherical.computeHeading(new google.maps.LatLng(pos), path[index + 1]);
            console.log('Computed heading from polyline:', computedHeading);
          } else if (heading == null && speed > CONFIG.STATIONARY_SPEED_THRESHOLD && navState.previousUserLocation) {
            computedHeading = google.maps.geometry.spherical.computeHeading(
              new google.maps.LatLng(navState.previousUserLocation),
              new google.maps.LatLng(pos)
            );
            console.log('Computed heading from previous position:', computedHeading);
          }
          const source = speed > CONFIG.STATIONARY_SPEED_THRESHOLD && heading ? 'gps' : speed <= CONFIG.STATIONARY_SPEED_THRESHOLD ? 'lastValid' : needsCalibration ? 'lastValid' : 'compass';
          navState.currentHeading = smoothHeading(computedHeading || compassHeading || navState.lastValidHeading, source, speed, snapped);
          console.log('Heading stabilized:', { gpsHeading: heading, compassHeading, currentHeading: navState.currentHeading, source, speed });
          if (navState.isNavigating) {
            try {
              checkOffRoute(new google.maps.LatLng(pos));
            } catch (error) {
              console.error('checkOffRoute failed:', error);
              showToast('Error checking route deviation. Continuing with raw location.');
            }
          }
        } else {
          const source = speed > CONFIG.STATIONARY_SPEED_THRESHOLD && heading ? 'gps' : 'lastValid';
          navState.currentHeading = smoothHeading(computedHeading || compassHeading || navState.lastValidHeading, source, speed);
        }
        navState.userLocation = pos;
        // Always update marker
        if (userMarker) {
          ProgrammaticUpdateManager.start();
          userMarker.position = pos;
          userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
          ProgrammaticUpdateManager.end();
          console.log('Marker position updated:', { pos, heading: navState.currentHeading, orientation: navState.mapOrientation });
        }
        // FIXED: Ensure marker in view after update
        ensureMarkerInView(pos);
        // FIXED: Update camera more reliably - lower distance threshold to 1m, always update if simulating or significant change
        if (navState.isFollowing && navState.isNavigating) {
          const predictedPos = predictPosition(pos, navState.currentHeading, speed, 500);
          if (shouldUpdateCameraView(pos, navState.currentHeading, Date.now() - navState.lastCameraUpdateTime)) {
            debouncedCameraUpdate(pos, predictedPos, navState.currentHeading, speed);
          }
        }
        lastPosition = pos;
        navState.lastKnownPosition = pos;
        AppHealth.lastGPSUpdate = Date.now();
        if (!isSimulation && socket && socket.connected) {
          socket.emit('locationUpdate', { location: navState.userLocation });
          updateServerLocation(navState.userLocation);
          console.log('Emitted locationUpdate and sent to server:', navState.userLocation);
        }
        updateHUD(navState.currentRoute, navState.userLocation);
        updateCompass();
        if (showTrafficCameras) {
          checkCameraProximity();
        }
        if (navState.trafficForecast) {
          forecastTrafficAhead();
        }
      } catch (error) {
        console.error('Error in position update:', error);
        showToast('Error updating location. Please ensure GPS is enabled.');
      }
    }
    function onPositionUpdate(position, isSimulation = false) {
      safeOnPositionUpdate(position, isSimulation);
    }
    function forecastTrafficAhead() {
      if (Math.random() > 0.8 && navState.isNavigating) {
        showToast('AI Forecast: Heavy traffic 10 miles ahead. Consider reroute.');
        console.log('Simulated traffic forecast alert');
      }
    }
    function lockNavigation() {
      if (dragTimer) {
        clearTimeout(dragTimer);
        dragTimer = null;
      }
      dragStartPos = null;
      navState.isFollowing = true;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      map.setOptions({ gestureHandling: 'none', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
     
      // âœ… FIX: Force immediate camera update instead of just calling restoreNavigationView
      if (navState.userLocation) {
        const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, 0);
        const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
        const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 0);
       
        ProgrammaticUpdateManager.start();
        requestAnimationFrame(() => {
          map.setCenter(lookaheadPoint);
          map.setZoom(zoom);
          map.setHeading(heading);
          map.setTilt(tilt);
          userMarker.position = navState.userLocation;
          console.log('Navigation locked with camera update:', { zoom, heading, tilt });
          ProgrammaticUpdateManager.end();
        });
      }
     
      console.log('Navigation locked');
    }
    function unlockNavigation() {
      navState.isFollowing = false;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      map.setOptions({ gestureHandling: 'cooperative', disableDefaultUI: true, mapTypeControl: false, streetViewControl: false });
      console.log('Navigation unlocked');
    }
    // Auto-save navigation state
    function saveNavState() {
      if (!navState.isNavigating) return;
      const state = {
        destination: navState.destination,
        currentRoute: navState.currentRoute,
        userLocation: navState.userLocation,
        timestamp: Date.now()
      };
      sessionStorage.setItem('navState', JSON.stringify(state));
    }
    // Restore on page load
    function restoreNavState() {
      const saved = sessionStorage.getItem('navState');
      if (!saved) return;
      const state = JSON.parse(saved);
      if (Date.now() - state.timestamp > CONFIG.NAV_STATE_EXPIRY) return; // 5 min expiry
      navState.destination = state.destination;
      calculateAndDisplayRoute(state.userLocation, state.destination);
    }
    // Call periodically
    setInterval(saveNavState, CONFIG.NAV_STATE_SAVE_INTERVAL);
    restoreNavState();
    function startGPS() {
      navState.hasArrived = false;
      if (!navigator.geolocation) {
        showToast('Geolocation is not supported by this browser.');
        console.error('Geolocation not supported');
        return;
      }
      if (!navState.destination) {
        showToast('Please select a destination.');
        console.error('No destination selected');
        return;
      }
      navState.isNavigating = true;
      navState.isFollowing = true;
      navState.isInitialSnap = true;
      localStorage.setItem('isFollowing', navState.isFollowing);
      sessionStorage.setItem('isFollowing', navState.isFollowing);
      document.getElementById('search-container').classList.add('hidden');
      document.getElementById('hud-container').style.display = 'flex';
      document.getElementById('bottom-hud-container').style.display = 'flex';
      lockNavigation();
      if (!wakeLock) requestWakeLock();
      if (navState.currentRoute) {
        const startLocation = navState.currentRoute.routes[0].legs[0].start_location;
        navState.routePolyline = navState.currentRoute.routes[0].overview_path;
        // FIXED: Compute detailed path for better snapping during turns
        navState.detailedPath = [];
        const legs = navState.currentRoute.routes[0].legs;
        for (const leg of legs) {
          for (const step of leg.steps) {
            step.path.forEach(point => navState.detailedPath.push(point));
          }
        }
        console.log('Detailed path computed:', navState.detailedPath.length, 'points');
        updateOffRoadPolyline(rawUserLocation || navState.userLocation, startLocation);
        const path = navState.detailedPath.length > 0 ? navState.detailedPath : navState.routePolyline;
        const { point } = findClosestRoutePoint(navState.userLocation, path, navState.currentHeading, 0);
        const initialPos = point;
        // FIXED: Smooth initial snap using TWEEN
        ProgrammaticUpdateManager.start();
        new TWEEN.Tween({ lat: navState.userLocation.lat, lng: navState.userLocation.lng })
          .to({ lat: initialPos.lat, lng: initialPos.lng }, 500)
          .easing(TWEEN.Easing.Quadratic.Out)
          .onUpdate((obj) => {
            navState.userLocation = { lat: obj.lat, lng: obj.lng };
            userMarker.position = navState.userLocation;
          })
          .onComplete(() => {
            navState.isInitialSnap = false;
            ProgrammaticUpdateManager.end();
            console.log('Initial snap completed smoothly');
          })
          .start();
        console.log('Smooth initial snap started:', { from: navState.userLocation, to: initialPos });
        directionsRenderer.setMap(map);
        directionsRenderer.setDirections(navState.currentRoute);
        updateHUD(navState.currentRoute, navState.userLocation);
        updateBottomHUD(navState.currentRoute);
        fetchCurrentAlerts();
        checkHazardsAndOfferReroute();
        startRerouteCheck();
        navState.ignoredHazards = [];
        navState.hazardCheckInterval = setInterval(checkHazardsAndOfferReroute, 5000);
        if (showTrafficCameras) {
          cameraCheckInterval = setInterval(checkCameraProximity, CONFIG.CAMERA_CHECK_INTERVAL);
        }
        // Keep ONLY the existing hazard/camera intervals
        if (watchId) {
          navigator.geolocation.clearWatch(watchId);
        }
        watchId = navigator.geolocation.watchPosition(
          onPositionUpdate,
          (error) => {
            console.error('Geolocation watch error:', error);
            handleGeolocationError(error);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 5000
          }
        );
        console.log('GPS tracking started, watchId:', watchId);
        const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, 0);
        navState.navigationZoom = zoom;
        const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
        const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 0);
        ProgrammaticUpdateManager.start();
        requestAnimationFrame(() => {
          if (isMobile && typeof TWEEN !== 'undefined') {
            new TWEEN.Tween(map.getCenter())
              .to({ lat: lookaheadPoint.lat(), lng: lookaheadPoint.lng() }, 300)
              .easing(TWEEN.Easing.Quadratic.Out)
              .onUpdate(() => map.setCenter({ lat: lookaheadPoint.lat(), lng: lookaheadPoint.lng() }))
              .start();
            updateMapHeading(heading);
          } else {
            map.panTo(lookaheadPoint);
            map.setHeading(heading);
          }
          lastProgrammaticZoom = zoom;
          map.setZoom(zoom);
          map.setTilt(tilt);
          userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
          console.log('Initial navigation view set:', { center: lookaheadPoint.toJSON(), zoom, heading, tilt, orientation: navState.mapOrientation });
          ProgrammaticUpdateManager.end();
        });
        onPositionUpdate({
          coords: {
            latitude: navState.userLocation.lat,
            longitude: navState.userLocation.lng,
            speed: 0,
            heading: navState.currentHeading
          }
        });
      }
    }
    function handleGeolocationError(error, isInitial = false) {
      let message;
      switch (error.code) {
        case 1:
          message = 'Location access denied. Please enable location permissions in browser settings.';
          break;
        case 2:
          message = 'Location unavailable. Ensure location services are enabled.';
          break;
        case 3:
          message = 'Weak GPS signal, using last known position...';
          if (navState.lastKnownPosition && navState.isNavigating) {
            const now = Date.now();
            if (now - lastLocationUpdate < 10000) {
              onPositionUpdate({
                coords: {
                  latitude: navState.lastKnownPosition.lat,
                  longitude: navState.lastKnownPosition.lng,
                  speed: 0,
                  heading: navState.currentHeading
                }
              });
              console.log('Using cached position due to GPS timeout:', navState.lastKnownPosition);
              return;
            } else {
              message = 'GPS signal lost for too long. Searching for GPS...';
            }
          }
          break;
        default:
          message = 'Failed to get location. Please try again later.';
      }
      console.error('Geolocation error:', { code: error.code, message: error.message });
      showToast(message);
      if (isInitial && retryCount < MAX_RETRIES) {
        retryCount++;
        const backoff = 5000 * Math.pow(2, retryCount);
        console.log(`Retrying geolocation (attempt ${retryCount}/${MAX_RETRIES}, backoff: ${backoff}ms)`);
        setTimeout(() => navigator.geolocation.getCurrentPosition(
          (position) => {
            navState.userLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };
            rawUserLocation = navState.userLocation;
            console.log('Initial location:', navState.userLocation);
            requestDeviceOrientationPermission();
            loadGoogleMaps();
          },
          (error) => {
            console.error('Retry geolocation error:', error);
            handleGeolocationError(error, true);
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          }
        ), backoff);
      } else if (isInitial) {
        navState.userLocation = { lat: 33.083270, lng: -83.233040 };
        rawUserLocation = navState.userLocation;
        console.log('Using fallback location:', navState.userLocation);
        loadGoogleMaps(); // â† Fallback map load
      }
    }
    function stopGPS() {
      navState.hasArrived = false;
      navState.alertProximities.clear();
      cleanupResources();
      releaseWakeLock();
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
        console.log('GPS tracking stopped.');
      }
      if (mockSimulationInterval) {
        clearInterval(mockSimulationInterval);
        mockSimulationInterval = null;
        document.getElementById('simulate-position-button').textContent = 'Simulate';
        console.log('Position simulation stopped');
      }
      if (navState.rerouteCheckTimeout) {
        clearTimeout(navState.rerouteCheckTimeout);
        navState.rerouteCheckTimeout = null;
      }
      if (navState.hazardCheckInterval) {
        clearInterval(navState.hazardCheckInterval);
        navState.hazardCheckInterval = null;
      }
      if (cameraCheckInterval) {
        clearInterval(cameraCheckInterval);
        cameraCheckInterval = null;
      }
      if (alertPollInterval) {
        clearInterval(alertPollInterval);
        alertPollInterval = null;
        console.log('Alert polling stopped.');
      }
      if (routePolyline) {
        routePolyline.setMap(null);
        routePolyline = null;
      }
      if (offRoadPolyline) {
        offRoadPolyline.setMap(null);
        offRoadPolyline = null;
      }
      // Stop all tweens
      if (currentHeadingTween) {
        currentHeadingTween.stop();
        currentHeadingTween = null;
      }
      TWEEN.removeAll();
      // Clear all intervals/timeouts
      [cameraCheckInterval, alertPollInterval, navState.rerouteCheckTimeout,
       navState.hazardCheckInterval, mockSimulationInterval, dragTimer].forEach(id => {
        if (id) clearInterval(id);
        if (id) clearTimeout(id);
      });
      // Add to stopGPS()
      routeSpatialIndex = null;
      google.maps.event.clearInstanceListeners(map);
      google.maps.event.clearInstanceListeners(userMarker);
      // Clean up TWEEN animations
      TWEEN.removeAll();
      // Clear all intervals/timeouts
      [cameraCheckInterval, alertPollInterval, navState.rerouteCheckTimeout,
       navState.hazardCheckInterval, mockSimulationInterval, dragTimer].forEach(id => {
        if (id) clearInterval(id);
        if (id) clearTimeout(id);
      });
      ProgrammaticUpdateManager.end();
      navState.isNavigating = false;
      navState.isFollowing = false;
      navState.isInitialSnap = false;
      navState.currentRoute = null;
      navState.originalRoute = null;
      navState.routePolyline = null;
      navState.detailedPath = [];
      navState.lastSnapIndex = 0;
      navState.ignoredHazards = [];
      navState.currentHazard = null;
      navState.alternativeRoute = null;
      navState.lastRecalculationTime = 0;
      navState.currentHeading = 0;
      navState.lastValidHeading = 0;
      headingHistory = [];
      lastLocationUpdate = 0;
      lastAlertFetchTime = 0;
      lastPosition = null;
      rawUserLocation = null;
      positionHistory = [];
      document.getElementById('search-container').classList.remove('hidden');
      document.getElementById('search-container').style.display = 'flex';
      document.getElementById('hud-container').style.display = 'none';
      document.getElementById('bottom-hud-container').style.display = 'none';
      document.getElementById('simulate-position-button').style.display = 'none';
      alternativeRenderer.setMap(null);
      directionsRenderer.setMap(null);
      trafficLayer.setMap(null);
      if (destMarker) destMarker.setMap(null);
      document.getElementById('start-button').style.display = 'none';
      map.setOptions({
        zoom: 15,
        tilt: 0,
        heading: navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading,
        disableDefaultUI: true,
        gestureHandling: 'cooperative',
        mapTypeControl: false,
        streetViewControl: false
      });
      requestAnimationFrame(() => {
        map.setCenter(navState.userLocation);
        console.log('Navigation stopped, reset to:', { center: navState.userLocation, zoom: 15, heading: navState.mapOrientation === 'north-up' ? 0 : navState.currentHeading, tilt: 0 });
      });
    }
    function cleanupResources() {
      // Stop all intervals/timeouts
      [cameraCheckInterval, alertPollInterval, navState.rerouteCheckTimeout,
       navState.hazardCheckInterval, mockSimulationInterval, dragTimer,
       postingTimeout].forEach(id => {
        if (id) {
          clearInterval(id);
          clearTimeout(id);
        }
      });
      // Release all markers
      markers.forEach(marker => releaseMarker(marker));
      markers.clear();
      // Clear all caches
      alertCache.clear();
      headingCache.clear();
      markerPool.length = 0;
      // Stop all tweens
      TWEEN.removeAll();
      if (currentHeadingTween) {
        currentHeadingTween.stop();
        currentHeadingTween = null;
      }
      // Remove event listeners
      if (navState.mapClickListener) {
        google.maps.event.removeListener(navState.mapClickListener);
      }
      google.maps.event.clearInstanceListeners(map);
      google.maps.event.clearInstanceListeners(userMarker);
      // Disconnect socket
      if (socket) {
        socket.disconnect();
        socket = null;
      }
      // Release wake lock
      releaseWakeLock();
      // Clear service worker cache periodically
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_OLD_CACHE' });
      }
    }
    function updateHUD(route, currentPos) {
  const hudTurn = document.getElementById('hud-turn');
  const hudStreet = document.getElementById('hud-street');
  const hudHeading = document.getElementById('hud-heading');
  if (!route || !route.routes || !route.routes[0]) {
    hudTurn.textContent = 'Follow the road';
    hudStreet.textContent = 'Current street: Loading...';
    hudHeading.textContent = `Heading: ${Math.round(navState.currentHeading || 0)}Â°`;
    console.log('No route data, HUD set to default');
    return;
  }
  const path = route.routes[0].overview_path;
  let closestPoint = null;
  let minDistance = Infinity;
  const currentLatLng = new google.maps.LatLng(currentPos);
  path.forEach(point => {
    const distance = google.maps.geometry.spherical.computeDistanceBetween(currentLatLng, point);
    if (distance < minDistance) {
      minDistance = distance;
      closestPoint = point;
    }
  });
  let currentStep = null;
  let nextStep = null;
  const legs = route.routes[0].legs[0];
  for (let i = 0; i < legs.steps.length; i++) {
    const stepPath = legs.steps[i].path;
    if (stepPath.some(pt => google.maps.geometry.spherical.computeDistanceBetween(pt, closestPoint) < 20)) {
      currentStep = legs.steps[i];
      nextStep = legs.steps[i + 1] || null;
      break;
    }
  }
  hudStreet.textContent = currentStep && currentStep.instructions
    ? `Current street: ${stripHtml(currentStep.instructions)}`
    : 'Current street: Loading...';
  hudHeading.textContent = `Heading: ${Math.round(navState.currentHeading || 0)}Â°`;
  if (nextStep && nextStep.maneuver) {
    const distanceToTurn = google.maps.geometry.spherical.computeDistanceBetween(
      currentLatLng,
      new google.maps.LatLng(nextStep.start_location)
    );
    if (distanceToTurn <= CONFIG.TURN_THRESHOLD) {
      const distanceText = distanceToTurn < 1609.34
        ? `${Math.round(distanceToTurn * 3.28084)} feet`
        : `${(distanceToTurn / 1609.34).toFixed(1)} miles`;
      const turnText = `${nextStep.maneuver.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase())} in ${distanceText}`;
      hudTurn.textContent = turnText;
      const now = Date.now();
      if (turnText !== lastSpokenTurn && now - lastAnnouncementTime > CONFIG.ANNOUNCEMENT_COOLDOWN && 'speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(turnText);
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
        lastSpokenTurn = turnText;
        lastAnnouncementTime = now;
      }
    } else {
      hudTurn.textContent = 'Follow the road';
    }
  } else {
    hudTurn.textContent = 'Follow the road';
  }
}
    function calculateAndDisplayRoute(origin, dest, callback) {
  if (!origin || !dest) {
    console.error('Invalid origin or destination:', origin, dest);
    showToast('Invalid route. Please select a destination.');
    return;
  }
  const waypoints = navState.waypoints.map(w => ({ location: w, stopover: true }));
  const request = {
    origin: origin,
    destination: dest,
    travelMode: google.maps.TravelMode.DRIVING,
    provideRouteAlternatives: true,
    waypoints: waypoints,
    avoidTolls: navState.avoidTolls,
    avoidHighways: navState.avoidHighways
  };
  if (navState.evCharging) {
    request.waypoints.unshift({ location: 'EV charging station near origin', stopover: true });
  }
  directionsService.route(request, (response, status) => {
    if (status === 'OK') {
      navState.currentRoute = response;
      navState.routePolyline = response.routes[0].overview_path;
      navState.detailedPath = [];
      const legs = response.routes[0].legs;
      for (const leg of legs) {
        for (const step of leg.steps) {
          step.path.forEach(point => navState.detailedPath.push(point));
        }
      }
      navState.detailedPath = navState.detailedPath.filter((point, index, self) =>
        index === self.findIndex(p => Math.abs(p.lat() - point.lat()) < 1e-6 && Math.abs(p.lng() - point.lng()) < 1e-6)
      );
      console.log('Detailed path computed for route:', navState.detailedPath.length, 'points');
      directionsRenderer.setMap(map);
      directionsRenderer.setDirections(response);
      updateRouteAhead(navState.userLocation);
      updateOffRoadPolyline(rawUserLocation || navState.userLocation, response.routes[0].overview_path[0]);
      updateHUD(response, navState.userLocation);
      updateBottomHUD(response);
      routeSpatialIndex = null;
      if (callback) callback();
      // Show simulation button
      document.getElementById('simulate-position-button').style.display = 'block';
      if (navState.isFollowing && navState.isNavigating) {
        const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, 0);
        navState.navigationZoom = zoom;
        const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
        const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 0);
        ProgrammaticUpdateManager.start();
        requestAnimationFrame(() => {
          if (isMobile && typeof TWEEN !== 'undefined') {
            new TWEEN.Tween(map.getCenter())
              .to({ lat: lookaheadPoint.lat(), lng: lookaheadPoint.lng() }, 300)
              .easing(TWEEN.Easing.Quadratic.Out)
              .onUpdate(() => map.setCenter({ lat: lookaheadPoint.lat(), lng: lookaheadPoint.lng() }))
              .start();
            updateMapHeading(heading);
          } else {
            map.panTo(lookaheadPoint);
            map.setHeading(heading);
          }
          lastProgrammaticZoom = zoom;
          map.setZoom(zoom);
          map.setTilt(tilt);
          userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
          console.log('Route calculated, camera set:', { center: lookaheadPoint.toJSON(), zoom, heading, tilt });
          ProgrammaticUpdateManager.end();
        });
      }
      console.log('Route calculated:', {
        pathLength: navState.routePolyline.length,
        endPoint: navState.routePolyline[navState.routePolyline.length - 1],
        destination: dest
      });
    } else {
      console.error('Directions request failed:', status);
      showToast('Directions request failed: ' + status);
      if (status === 'REQUEST_DENIED') {
        showToast('API key invalid or restricted. Check Google Cloud Console.');
      }
    }
  });
}
    function updateBottomHUD(route) {
      const hudTime = document.getElementById('bottom-hud-time');
      const hudDistance = document.getElementById('bottom-hud-distance');
      if (!route || !route.routes[0]) {
        hudTime.textContent = '0 Mins';
        hudDistance.textContent = '0 miles - Unknown';
        return;
      }
      const leg = route.routes[0].legs[0];
      const duration = leg.duration.value;
      const distanceM = leg.distance.value;
      const distanceMi = (distanceM / 1609.34).toFixed(1);
      const currentTime = new Date();
      const arrivalTime = new Date(currentTime.getTime() + duration * 1000);
      const formattedTime = arrivalTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      hudTime.textContent = `${Math.round(duration / 60)} Mins`;
      hudDistance.textContent = `${distanceMi} miles - ${formattedTime}`;
    }
    function stripHtml(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      return div.textContent || div.innerText || 'Unknown';
    }
    function startRerouteCheck() {
      if (navState.rerouteCheckTimeout) {
        clearTimeout(navState.rerouteCheckTimeout);
      }
      navState.rerouteCheckTimeout = setTimeout(() => {
        if (navState.isNavigating && navState.currentRoute && navState.userLocation && navState.routePolyline) {
          const userLatLng = new google.maps.LatLng(navState.userLocation);
          checkOffRoute(userLatLng);
        }
        startRerouteCheck();
      }, CONFIG.REROUTE_CHECK_INTERVAL);
    }
    function checkOffRoute(userLatLng) {
      if (!navState.isNavigating || !navState.currentRoute || !navState.routePolyline) {
        console.log('checkOffRoute skipped: Not navigating or no route data');
        return false;
      }
      const routePolyline = new google.maps.Polyline({ path: navState.routePolyline });
      if (!google.maps.geometry.poly.isLocationOnEdge(userLatLng, routePolyline, CONFIG.OFF_ROUTE_TOLERANCE / 111000)) {
        console.log('User off-route detected, recalculating...', { distance: CONFIG.OFF_ROUTE_TOLERANCE });
        showToast('You are off-route. Recalculating route...');
        calculateAndDisplayRoute(navState.userLocation, navState.destination, () => {
          console.log('Route recalculated due to off-route detection');
          showToast('Route recalculated.');
          if (navState.isFollowing) {
            lockNavigation();
          }
        });
        return true;
      }
      return false;
    }
    function createAlertContent() {
      const content = document.createElement('div');
      content.style.width = '20px';
      content.style.height = '20px';
      content.style.backgroundColor = 'red';
      content.style.borderRadius = '50%';
      content.style.border = '2px solid white';
      content.classList.add('ping');
      return content;
    }
    function createTrafficCameraContent() {
      const content = document.createElement('img');
      content.src = 'https://i.postimg.cc/jjN0JrPZ/New-Project-5.png';
      content.className = 'traffic-cam-marker';
      return content;
    }
    function checkCameraProximity() {
      if (!showTrafficCameras || !navState.userLocation) return;
      const now = Date.now();
      if (now - navState.lastCameraUpdate < CONFIG.CAMERA_UPDATE_THRESHOLD) {
        console.log('Skipping camera proximity check due to throttle');
        return;
      }
      navState.lastCameraUpdate = now;
      const userLatLng = new google.maps.LatLng(navState.userLocation);
      for (const camera of cameraPositions) {
        const cameraLatLng = new google.maps.LatLng(camera);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(userLatLng, cameraLatLng);
        const cameraKey = `static-${camera.lat.toFixed(4)}-${camera.lng.toFixed(4)}`;
        if (distance <= cameraAlertDistance * 1609.34 && !cameraAlertShown.has(cameraKey)) {
          showCameraHud();
          cameraAlertShown.add(cameraKey);
          console.log('Traffic camera alert triggered:', { distance, camera });
          break;
        }
      }
      for (const alert of currentAlerts) {
        if (alert.type !== 'Traffic Camera') continue;
        const alertLatLng = new google.maps.LatLng(alert.location.coordinates[1], alert.location.coordinates[0]);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(userLatLng, alertLatLng);
        const alertKey = `mongo-${alert._id}`;
        if (distance <= cameraAlertDistance * 1609.34 && !cameraAlertShown.has(alertKey)) {
          showCameraHud();
          cameraAlertShown.add(alertKey);
          console.log('MongoDB traffic camera alert triggered:', { distance, alertId: alert._id });
          break;
        }
      }
    }
    function checkAlertProximity() {
      if (!navState.isNavigating || !navState.userLocation) return;
      const userLatLng = new google.maps.LatLng(navState.userLocation);
      currentAlerts.forEach(alert => {
        if (alert.type === 'Traffic Camera') return;
        const alertLatLng = new google.maps.LatLng(alert.location.coordinates[1], alert.location.coordinates[0]);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(userLatLng, alertLatLng);
        const alertId = alert._id;
        const previousDistance = navState.alertProximities.get(alertId) || Infinity;
        navState.alertProximities.set(alertId, distance);
        if (distance <= CONFIG.VERIFICATION_DISTANCE && previousDistance > CONFIG.VERIFICATION_DISTANCE) {
          currentVerificationAlertId = alertId;
          document.getElementById('verification-message').textContent = `Passed ${alert.type} alert. Is it still valid?`;
          const verificationHudContainer = document.getElementById('verification-hud-container');
          const verificationHud = document.getElementById('verification-hud');
          verificationHud.classList.add('active');
          verificationHudContainer.classList.add('active');
          console.log('Alert verification HUD shown for:', alertId);
        }
      });
    }
    async function updateServerLocation(position) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, skipping server location update');
          return;
        }
        const response = await fetchWithRetry('/api/location', {
          method: 'POST',
          mode: 'cors',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            location: {
              type: 'Point',
              coordinates: [position.lng, position.lat]
            }
          })
        });
        if (!response.ok) {
          console.error('Failed to update server location:', response.statusText);
        } else {
          console.log('Server location updated:', position);
        }
      } catch (error) {
        console.error('Error updating server location:', error);
      }
    }
    function ensureMarkerInView(position) {
      if (!map || !position || !navState.isFollowing) return;
      const now = Date.now();
      if (now - lastBoundsCheck < BOUNDS_CHECK_INTERVAL) return;
      lastBoundsCheck = now;
      const bounds = map.getBounds();
      if (!bounds) {
        console.warn('Map bounds unavailable, cannot check viewport');
        return;
      }
      const ne = bounds.getNorthEast();
      const sw = bounds.getSouthWest();
      const latSpan = ne.lat() - sw.lat();
      const lngSpan = ne.lng() - sw.lng();
      const edgeThresholdLat = latSpan * 0.2;
      const edgeThresholdLng = lngSpan * 0.2;
      const isNearEdge =
        position.lat > ne.lat() - edgeThresholdLat ||
        position.lat < sw.lat() + edgeThresholdLat ||
        position.lng > ne.lng() - edgeThresholdLng ||
        position.lng < sw.lng() + edgeThresholdLng;
      if (isNearEdge) {
        console.log('Marker near viewport edge, ensuring in view');
        requestAnimationFrame(() => {
          map.setCenter(position);
        });
      }
    }
    function checkHazardsAndOfferReroute() {
      if (!navState.isNavigating || !navState.currentRoute || !navState.userLocation) {
        console.log('Hazard check skipped: Not navigating or no route/location data');
        return;
      }
      const userLatLng = new google.maps.LatLng(navState.userLocation);
      const path = navState.currentRoute.routes[0].overview_path;
      // Use detailed path if available for more accurate detection
      const checkPath = navState.detailedPath.length > 0 ? navState.detailedPath : path;
      const routeIndex = buildRouteIndex(checkPath);
      for (const alert of currentAlerts) {
        // Skip traffic cameras and already ignored hazards
        if (alert.type === 'Traffic Camera' || navState.ignoredHazards.includes(alert._id)) continue;
        const filterKey = alert.type.toLowerCase().replace(/\s+/g, '-');
        if (navState.alertFilters[filterKey] === false) continue;
        const alertLatLng = new google.maps.LatLng(alert.location.coordinates[1], alert.location.coordinates[0]);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(userLatLng, alertLatLng);
        // Check if alert is within warning distance
        if (distance <= hazardAlertDistance * 1609.34) {
          let isOnRoute = false;
          let minDistanceToRoute = Infinity;
          const gridKey = `${Math.floor(alertLatLng.lat() / 0.001)},${Math.floor(alertLatLng.lng() / 0.001)}`;
          if (!routeIndex.has(gridKey)) continue; // Not near route
          // Now check actual distance only for nearby cells
          const nearbyPoints = routeIndex.get(gridKey);
          for (const { point } of nearbyPoints) {
            const pointLatLng = new google.maps.LatLng(point);
            const distanceToPoint = google.maps.geometry.spherical.computeDistanceBetween(alertLatLng, pointLatLng);
            minDistanceToRoute = Math.min(minDistanceToRoute, distanceToPoint);
            // Increased threshold to 100 meters for better detection
            if (distanceToPoint < 100) {
              isOnRoute = true;
              break;
            }
          }
          if (isOnRoute) {
            console.log('Hazard detected on route:', {
              alertId: alert._id,
              type: alert.type,
              distanceToUser: distance,
              minDistanceToRoute: minDistanceToRoute
            });
            navState.currentHazard = alert;
            calculateAlternativeRoute(alert);
            break;
          } else {
            console.log('Alert nearby but not on route:', {
              alertId: alert._id,
              type: alert.type,
              minDistanceToRoute: minDistanceToRoute
            });
          }
        }
      }
    }
    function calculateAlternativeRoute(hazard) {
      if (!navState.isNavigating || !navState.currentRoute || !navState.userLocation || !navState.destination) {
        console.log('Alternative route calculation skipped: Missing navigation data');
        return;
      }
      const hazardLatLng = new google.maps.LatLng(hazard.location.coordinates[1], hazard.location.coordinates[0]);
      const waypoints = navState.waypoints.map(w => ({ location: w, stopover: true }));
      const request = {
        origin: navState.userLocation,
        destination: navState.destination,
        travelMode: google.maps.TravelMode.DRIVING,
        provideRouteAlternatives: true,
        waypoints: waypoints,
        avoidTolls: navState.avoidTolls,
        avoidHighways: navState.avoidHighways,
        region: 'US'
      };
      directionsService.route(request, (response, status) => {
        if (status === 'OK' && response.routes.length > 1) {
          let selectedRoute = null;
          let timeSaved = 0;
          const mainRouteDuration = navState.currentRoute.routes[0].legs[0].duration.value;
          for (const route of response.routes) {
            let intersectsHazard = false;
            for (const point of route.overview_path) {
              const pointLatLng = new google.maps.LatLng(point);
              const distance = google.maps.geometry.spherical.computeDistanceBetween(hazardLatLng, pointLatLng);
              if (distance < CONFIG.ALTERNATE_TRIGGER_DISTANCE) {
                intersectsHazard = true;
                break;
              }
            }
            if (!intersectsHazard) {
              selectedRoute = route;
              timeSaved = mainRouteDuration - route.legs[0].duration.value;
              if (timeSaved > 60) {
                break;
              }
            }
          }
          if (selectedRoute) {
            navState.alternativeRoute = response;
            alternativeRenderer.setDirections(response);
            alternativeRenderer.setRouteIndex(response.routes.indexOf(selectedRoute));
            alternativeRenderer.setMap(map);
            showRerouteHud(hazard, timeSaved);
            console.log('Alternative route calculated:', {
              hazardId: hazard._id,
              timeSaved: timeSaved / 60,
              pathLength: selectedRoute.overview_path.length
            });
          } else {
            console.log('No viable alternative route found');
          }
        } else {
          console.log('Alternative route request failed:', status);
        }
      });
    }
    function showRerouteHud(hazard, timeSaved) {
      if (!document.getElementById('reroute-hud-container').classList.contains('active')) {
        navState.alertState = 'OFFERING_REROUTE';
        const rerouteHudContainer = document.getElementById('reroute-hud-container');
        const rerouteHud = document.getElementById('reroute-hud');
        const hazardMessage = document.getElementById('hazard-message');
        const timeText = timeSaved > 0 ? `Saves ${Math.round(timeSaved / 60)} minutes` : 'Avoids hazard';
        hazardMessage.textContent = `A ${hazard.type} is ahead on your route. Reroute available. ${timeText}.`;
        rerouteHudContainer.classList.add('active');
        rerouteHud.classList.add('active');
        unlockNavigation();
        console.log('Reroute HUD shown:', { hazardId: hazard._id, type: hazard.type, timeSaved });
      } else {
        console.log('Reroute HUD already open, queuing reroute offer');
        navState.pendingReroute = { hazard, timeSaved };
      }
    }
    function acceptReroute() {
      if (!navState.alternativeRoute) {
        console.error('No alternative route available');
        return;
      }
      navState.currentRoute = navState.alternativeRoute;
      navState.routePolyline = navState.alternativeRoute.routes[0].overview_path;
     
      // Recompute detailed path for alternative route
      navState.detailedPath = [];
      const legs = navState.currentRoute.routes[0].legs;
      for (const leg of legs) {
        for (const step of leg.steps) {
          step.path.forEach(point => navState.detailedPath.push(point));
        }
      }
      navState.detailedPath = navState.detailedPath.filter((point, index, self) =>
        index === self.findIndex(p => Math.abs(p.lat() - point.lat()) < 1e-6 && Math.abs(p.lng() - point.lng()) < 1e-6)
      );
     
      directionsRenderer.setDirections(navState.currentRoute);
      directionsRenderer.setMap(map);
      alternativeRenderer.setMap(null);
      updateRouteAhead(navState.userLocation);
      updateHUD(navState.currentRoute, navState.userLocation);
      updateBottomHUD(navState.currentRoute);
     
      navState.ignoredHazards.push(navState.currentHazard._id);
      navState.currentHazard = null;
      navState.alternativeRoute = null;
     
      const rerouteHudContainer = document.getElementById('reroute-hud-container');
      const rerouteHud = document.getElementById('reroute-hud');
      rerouteHudContainer.classList.remove('active');
      rerouteHud.classList.remove('active');
      navState.alertState = 'IDLE';
     
      // âœ… FIX: Force camera update before locking
      const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, 0);
      const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
      const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 0);
     
      ProgrammaticUpdateManager.start();
      requestAnimationFrame(() => {
        map.setCenter(lookaheadPoint);
        map.setZoom(zoom);
        map.setHeading(heading);
        map.setTilt(tilt);
        userMarker.position = navState.userLocation;
        userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
        console.log('Camera restored after reroute accept:', { zoom, heading, tilt });
        ProgrammaticUpdateManager.end(() => {
          // Now lock navigation after camera is set
          if (navState.isFollowing) {
            lockNavigation();
          }
        });
      });
     
      showToast('Reroute accepted.');
      console.log('Reroute accepted, navigation updated');
    }
    function rejectReroute() {
      if (navState.currentHazard) {
        navState.ignoredHazards.push(navState.currentHazard._id);
        console.log('Hazard ignored:', navState.currentHazard._id);
      }
     
      alternativeRenderer.setMap(null);
      navState.alternativeRoute = null;
      navState.currentHazard = null;
     
      const rerouteHudContainer = document.getElementById('reroute-hud-container');
      const rerouteHud = document.getElementById('reroute-hud');
      rerouteHudContainer.classList.remove('active');
      rerouteHud.classList.remove('active');
      navState.alertState = 'IDLE';
     
      // âœ… FIX: Force camera update before locking
      const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, 0);
      const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
      const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 0);
     
      ProgrammaticUpdateManager.start();
      requestAnimationFrame(() => {
        map.setCenter(lookaheadPoint);
        map.setZoom(zoom);
        map.setHeading(heading);
        map.setTilt(tilt);
        userMarker.position = navState.userLocation;
        userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
        console.log('Camera restored after reroute reject:', { zoom, heading, tilt });
        ProgrammaticUpdateManager.end(() => {
          // Now lock navigation after camera is set
          if (navState.isFollowing) {
            lockNavigation();
          }
        });
      });
     
      showToast('Reroute rejected.');
      console.log('Reroute rejected, continuing on original route');
    }
    function showCameraHud() {
      if (document.getElementById('camera-hud-container').classList.contains('active')) {
        console.log('Camera HUD already open, skipping');
        return;
      }
      const cameraHudContainer = document.getElementById('camera-hud-container');
      const cameraHud = document.getElementById('camera-hud');
      cameraHudContainer.classList.add('active');
      cameraHud.classList.add('active');
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance('Traffic camera ahead. Drive safely.');
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
      }
      console.log('Camera HUD shown');
    }
    function dismissCameraAlert() {
      const cameraHudContainer = document.getElementById('camera-hud-container');
      const cameraHud = document.getElementById('camera-hud');
      cameraHudContainer.classList.remove('active');
      cameraHud.classList.remove('active');
      if (navState.isFollowing) {
        lockNavigation();
      }
      console.log('Camera HUD dismissed');
    }
    function toggleAccordion(header) {
      const content = header.nextElementSibling;
      const isActive = header.classList.contains('active');
      document.querySelectorAll('.accordion-header').forEach(h => {
        h.classList.remove('active');
        h.nextElementSibling.classList.remove('active');
      });
      if (!isActive) {
        header.classList.add('active');
        content.classList.add('active');
      }
      console.log('Accordion toggled:', header.textContent, 'Active:', !isActive);
    }
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('visible-toast');
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => {
        toast.classList.remove('visible-toast');
      }, duration);
      console.log('Toast shown:', message);
    }
    function startPositionSimulation() {
      if (!navState.currentRoute || !navState.currentRoute.routes[0]) {
        showToast('No route to simulate.');
        console.error('No route for simulation');
        return;
      }
      const path = navState.currentRoute.routes[0].overview_path;
      let index = 0;
      mockSimulationInterval = setInterval(() => {
        if (index >= path.length) {
          clearInterval(mockSimulationInterval);
          mockSimulationInterval = null;
          document.getElementById('simulate-position-button').textContent = 'Simulate';
          console.log('Simulation completed');
          document.getElementById('arrival-hud-container').classList.add('active');
          document.getElementById('arrival-hud').classList.add('active');
          // FIXED: Reset lastCameraPosition after simulation completion
          lastCameraPosition = null;
          return;
        }
        const point = path[index];
        const nextPoint = index < path.length - 1 ? path[index + 1] : point;
        const heading = google.maps.geometry.spherical.computeHeading(
          new google.maps.LatLng(point),
          new google.maps.LatLng(nextPoint)
        );
        onPositionUpdate({
          coords: {
            latitude: point.lat(),
            longitude: point.lng(),
            speed: 10,
            heading: heading
          }
        }, true);
        index += 1;
        console.log('Simulated position:', { lat: point.lat(), lng: point.lng(), index, totalPoints: path.length });
      }, 1000);
    }
    function restoreNavigationView() {
      if (!navState.isNavigating || !navState.isFollowing || !navState.userLocation) {
        console.log('Cannot restore navigation view:', {
          isNavigating: navState.isNavigating,
          isFollowing: navState.isFollowing,
          userLocation: !!navState.userLocation
        });
        return;
      }
      const { zoom, tilt, turnHeading } = getDynamicZoom(navState.userLocation, 0);
      navState.navigationZoom = zoom;
      const heading = navState.mapOrientation === 'north-up' ? 0 : turnHeading || navState.currentHeading;
      const lookaheadPoint = getLookaheadPoint(navState.userLocation, heading, 0);
      ProgrammaticUpdateManager.start();
      requestAnimationFrame(() => {
        if (isMobile && typeof TWEEN !== 'undefined') {
          new TWEEN.Tween(map.getCenter())
            .to({ lat: lookaheadPoint.lat(), lng: lookaheadPoint.lng() }, 300)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(() => map.setCenter({ lat: lookaheadPoint.lat(), lng: lookaheadPoint.lng() }))
            .start();
          updateMapHeading(heading);
        } else {
          map.panTo(lookaheadPoint);
          map.setHeading(heading);
        }
        lastProgrammaticZoom = zoom;
        map.setZoom(zoom);
        map.setTilt(tilt);
        userMarker.content.style.transform = `rotate(${navState.mapOrientation === 'north-up' ? navState.currentHeading : 0}deg)`;
        console.log('Navigation view restored:', { center: lookaheadPoint.toJSON(), zoom, heading, tilt });
        ProgrammaticUpdateManager.end();
      });
    }
    async function fetchUsers(query = '') {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching users with token:', token.substring(0, 20) + '...', 'Query:', query);
        const url = query ? `/api/users/search?query=${encodeURIComponent(query)}` : '/api/users';
        const response = await fetchWithRetry(url, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Users fetch response:', { status: response.status, ok: response.ok });
        const users = await response.json();
        displayUsers(users);
      } catch (error) {
        console.error('Error fetching users:', error);
        showToast('Failed to fetch users.');
      }
    }
    function displayUsers(users) {
      const usersList = document.getElementById('users-list');
      usersList.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Username</th>
              <th>Email</th>
              <th>Role</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            ${users.map(user => `
              <tr>
                <td>${user.username}</td>
                <td>${user.email}</td>
                <td>${user.isAdmin ? 'Admin' : 'User'}</td>
                <td>
                  <button class="view-activity-btn" onclick="loadUserActivity('${user._id}')">View Activity</button>
                  ${user.isAdmin ? `<button class="demote-btn" onclick="demoteUser('${user._id}')">Demote</button>` : `<button class="promote-btn" onclick="promoteUser('${user._id}')">Promote</button>`}
                  <button class="delete-btn" onclick="deleteUser('${user._id}')">Delete</button>
                  <button class="ban-btn" onclick="banUser('${user._id}')">Ban</button>
                  <button class="ipban-btn" onclick="ipBanUser('${user._id}')">IP Ban</button>
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      `;
      console.log('Users displayed:', users.length);
    }
    async function loadUserActivity(userId) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching user activity with token:', token.substring(0, 20) + '...', 'User ID:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/activity`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('User activity fetch response:', { status: response.status, ok: response.ok });
        const activities = await response.json();
        selectedUserId = userId;
        document.querySelector('.admin-tab[data-tab="activity"]').click();
        const activityList = document.getElementById('user-activity-list');
        activityList.innerHTML = activities.length > 0 ? activities.map(activity => `
          <li><strong>${activity.type}</strong> - ${activity.description} at ${new Date(activity.timestamp).toLocaleString()}</li>
        `).join('') : '<li class="no-activity">No activity found</li>';
        console.log('User activity displayed:', activities.length);
      } catch (error) {
        console.error('Error fetching user activity:', error);
        showToast('Failed to fetch user activity.');
      }
    }
    async function promoteUser(userId) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Promoting user with token:', token.substring(0, 20) + '...', 'User ID:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/promote`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Promote user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User promoted to admin.');
          fetchUsers();
        } else {
          throw new Error('Failed to promote user');
        }
      } catch (error) {
        console.error('Error promoting user:', error);
        showToast('Failed to promote user.');
      }
    }
    async function demoteUser(userId) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Demoting user with token:', token.substring(0, 20) + '...', 'User ID:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/demote`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Demote user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User demoted from admin.');
          fetchUsers();
        } else {
          throw new Error('Failed to demote user');
        }
      } catch (error) {
        console.error('Error demoting user:', error);
        showToast('Failed to demote user.');
      }
    }
    async function deleteUser(userId) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Deleting user with token:', token.substring(0, 20) + '...', 'User ID:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Delete user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User deleted.');
          fetchUsers();
        } else {
          throw new Error('Failed to delete user');
        }
      } catch (error) {
        console.error('Error deleting user:', error);
        showToast('Failed to delete user.');
      }
    }
    async function banUser(userId) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Banning user with token:', token.substring(0, 20) + '...', 'User ID:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/ban`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('Ban user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User banned.');
          fetchUsers();
        } else {
          throw new Error('Failed to ban user');
        }
      } catch (error) {
        console.error('Error banning user:', error);
        showToast('Failed to ban user.');
      }
    }
    async function ipBanUser(userId) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('IP banning user with token:', token.substring(0, 20) + '...', 'User ID:', userId);
        const response = await fetchWithRetry(`/api/users/${userId}/ipban`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('IP ban user response:', { status: response.status, ok: response.ok });
        if (response.ok) {
          showToast('User IP banned.');
          fetchUsers();
        } else {
          throw new Error('Failed to IP ban user');
        }
      } catch (error) {
        console.error('Error IP banning user:', error);
        showToast('Failed to IP ban user.');
      }
    }
    async function loadAllUsers() {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching all users with token:', token.substring(0, 20) + '...');
        const response = await fetchWithRetry('/api/users', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('All users fetch response:', { status: response.status, ok: response.ok });
        const users = await response.json();
        displayUsers(users);
      } catch (error) {
        console.error('Error fetching all users:', error);
        showToast('Failed to fetch all users.');
      }
    }
    async function fetchUserForActivity(query) {
      try {
        const token = TokenManager.get();
        if (!TokenManager.isValid()) {
          console.error('Invalid token, showing auth form');
          TokenManager.clear();
          document.getElementById('auth-container').style.display = 'flex';
          return;
        }
        console.log('Fetching user for activity with token:', token.substring(0, 20) + '...', 'Query:', query);
        const response = await fetchWithRetry(`/api/users/search?query=${encodeURIComponent(query)}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        console.log('User for activity fetch response:', { status: response.status, ok: response.ok });
        const users = await response.json();
        if (users.length > 0) {
          loadUserActivity(users[0]._id);
        } else {
          showToast('No user found for activity.');
        }
      } catch (error) {
        console.error('Error fetching user for activity:', error);
        showToast('Failed to fetch user for activity.');
      }
    }
    // NEW: Extract socket initialization to separate function
function initSocket(token, userId) {
  console.log('Token and userId found:', { token: token.substring(0, 20) + '...', userId });
  isInitialized = true;
  socket = io({
    auth: { token },
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    timeout: 20000
  });
  socket.on('connect', () => {
    console.log('Socket.IO connected');
    showToast('Connected to server.');
    socket.emit('join', userId);
  });
  socket.on('reconnect', (attemptNumber) => {
    console.log('Reconnected after', attemptNumber, 'attempts');
    socket.emit('join', userId);
    // Resync state
    fetchCurrentAlerts();
    if (navState.isNavigating) {
      checkHazardsAndOfferReroute();
    }
  });
  socket.on('connect_error', (error) => {
    console.error('Socket.IO connection error:', error);
    showToast('Failed to connect to server.');
  });
  const debouncedAlertSync = debounce(() => pollAlerts(), 500);
  const debouncedLocationUpdate = debounce((data) => {
    // Handle location update
    updateTrackedUserLocation(data);
  }, 200);
  socket.on('alert', (alert) => {
  console.log('Received new alert via Socket.IO:', alert?._id);
  // ENHANCED validation
  if (!alert || typeof alert !== 'object' ||
      !alert._id || typeof alert._id !== 'string' ||
      !alert.location?.coordinates ||
      !Array.isArray(alert.location.coordinates) ||
      alert.location.coordinates.length !== 2 ||
      !alert.location.coordinates.every(c => typeof c === 'number' && !isNaN(c)) ||
      !alert.type || typeof alert.type !== 'string') {
    console.error('Invalid alert structure:', alert);
    return;
  }
  // Timestamp validation
  if (!alert.timestamp || new Date(alert.timestamp) > new Date()) {
    console.error('Invalid alert timestamp:', alert.timestamp);
    return;
  }
  // ... rest of handler
  if (!alert.userId || typeof alert.userId !== 'object') {
    console.warn('Alert missing userId, using fallback');
    alert.userId = { username: 'Anonymous', _id: null };
  }
  const alertId = alert._id;
  const isTrafficCamera = alert.type === 'Traffic Camera';
  // Skip if filtered out
  if (isTrafficCamera && !showTrafficCameras) {
    console.log('Skipping traffic camera alert: disabled in settings');
    return;
  }
  const filterKey = alert.type.toLowerCase().replace(/\s+/g, '-');
  if (navState.alertFilters[filterKey] === false) {
    console.log('Skipping filtered alert:', filterKey);
    return;
  }
  if (!isDuplicateAlert(alert)) {
    // Dedupe in currentAlerts
    if (!currentAlerts.some(a => a._id === alertId)) {
      currentAlerts.push(alert);
      displayAlertsInHud(currentAlerts);
      console.log('Added alert to currentAlerts via socket:', alertId);
    } else {
      console.log('Alert already in currentAlerts, skipping push:', alertId);
    }
    // Dedupe marker creation
    if (!markers.has(alertId)) {
      const marker = getMarker({
        map,
        position: { lat: alert.location.coordinates[1], lng: alert.location.coordinates[0] },
        content: isTrafficCamera ? createTrafficCameraContent() : createAlertContent(),
        title: `${alert.type} Alert`
      });
      markers.set(alertId, marker);
      console.log('Created marker for socket alert:', alertId);
    } else {
      console.log('Marker already exists for socket alert, skipping creation:', alertId);
    }
    if (isTrafficCamera) {
      cameraPositions.push({
        lat: alert.location.coordinates[1],
        lng: alert.location.coordinates[0]
      });
    } else if (navState.isNavigating) {
      checkHazardsAndOfferReroute();
    }
    showToast(`New ${alert.type} alert received.`);
  } else {
    console.log('Duplicate alert ignored via cache:', alertId);
  }
  debouncedAlertSync();
});
      socket.on('locationUpdate', debouncedLocationUpdate);
      // Add heartbeat to detect stale connections
      let heartbeatInterval = setInterval(() => {
        if (socket.connected) {
          socket.emit('heartbeat');
        }
      }, 30000);
      socket.on('disconnect', () => {
        clearInterval(heartbeatInterval);
      });
      socket.on('alertDeleted', (alertId) => {
        // FIXED: Validation already present, but ensure it's robust
        if (!alertId || typeof alertId !== 'string') {
          console.error('Invalid alertDeleted event:', alertId);
          return;
        }
        console.log('Alert deleted via Socket.IO:', alertId);
        const marker = markers.get(alertId);
        if (marker) {
          releaseMarker(marker);
          markers.delete(alertId);
        }
        currentAlerts = currentAlerts.filter(a => a._id !== alertId);
        displayAlertsInHud(currentAlerts);
        if (alertId === navState.currentHazard?._id) {
          navState.currentHazard = null;
          navState.alternativeRoute = null;
          alternativeRenderer.setMap(null);
          document.getElementById('reroute-hud-container').classList.remove('active');
          document.getElementById('reroute-hud').classList.remove('active');
          navState.alertState = 'IDLE';
          if (navState.isFollowing) {
            lockNavigation();
          }
        }
        showToast('Alert removed.');
        // Debounced full sync
        debouncedAlertSync();
      });
      socket.on('extendAlert', (alertId) => {
        // FIXED: Validation already present, but ensure it's robust
        if (!alertId || typeof alertId !== 'string') {
          console.error('Invalid extendAlert event:', alertId);
          return;
        }
        console.log('Alert duration extended:', alertId);
        showToast('Alert duration extended.');
      });
      socket.on('familyAlert', (data) => {
        console.log('Received family alert:', data);
        if (navState.familyMembers.some(m => m.email === data.user.email)) {
          showToast(`Family alert: ${data.alert.type} from ${data.user.username}`);
          if (!currentAlerts.some(a => a._id === data.alert._id)) {
            currentAlerts.push(data.alert);
            displayAlertsInHud(currentAlerts);
          }
          const marker = getMarker({
            map,
            position: { lat: data.alert.location.coordinates[1], lng: data.alert.location.coordinates[0] },
            content: data.alert.type === 'Traffic Camera' ? createTrafficCameraContent() : createAlertContent(),
            title: `${data.alert.type} Alert`
          });
          markers.set(data.alert._id, marker);
          if (data.alert.type !== 'Traffic Camera' && navState.isNavigating) {
            checkHazardsAndOfferReroute();
          }
        }
      });
      socket.on('premiumActivated', (data) => {
        console.log('Premium activated via Socket.IO:', data);
        checkSubscriptionStatus(); // Refresh status
        showToast('ðŸŽ‰ Premium activated! Welcome!');
      });
}
    // Subscription & Trial Management
const PREMIUM_FEATURES = [
  'traffic-camera-toggle',
  'multi-stop-toggle',
  'traffic-forecast-toggle',
  'ev-charging-toggle',
  'offline-download-btn',
  'add-family-btn',
  'route-preset',
  'leaderboard-button'
];
let subscriptionStatus = {
  isPremium: false,
  isTrialActive: false,
  trialDaysRemaining: 0,
  trialEndsAt: null
};
async function checkSubscriptionStatus() {
  try {
    const token = TokenManager.get();
    if (!TokenManager.isValid()) return;
    // âœ… Force cache bypass with timestamp
    const cacheBuster = Date.now();
    const response = await fetch(`/api/subscription/status?_=${cacheBuster}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache'
      },
      cache: 'no-store' // â† Force fresh fetch
    });
    if (!response.ok) throw new Error('Failed to check subscription');
    subscriptionStatus = await response.json();
    console.log('ðŸ” Subscription Check:', subscriptionStatus);
    updateUIForSubscription();
    // âœ… Show upgrade modal if trial ended
    if (!subscriptionStatus.isPremium && !subscriptionStatus.isTrialActive) {
      const lastShown = localStorage.getItem('lastUpgradePrompt');
      const now = Date.now();
      if (!lastShown || now - parseInt(lastShown) > 2 * 24 * 60 * 60 * 1000) {
        showUpgradeModal('trial_ended');
        localStorage.setItem('lastUpgradePrompt', now.toString());
      }
    }
  } catch (error) {
    console.error('Subscription status error:', error);
  }
}
function updateUIForSubscription() {
  // === FIXED: Always calculate hasAccess FIRST ===
  const hasAccess = subscriptionStatus.isPremium ||
                    (subscriptionStatus.isTrialActive && subscriptionStatus.trialDaysRemaining > 0);
  console.log('ðŸ” Access Check:', {
    isPremium: subscriptionStatus.isPremium,
    isTrialActive: subscriptionStatus.isTrialActive,
    trialDaysRemaining: subscriptionStatus.trialDaysRemaining,
    hasAccess
  });
  const trialBanner = document.getElementById('trial-banner');
  // === Hide banner ONLY if premium OR no active trial ===
  if (subscriptionStatus.isPremium) {
    trialBanner.style.display = 'none';
    localStorage.removeItem('trialBannerHiddenAt');
    console.log('âœ… Banner hidden - user is premium');
  } else if (subscriptionStatus.isTrialActive && subscriptionStatus.trialDaysRemaining > 0) {
    // === Show banner for ACTIVE trial ===
    const trialDaysSpan = document.getElementById('trial-days-remaining');
    const hiddenAt = localStorage.getItem('trialBannerHiddenAt');
    const now = Date.now();
    const shouldShow = (!hiddenAt || now - parseInt(hiddenAt) > 48 * 60 * 60 * 1000); // 48hr cooldown
    if (shouldShow) {
      trialBanner.style.display = 'flex';
      trialDaysSpan.textContent = subscriptionStatus.trialDaysRemaining;
      trialBanner.onclick = (e) => {
        if (e.target.id !== 'trial-banner-close') {
          showUpgradeModal('banner_click');
        }
      };
      console.log('âœ… Banner shown - trial active, days left:', subscriptionStatus.trialDaysRemaining);
    } else {
      trialBanner.style.display = 'none';
    }
  } else {
    // No premium, no trial â†’ hide banner
    trialBanner.style.display = 'none';
    console.log('Banner hidden - no premium or active trial');
  }
  // === Lock/Unlock Features ===
  PREMIUM_FEATURES.forEach(featureId => {
    const el = document.getElementById(featureId);
    if (!el) return;
    if (hasAccess) {
      el.classList.remove('locked-feature');
      el.disabled = false;
      el.style.pointerEvents = 'auto';
      el.onclick = null;
    } else {
      el.classList.add('locked-feature');
      el.disabled = true;
      el.style.pointerEvents = 'auto';
      el.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        showUpgradeModal('feature_click');
        return false;
      };
    }
  });
  // === Lock Premium Report Buttons ===
  document.querySelectorAll('.report-button').forEach(btn => {
    const type = btn.getAttribute('data-alert-type');
    const isPremiumType = ['Traffic Camera', 'Manual Traffic Camera', 'Construction', 'Lane Closure'].includes(type);
    if (isPremiumType && !hasAccess) {
      btn.classList.add('locked-feature');
      btn.style.pointerEvents = 'auto';
      btn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        showUpgradeModal('feature_click');
        return false;
      };
    } else {
      btn.classList.remove('locked-feature');
      btn.onclick = null; // Restore original onclick if it exists
    }
  });
  console.log('âœ… UI updated - hasAccess:', hasAccess);
}
function showUpgradeModal(source) {
  const modal = document.getElementById('subscription-modal');
  const title = document.getElementById('modal-title');
  const message = document.getElementById('modal-message');
  const trialInfo = document.getElementById('trial-info-box');
  const trialText = document.getElementById('trial-status-text');
  if (subscriptionStatus.isTrialActive) {
    title.textContent = 'â° Trial Ending Soon';
    message.textContent = `You have ${subscriptionStatus.trialDaysRemaining} days left in your free trial. Upgrade now to ensure uninterrupted access to all premium features!`;
    trialInfo.style.display = 'block';
    trialText.textContent = `Trial ends on ${new Date(subscriptionStatus.trialEndsAt).toLocaleDateString()}`;
  } else {
    title.textContent = 'ðŸš€ Unlock Premium Features';
    message.textContent = 'Your 7-day free trial has ended. Upgrade to Premium to continue enjoying all features!';
    trialInfo.style.display = 'none';
  }
  modal.style.display = 'flex';
  // Trigger animation
  requestAnimationFrame(() => {
    modal.classList.add('show');
  });
  console.log('Upgrade modal shown, source:', source);
}
document.getElementById('upgrade-button').addEventListener('click', async () => {
  const button = document.getElementById('upgrade-button');
  button.disabled = true;
  button.textContent = 'Processing...';
  try {
    const token = TokenManager.get();
    if (!TokenManager.isValid()) {
      showToast('Please log in to upgrade');
      return;
    }
    showToast('Redirecting to payment...');
    const response = await fetchWithRetry('/api/subscription/create-checkout', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });
    if (!response.ok) throw new Error('Failed to create checkout session');
    const { url } = await response.json();
    window.location.href = url; // Redirect to Stripe Checkout
  } catch (error) {
    console.error('Error creating checkout:', error);
    showToast('Failed to start checkout process. Please try again.');
  } finally {
    button.disabled = false;
    button.textContent = 'Upgrade Now';
  }
});
document.getElementById('maybe-later-button').addEventListener('click', () => {
  const modal = document.getElementById('subscription-modal');
  modal.classList.remove('show');
  setTimeout(() => {
    modal.style.display = 'none';
  }, 300); // Match transition duration
  if (!subscriptionStatus.isPremium && !subscriptionStatus.isTrialActive) {
    showToast('Reminder: You can upgrade anytime from Settings');
  }
  console.log('Upgrade modal dismissed');
});
// Handle payment success callback
async function handlePaymentCallback() {
  const urlParams = new URLSearchParams(window.location.search);
  const sessionId = urlParams.get('session_id');
  const paymentStatus = urlParams.get('payment');
  if (sessionId && paymentStatus === 'success') {
    // Hide banner IMMEDIATELY
    document.getElementById('trial-banner').style.display = 'none';
    createCelebration();
    showToast('ðŸŽ‰ Payment successful! Activating premium...', 5000);
    const token = TokenManager.get();
    if (!TokenManager.isValid()) {
      showToast('Please log in to complete activation');
      window.history.replaceState({}, '', window.location.pathname);
      return;
    }
    let attempts = 0;
    const MAX_ATTEMPTS = 40; // Increase to 40 seconds
    let pollTimeoutId = null;
    const checkStatus = async () => {
      attempts++;
      try {
        const response = await fetch('/api/subscription/status', {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Cache-Control': 'no-cache, no-store, must-revalidate'
          },
          cache: 'no-store'
        });
        if (!response.ok) throw new Error('Status check failed');
        const status = await response.json();
        if (status.isPremium) {
          clearTimeout(pollTimeoutId); // âœ… Cancel polling
          showToast('âœ… Premium activated! Reloading...', 3000);
      
          // Clear URL cleanly
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
      
          setTimeout(() => window.location.reload(true), 2000);
          return;
        }
      
        if (attempts < MAX_ATTEMPTS) {
          pollTimeoutId = setTimeout(checkStatus, 1000);
        } else {
          clearTimeout(pollTimeoutId);
          showToast('âš ï¸ Activation taking longer than expected. Please refresh manually.', 10000);
          window.history.replaceState({}, document.title, cleanUrl);
        }
      } catch (error) {
        console.error('Polling error:', error);
        if (attempts < MAX_ATTEMPTS) {
          pollTimeoutId = setTimeout(checkStatus, 1000);
        }
      }
    };
    checkStatus();
  }
}
async function cancelSubscription() {
  try {
    const token = TokenManager.get();
    const response = await fetchWithRetry('/api/subscription/cancel', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` }
    });
    if (!response.ok) throw new Error('Failed to cancel subscription');
    showToast('Subscription cancelled. You\'ll have access until the end of your billing period.');
    await checkSubscriptionStatus();
  } catch (error) {
    console.error('Error cancelling subscription:', error);
    showToast('Failed to cancel subscription. Please try again.');
  }
}
// Initialize subscription check on app load
function initSubscription() {
  checkSubscriptionStatus();
  // Check subscription status periodically (every hour)
  setInterval(checkSubscriptionStatus, 60 * 60 * 1000);
}
// Trial banner close handler
document.getElementById('trial-banner-close').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('trial-banner').style.display = 'none';
  localStorage.setItem('trialBannerHiddenAt', Date.now().toString());
  console.log('Trial banner hidden');
});
// Add upgrade button to settings
document.getElementById('edit-profile-button').insertAdjacentHTML('afterend', `
  <button id="manage-subscription-button" style="margin: 0.5vmin; padding: 0.8vmin 1.5vmin; border: none; border-radius: 0.4rem; cursor: pointer; font-size: clamp(10px, 2vmin, 14px); color: white; background-color: #FFD700;">
    Manage Subscription
  </button>
`);
document.getElementById('manage-subscription-button').addEventListener('click', () => {
  if (subscriptionStatus.isPremium) {
    // Show manage options
    if (confirm('Do you want to cancel your premium subscription?')) {
      cancelSubscription();
    }
  } else {
    showUpgradeModal('settings');
  }
});
async function requestStorageAccess() {
  if ('requestStorageAccess' in document) {
    try {
      await document.requestStorageAccess();
      console.log('âœ… Storage access granted');
      return true;
    } catch (error) {
      console.warn('âŒ Storage access denied:', error);
      showToast('Please disable Strict Tracking Protection for this site');
      return false;
    }
  }
  return true; // Not Firefox or already permitted
}
async function ensureValidToken() {
  if (!TokenManager.isValid()) {
    const refreshed = await refreshToken();
    if (!refreshed) {
      console.log('Token refresh failed, showing auth form');
      document.getElementById('auth-container').style.display = 'flex';
      return false;
    }
  }
  return true;
}
async function initApp() {
  // ... existing location code ...
  const userId = localStorage.getItem('userId') || sessionStorage.getItem('userId');
  if (!await ensureValidToken() || !userId) {
    document.getElementById('auth-container').style.display = 'flex';
    return; // Don't proceed without valid auth
  }
  // ... rest of init ...
  console.log('Initializing app...');
  // âœ… Request storage access first
  const hasStorageAccess = await requestStorageAccess();
  if (!hasStorageAccess && window.location.search.includes('payment=success')) {
    // Can't proceed with payment callback without storage
    showToast('Storage access required. Please allow and refresh.');
    return;
  }
  // â† FIX: Initialize map FIRST, regardless of auth status
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        navState.userLocation = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };
        rawUserLocation = navState.userLocation;
        console.log('Initial location:', navState.userLocation);
        requestDeviceOrientationPermission();
        loadGoogleMaps(); // â† Map loads here
      },
      (error) => {
        console.error('Initial geolocation error:', error);
        handleGeolocationError(error, true);
      },
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
      }
    );
  } else {
    console.error('Geolocation not supported');
    showToast('Geolocation not supported by this browser.');
    navState.userLocation = { lat: 33.083270, lng: -83.233040 };
    rawUserLocation = navState.userLocation;
    loadGoogleMaps(); // â† Fallback map load
  }
  // Check auth AFTER starting map load
  if (!TokenManager.isValid() || !userId) {
    console.log('No valid token or userId, showing auth form');
    TokenManager.clear();
    document.getElementById('auth-container').style.display = 'flex';
    // Don't return early - let map still load
  } else {
    initSocket(TokenManager.get(), userId);
    // âœ… FIX: Only init subscription if NOT in payment callback
    if (!window.location.search.includes('payment=success')) {
      initSubscription();
    } else {
      // Let handlePaymentCallback() handle it
      handlePaymentCallback();
    }
  }
  // Service Worker registration
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').then(reg => {
      console.log('Service Worker registered:', reg);
      if (pushNotificationsEnabled) {
        requestPushPermission();
      }
    }).catch(err => {
      console.error('Service Worker registration failed:', err);
    });
  }
  console.log('App initialization complete');
}
    // Call initApp on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
    // Add periodic cleanup
setInterval(() => {
  if (markerPool.length > MAX_MARKER_POOL_SIZE) {
    const excess = markerPool.length - MAX_MARKER_POOL_SIZE;
    markerPool.splice(0, excess);
    console.log(`Cleaned ${excess} excess markers from pool`);
  }
}, 60000); // Every minute
  </script>
</body>
</html>